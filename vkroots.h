// The vkroots.h header is licensed under Apache-2.0 OR MIT
// as it was generated from the Vulkan Registry, which is licensed
// under the same license.

#pragma once

#include <vulkan/vk_layer.h>
#include <vulkan/vulkan.h>

#include <cstring>
#include <unordered_map>
#include <memory>
#include <mutex>
#include <type_traits>
#include <memory>
#include <cassert>
#include <vector>
#include <utility>
#include <optional>
#include <string_view>
#include <array>
#include <functional>
#include <shared_mutex>
#include <atomic>
#include <ranges>
#include <format>
#include <iostream>
#include <algorithm>

#define VKROOTS_VERSION_MAJOR 0
#define VKROOTS_VERSION_MINOR 1
#define VKROOTS_VERSION_PATCH 0

#define VKROOTS_VERSION VK_MAKE_API_VERSION(0, VKROOTS_VERSION_MAJOR, VKROOTS_VERSION_MINOR, VKROOTS_VERSION_PATCH)

namespace vkroots {

  class GenericUserData {
  public:
    GenericUserData() {}
    ~GenericUserData() {
      destroy();
    }

    template <typename T, typename... Args>
    void emplace(Args&&... args) {
      destroy();

      m_data = new T{ std::forward<Args>(args)... };
      m_type = []() -> std::type_info const&{ return typeid(T); };
      m_destroy = [](void* data) -> void { delete static_cast<T*>(data); };
    }

    template <typename T>
    void set(T* ptr) {
      m_data = ptr;
      m_type = []() -> std::type_info const&{ return typeid(T*); };
      m_destroy = [](void* data) -> void {}; // Do nothing for implicit ptrs.
    }

    bool has() {
      return m_data != nullptr;
    }

    const std::type_info &type() {
      if (!has())
        return typeid(nullptr);
      return m_type();
    }

    void destroy() {
      if (!m_data)
        return;
      m_destroy(m_data);
      m_data = nullptr;
    }

    template <typename T>
    T& cast() {
      assert(type() == typeid(T));
      return *static_cast<T*>(m_data);
    }

    template <typename T>
    operator T& () {
      return cast<T>();
    }

    operator bool() {
      return has();
    }

  private:
    void* m_data = nullptr;
    std::type_info const &(*m_type)() = nullptr;
    void (*m_destroy)(void *data) = nullptr;
  };

  template <typename T>
  T& userdata_cast(GenericUserData &userdata) {
    return userdata.cast<T>();
  }

}
namespace vkroots {

  // Consistency!
  using PFN_vkGetPhysicalDeviceProcAddr = PFN_GetPhysicalDeviceProcAddr;

  class VkInstanceDispatch;
  class VkPhysicalDeviceDispatch;
  class VkDeviceDispatch;
  class VkQueueDispatch;
  class VkCommandBufferDispatch;
  class VkExternalComputeQueueNVDispatch;

  class NoOverrides { static constexpr bool IsNoOverrides = true; };

  template <typename Type>
  constexpr VkStructureType ResolveSType();

  template <> constexpr VkStructureType ResolveSType<VkLayerInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<VkLayerDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO; }

  template <typename T>
  static constexpr bool TypeIsSinglePointer() {
    // If we aren't a pointer at all, return false
    // eg. int
    if (!std::is_pointer<T>::value)
      return false;

    // If we are still a pointer after removing pointer, return false.
    // eg. void**
    if (std::is_pointer<typename std::remove_pointer<T>::type>::value)
      return false;

    // Must be a single * ptr.
    return true;
  }

  template <typename Type, typename AnyStruct>
  const Type* FindInChain(const AnyStruct* obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (const VkBaseInStructure* header = reinterpret_cast<const VkBaseInStructure*>(obj); header; header = header->pNext) {
      if (header->sType == ResolveSType<Type>())
        return reinterpret_cast<const Type*>(header);
    }
    return nullptr;
  }

  template <typename Type, typename AnyStruct>
  Type* FindInChainMutable(AnyStruct* obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (VkBaseOutStructure* header = reinterpret_cast<VkBaseOutStructure*>(obj); header; header = header->pNext) {
      if (header->sType == ResolveSType<Type>())
        return reinterpret_cast<Type*>(header);
    }
    return nullptr;
  }

  template <typename Type, typename AnyStruct>
  std::tuple<Type *, VkBaseOutStructure *> RemoveFromChain(AnyStruct *obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (VkBaseOutStructure* header = reinterpret_cast<VkBaseOutStructure*>(obj); header; header = header->pNext) {
      VkBaseOutStructure *pNextInChain = header->pNext;
      if (pNextInChain && pNextInChain->sType == ResolveSType<Type>()) {
        header->pNext = pNextInChain->pNext;
        return std::make_tuple(reinterpret_cast<Type*>(pNextInChain), header);
      }
    }
    return std::make_tuple(nullptr, nullptr);
  }

  template <typename Type, typename AnyStruct>
  Type *AddToChain(AnyStruct *pParent, Type *pType) {
    static_assert(TypeIsSinglePointer<decltype(pParent)>());
    static_assert(TypeIsSinglePointer<decltype(pType)>());

    void **ppParentNext = reinterpret_cast<void **>(&pParent->pNext);
    void **ppTypeNext   = reinterpret_cast<void **>(&pType->pNext);

    *ppTypeNext = std::exchange(*ppParentNext, reinterpret_cast<void *>(pType));
    return pType;
  }

  // RwLock impl by doitsujin
  class RwLock {
    static constexpr uint32_t ReadBit  = 1u;
    static constexpr uint32_t WriteBit = 1u << 31u;
  public:

    RwLock() = default;

    RwLock(const RwLock&) = delete;

    RwLock& operator = (const RwLock&) = delete;

    void lock() {
      auto value = m_lock.load(std::memory_order_relaxed);

      while (value || !m_lock.compare_exchange_strong(value, WriteBit, std::memory_order_acquire, std::memory_order_relaxed)) {
        m_lock.wait(value, std::memory_order_acquire);
        value = m_lock.load(std::memory_order_relaxed);
      }
    }

    bool try_lock() {
      auto value = m_lock.load(std::memory_order_relaxed);

      if (value)
        return false;

      return m_lock.compare_exchange_strong(value, WriteBit, std::memory_order_acquire, std::memory_order_relaxed);
    }

    void unlock() {
      m_lock.store(0u, std::memory_order_release);
      m_lock.notify_all();
    }

    void lock_shared() {
      auto value = m_lock.load(std::memory_order_relaxed);

      do {
        while (value & WriteBit) {
          m_lock.wait(value, std::memory_order_acquire);
          value = m_lock.load(std::memory_order_relaxed);
        }
      } while (!m_lock.compare_exchange_strong(value, value + ReadBit, std::memory_order_acquire, std::memory_order_relaxed));
    }

    bool try_lock_shared() {
      auto value = m_lock.load(std::memory_order_relaxed);

      if (value & WriteBit)
        return false;

      return m_lock.compare_exchange_strong(value, value + ReadBit, std::memory_order_acquire, std::memory_order_relaxed);
    }

    void unlock_shared() {
      m_lock.fetch_sub(ReadBit, std::memory_order_release);
      m_lock.notify_one();
    }

  private:

    std::atomic<uint32_t> m_lock = { 0u };

  };

  template <typename K, typename V>
  class ObjectMap {
  public:

    V *find(const K& key) const {
      std::shared_lock lock(m_lock);

      auto entry = m_map.find(key);

      if (entry == m_map.end())
        return nullptr;

      return entry->second.get();
    }


    template<typename... Args>
    V* create(const K& key, Args&&... args) {
      std::unique_lock lock(m_lock);

      auto result = m_map.emplace(std::piecewise_construct,
        std::tuple(key),
        std::tuple());

      if (!result.second)
        return nullptr;

      result.first->second = std::make_unique<V>(std::forward<Args>(args)...);
      return result.first->second.get();
    }

    void erase(const K& key) {
      std::unique_lock lock(m_lock);
      m_map.erase(key);
    }
  private:
    std::unordered_map<K, std::unique_ptr<V>> m_map;
    mutable RwLock m_lock;
  };

  namespace tables {

    // All our dispatchables...
    inline ObjectMap<VkInstance,               const VkInstanceDispatch>               InstanceDispatches;
    inline ObjectMap<VkPhysicalDevice,         const VkPhysicalDeviceDispatch>         PhysicalDeviceDispatches;
    inline ObjectMap<VkDevice,                 const VkDeviceDispatch>                 DeviceDispatches;
    inline ObjectMap<VkQueue,                  const VkQueueDispatch>                  QueueDispatches;
    inline ObjectMap<VkCommandBuffer,          const VkCommandBufferDispatch>          CommandBufferDispatches;
    inline ObjectMap<VkExternalComputeQueueNV, const VkExternalComputeQueueNVDispatch> ExternalComputeQueueDispatches;

    static inline void CreateDispatchTable(PFN_vkGetInstanceProcAddr nextInstanceProcAddr, PFN_GetPhysicalDeviceProcAddr nextPhysDevProcAddr, VkInstance instance);
    static inline void CreateDispatchTable(const VkDeviceCreateInfo* pCreateInfo, PFN_vkGetDeviceProcAddr nextProcAddr, VkPhysicalDevice physicalDevice, VkDevice device);
    static inline void DestroyDispatchTable(VkInstance instance);
    static inline void DestroyDispatchTable(VkDevice device);

    static inline const VkPhysicalDeviceDispatch *AssignDispatchTable(VkPhysicalDevice physDev, const VkInstanceDispatch *pDispatch) { return PhysicalDeviceDispatches.create(physDev, physDev, pDispatch); }
    static inline const VkCommandBufferDispatch *AssignDispatchTable(VkCommandBuffer cmdBuffer, const VkDeviceDispatch *pDispatch) { return CommandBufferDispatches.create(cmdBuffer, cmdBuffer, pDispatch); }
    static inline const VkQueueDispatch *AssignDispatchTable(VkQueue queue, const VkDeviceDispatch *pDispatch) { return QueueDispatches.create(queue, queue, pDispatch); }
    static inline const VkExternalComputeQueueNVDispatch *AssignDispatchTable(VkExternalComputeQueueNV queue, const VkDeviceDispatch *pDispatch) { return ExternalComputeQueueDispatches.create(queue, queue, pDispatch); }
    static inline void UnassignDispatchTable(VkPhysicalDevice physDev) { PhysicalDeviceDispatches.erase(physDev); }
    static inline void UnassignDispatchTable(VkCommandBuffer cmdBuffer) { CommandBufferDispatches.erase(cmdBuffer); }
    static inline void UnassignDispatchTable(VkQueue queue) { QueueDispatches.erase(queue); }
    static inline void UnassignDispatchTable(VkExternalComputeQueueNV queue) { ExternalComputeQueueDispatches.erase(queue); }
  }

  static inline const VkInstanceDispatch*               LookupDispatch        (VkInstance instance)                             { return tables::InstanceDispatches.find(instance); }
  static inline const VkPhysicalDeviceDispatch*         LookupDispatch        (VkPhysicalDevice physicalDevice)                 { return tables::PhysicalDeviceDispatches.find(physicalDevice); }
  static inline const VkDeviceDispatch*                 LookupDispatch        (VkDevice device)                                 { return tables::DeviceDispatches.find(device); }
  static inline const VkQueueDispatch*                  LookupDispatch        (VkQueue device)                                  { return tables::QueueDispatches.find(device); }
  static inline const VkCommandBufferDispatch*          LookupDispatch        (VkCommandBuffer cmdBuffer)                       { return tables::CommandBufferDispatches.find(cmdBuffer); }
  static inline const VkExternalComputeQueueNVDispatch* LookupDispatch        (VkExternalComputeQueueNV externalComputeQueueNV) { return tables::ExternalComputeQueueDispatches.find(externalComputeQueueNV); }

  struct VkInstanceProcAddrFuncs {
    PFN_vkGetInstanceProcAddr NextGetInstanceProcAddr;
    PFN_vkGetPhysicalDeviceProcAddr NextGetPhysicalDeviceProcAddr;
  };

  static inline VkResult GetProcAddrs(const VkInstanceCreateInfo* pInfo, VkInstanceProcAddrFuncs *pOutFuncs) {
    const void* pNext = (const void*) pInfo;
    const VkLayerInstanceCreateInfo* layerInfo;
    while ((layerInfo = FindInChain<const VkLayerInstanceCreateInfo>(pNext)) && layerInfo->function != VK_LAYER_LINK_INFO)
      pNext = layerInfo->pNext;
    assert(layerInfo);
    if (!layerInfo)
      return VK_ERROR_INITIALIZATION_FAILED;
    *pOutFuncs = VkInstanceProcAddrFuncs{ layerInfo->u.pLayerInfo->pfnNextGetInstanceProcAddr, layerInfo->u.pLayerInfo->pfnNextGetPhysicalDeviceProcAddr };
    // Josh:
    // It really sucks that we have to advance this ourselves given the const situation here... 
    VkLayerInstanceCreateInfo* layerInfoMutable = const_cast<VkLayerInstanceCreateInfo *>(layerInfo);
    layerInfoMutable->u.pLayerInfo = layerInfoMutable->u.pLayerInfo->pNext;
    return VK_SUCCESS;
  }

  static inline VkResult GetProcAddrs(const VkDeviceCreateInfo* pInfo, PFN_vkGetDeviceProcAddr *pOutAddr) {
    const void* pNext = (const void*) pInfo;
    const VkLayerDeviceCreateInfo* layerInfo;
    while ((layerInfo = FindInChain<const VkLayerDeviceCreateInfo>(pNext)) && layerInfo->function != VK_LAYER_LINK_INFO)
      pNext = layerInfo->pNext;
    assert(layerInfo);
    if (!layerInfo)
      return VK_ERROR_INITIALIZATION_FAILED;
    *pOutAddr = layerInfo->u.pLayerInfo->pfnNextGetDeviceProcAddr;
    // Josh:
    // It really sucks that we have to advance this ourselves given the const situation here... 
    VkLayerDeviceCreateInfo* layerInfoMutable = const_cast<VkLayerDeviceCreateInfo *>(layerInfo);
    layerInfoMutable->u.pLayerInfo = layerInfoMutable->u.pLayerInfo->pNext;
    return VK_SUCCESS;
  }

}
namespace vkroots {
  static VkResult implicit_wrap_CreateInstance(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);

  template <typename InstanceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetPhysicalDeviceProcAddr(VkInstance instance, const char* name);

  class VkInstanceDispatch {
  public:
    VkInstanceDispatch(PFN_vkGetInstanceProcAddr NextGetInstanceProcAddr, VkInstance instance, PFN_vkGetPhysicalDeviceProcAddr NextGetPhysicalDeviceProcAddr) {
      this->Instance = instance;
      this->m_GetPhysicalDeviceProcAddr = NextGetPhysicalDeviceProcAddr;
      this->m_AcquireDrmDisplayEXT = (PFN_vkAcquireDrmDisplayEXT) NextGetInstanceProcAddr(instance, "vkAcquireDrmDisplayEXT");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_AcquireWinrtDisplayNV = (PFN_vkAcquireWinrtDisplayNV) NextGetInstanceProcAddr(instance, "vkAcquireWinrtDisplayNV");
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
      this->m_AcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT) NextGetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT");
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->m_CreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateAndroidSurfaceKHR");
#endif
      this->m_CreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT) NextGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
      this->m_CreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT) NextGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
      this->m_CreateDevice = (PFN_vkCreateDevice) NextGetInstanceProcAddr(instance, "vkCreateDevice");
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
      this->m_CreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateDirectFBSurfaceEXT");
#endif
      this->m_CreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR) NextGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR");
      this->m_CreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR");
      this->m_CreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateHeadlessSurfaceEXT");
#ifdef VK_USE_PLATFORM_IOS_MVK
      this->m_CreateIOSSurfaceMVK = (PFN_vkCreateIOSSurfaceMVK) NextGetInstanceProcAddr(instance, "vkCreateIOSSurfaceMVK");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_CreateImagePipeSurfaceFUCHSIA = (PFN_vkCreateImagePipeSurfaceFUCHSIA) NextGetInstanceProcAddr(instance, "vkCreateImagePipeSurfaceFUCHSIA");
#endif
      this->m_CreateInstance = (PFN_vkCreateInstance) NextGetInstanceProcAddr(instance, "vkCreateInstance");
#ifdef VK_USE_PLATFORM_MACOS_MVK
      this->m_CreateMacOSSurfaceMVK = (PFN_vkCreateMacOSSurfaceMVK) NextGetInstanceProcAddr(instance, "vkCreateMacOSSurfaceMVK");
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->m_CreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT");
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->m_CreateScreenSurfaceQNX = (PFN_vkCreateScreenSurfaceQNX) NextGetInstanceProcAddr(instance, "vkCreateScreenSurfaceQNX");
#endif
#ifdef VK_USE_PLATFORM_GGP
      this->m_CreateStreamDescriptorSurfaceGGP = (PFN_vkCreateStreamDescriptorSurfaceGGP) NextGetInstanceProcAddr(instance, "vkCreateStreamDescriptorSurfaceGGP");
#endif
#ifdef VK_USE_PLATFORM_OHOS
      this->m_CreateSurfaceOHOS = (PFN_vkCreateSurfaceOHOS) NextGetInstanceProcAddr(instance, "vkCreateSurfaceOHOS");
#endif
#ifdef VK_USE_PLATFORM_VI_NN
      this->m_CreateViSurfaceNN = (PFN_vkCreateViSurfaceNN) NextGetInstanceProcAddr(instance, "vkCreateViSurfaceNN");
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      this->m_CreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateWaylandSurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
      this->m_CreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateXcbSurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
      this->m_CreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateXlibSurfaceKHR");
#endif
      this->m_DebugReportMessageEXT = (PFN_vkDebugReportMessageEXT) NextGetInstanceProcAddr(instance, "vkDebugReportMessageEXT");
      this->m_DestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT) NextGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
      this->m_DestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT) NextGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
      this->m_DestroyInstance = (PFN_vkDestroyInstance) NextGetInstanceProcAddr(instance, "vkDestroyInstance");
      this->m_DestroySurfaceKHR = (PFN_vkDestroySurfaceKHR) NextGetInstanceProcAddr(instance, "vkDestroySurfaceKHR");
      this->m_EnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties) NextGetInstanceProcAddr(instance, "vkEnumerateDeviceExtensionProperties");
      this->m_EnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties) NextGetInstanceProcAddr(instance, "vkEnumerateDeviceLayerProperties");
      this->m_EnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroups");
      this->m_EnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroupsKHR");
      this->m_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
      this->m_EnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDevices");
      this->m_GetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetDisplayModeProperties2KHR");
      this->m_GetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR");
      this->m_GetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR) NextGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilities2KHR");
      this->m_GetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR");
      this->m_GetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR");
      this->m_GetDrmDisplayEXT = (PFN_vkGetDrmDisplayEXT) NextGetInstanceProcAddr(instance, "vkGetDrmDisplayEXT");
      this->m_GetInstanceProcAddr = NextGetInstanceProcAddr;
      this->m_GetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
      this->m_GetPhysicalDeviceCalibrateableTimeDomainsKHR = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR");
      this->m_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV");
      this->m_GetPhysicalDeviceCooperativeMatrixPropertiesKHR = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
      this->m_GetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
      this->m_GetPhysicalDeviceCooperativeVectorPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV");
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
      this->m_GetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
#endif
      this->m_GetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
      this->m_GetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
      this->m_GetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayProperties2KHR");
      this->m_GetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
      this->m_GetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferProperties");
      this->m_GetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
      this->m_GetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFenceProperties");
      this->m_GetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
      this->m_GetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
      this->m_GetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties");
      this->m_GetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
      this->m_GetPhysicalDeviceExternalTensorPropertiesARM = (PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalTensorPropertiesARM");
      this->m_GetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures");
      this->m_GetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2");
      this->m_GetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2KHR");
      this->m_GetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties");
      this->m_GetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2");
      this->m_GetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2KHR");
      this->m_GetPhysicalDeviceFragmentShadingRatesKHR = (PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR");
      this->m_GetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties");
      this->m_GetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2");
      this->m_GetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR");
      this->m_GetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties");
      this->m_GetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2");
      this->m_GetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR");
      this->m_GetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
      this->m_GetPhysicalDeviceOpticalFlowImageFormatsNV = (PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
      this->m_GetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDevicePresentRectanglesKHR");
      this->m_GetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties");
      this->m_GetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2");
      this->m_GetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2KHR");
      this->m_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = (PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM");
      this->m_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = (PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM");
      this->m_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
      this->m_GetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties");
      this->m_GetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2");
      this->m_GetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->m_GetPhysicalDeviceScreenPresentationSupportQNX = (PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceScreenPresentationSupportQNX");
#endif
      this->m_GetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties");
      this->m_GetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2");
      this->m_GetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
      this->m_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = (PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
      this->m_GetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
      this->m_GetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
      this->m_GetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
      this->m_GetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
      this->m_GetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
#endif
      this->m_GetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
      this->m_GetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceSupportKHR");
      this->m_GetPhysicalDeviceToolProperties = (PFN_vkGetPhysicalDeviceToolProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolProperties");
      this->m_GetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolPropertiesEXT");
      this->m_GetPhysicalDeviceVideoCapabilitiesKHR = (PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR");
      this->m_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR");
      this->m_GetPhysicalDeviceVideoFormatPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoFormatPropertiesKHR");
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      this->m_GetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
      this->m_GetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
      this->m_GetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
      this->m_GetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT) NextGetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetWinrtDisplayNV = (PFN_vkGetWinrtDisplayNV) NextGetInstanceProcAddr(instance, "vkGetWinrtDisplayNV");
#endif
      this->m_ReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT) NextGetInstanceProcAddr(instance, "vkReleaseDisplayEXT");
      this->m_SubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT) NextGetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT");
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    PFN_vkVoidFunction GetPhysicalDeviceProcAddr(VkInstance instance, const char *pName) const { return m_GetPhysicalDeviceProcAddr(instance, pName); }    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return m_AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return m_AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return m_AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return m_CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return m_CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }

  VkResult CreateDevice(
            VkPhysicalDevice       physicalDevice,
      const VkDeviceCreateInfo*    pCreateInfo,
      const VkAllocationCallbacks* pAllocator,
            VkDevice*              pDevice) const {
    PFN_vkGetDeviceProcAddr deviceProcAddr;
    VkResult procAddrRes = GetProcAddrs(pCreateInfo, &deviceProcAddr);
    if (procAddrRes != VK_SUCCESS)
      return procAddrRes;
    VkResult ret = m_CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
    if (ret == VK_SUCCESS)
      tables::CreateDispatchTable(pCreateInfo, deviceProcAddr, physicalDevice, *pDevice);
    return ret;
  }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return m_CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return m_CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return m_CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { m_DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { m_DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { m_DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyInstance(VkInstance object, const VkAllocationCallbacks* pAllocator) const {
      vkroots::tables::DestroyDispatchTable(object);
      m_DestroyInstance(object, pAllocator);
    }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { m_DestroySurfaceKHR(instance, surface, pAllocator); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return m_EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return m_EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return m_EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return m_EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return m_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return m_EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return m_GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return m_GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return m_GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return m_GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return m_GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return m_GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return m_GetInstanceProcAddr(instance, pName); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return m_GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return m_GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return m_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return m_GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return m_GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return m_GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return m_GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return m_GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return m_GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return m_GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return m_GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { m_GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { m_GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { m_GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { m_GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return m_GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { m_GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { m_GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { m_GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { m_GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { m_GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { m_GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { m_GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { m_GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { m_GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return m_GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return m_GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return m_GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return m_GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { m_GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { m_GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { m_GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { m_GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return m_GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return m_GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { m_GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { m_GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { m_GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { m_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return m_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { m_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { m_GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { m_GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { m_GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return m_GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { m_GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { m_GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { m_GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return m_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return m_GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return m_GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return m_GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return m_GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return m_GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return m_GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return m_GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return m_GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return m_GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return m_GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return m_GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return m_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return m_GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return m_GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return m_GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return m_GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return m_GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return m_GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return m_GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return m_ReleaseDisplayEXT(physicalDevice, display); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { m_SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
  public:
    VkInstance Instance;
    mutable std::vector<VkPhysicalDevice> PhysicalDevices;
    mutable std::vector<const vkroots::VkPhysicalDeviceDispatch *> PhysicalDeviceDispatches;
  private:
    PFN_GetPhysicalDeviceProcAddr m_GetPhysicalDeviceProcAddr;
    PFN_vkAcquireDrmDisplayEXT m_AcquireDrmDisplayEXT;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkAcquireWinrtDisplayNV m_AcquireWinrtDisplayNV;
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    PFN_vkAcquireXlibDisplayEXT m_AcquireXlibDisplayEXT;
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkCreateAndroidSurfaceKHR m_CreateAndroidSurfaceKHR;
#endif
    PFN_vkCreateDebugReportCallbackEXT m_CreateDebugReportCallbackEXT;
    PFN_vkCreateDebugUtilsMessengerEXT m_CreateDebugUtilsMessengerEXT;
    PFN_vkCreateDevice m_CreateDevice;
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    PFN_vkCreateDirectFBSurfaceEXT m_CreateDirectFBSurfaceEXT;
#endif
    PFN_vkCreateDisplayModeKHR m_CreateDisplayModeKHR;
    PFN_vkCreateDisplayPlaneSurfaceKHR m_CreateDisplayPlaneSurfaceKHR;
    PFN_vkCreateHeadlessSurfaceEXT m_CreateHeadlessSurfaceEXT;
#ifdef VK_USE_PLATFORM_IOS_MVK
    PFN_vkCreateIOSSurfaceMVK m_CreateIOSSurfaceMVK;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkCreateImagePipeSurfaceFUCHSIA m_CreateImagePipeSurfaceFUCHSIA;
#endif
    PFN_vkCreateInstance m_CreateInstance;
#ifdef VK_USE_PLATFORM_MACOS_MVK
    PFN_vkCreateMacOSSurfaceMVK m_CreateMacOSSurfaceMVK;
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkCreateMetalSurfaceEXT m_CreateMetalSurfaceEXT;
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkCreateScreenSurfaceQNX m_CreateScreenSurfaceQNX;
#endif
#ifdef VK_USE_PLATFORM_GGP
    PFN_vkCreateStreamDescriptorSurfaceGGP m_CreateStreamDescriptorSurfaceGGP;
#endif
#ifdef VK_USE_PLATFORM_OHOS
    PFN_vkCreateSurfaceOHOS m_CreateSurfaceOHOS;
#endif
#ifdef VK_USE_PLATFORM_VI_NN
    PFN_vkCreateViSurfaceNN m_CreateViSurfaceNN;
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkCreateWaylandSurfaceKHR m_CreateWaylandSurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkCreateWin32SurfaceKHR m_CreateWin32SurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkCreateXcbSurfaceKHR m_CreateXcbSurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkCreateXlibSurfaceKHR m_CreateXlibSurfaceKHR;
#endif
    PFN_vkDebugReportMessageEXT m_DebugReportMessageEXT;
    PFN_vkDestroyDebugReportCallbackEXT m_DestroyDebugReportCallbackEXT;
    PFN_vkDestroyDebugUtilsMessengerEXT m_DestroyDebugUtilsMessengerEXT;
    PFN_vkDestroyInstance m_DestroyInstance;
    PFN_vkDestroySurfaceKHR m_DestroySurfaceKHR;
    PFN_vkEnumerateDeviceExtensionProperties m_EnumerateDeviceExtensionProperties;
    PFN_vkEnumerateDeviceLayerProperties m_EnumerateDeviceLayerProperties;
    PFN_vkEnumeratePhysicalDeviceGroups m_EnumeratePhysicalDeviceGroups;
    PFN_vkEnumeratePhysicalDeviceGroupsKHR m_EnumeratePhysicalDeviceGroupsKHR;
    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR m_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
    PFN_vkEnumeratePhysicalDevices m_EnumeratePhysicalDevices;
    PFN_vkGetDisplayModeProperties2KHR m_GetDisplayModeProperties2KHR;
    PFN_vkGetDisplayModePropertiesKHR m_GetDisplayModePropertiesKHR;
    PFN_vkGetDisplayPlaneCapabilities2KHR m_GetDisplayPlaneCapabilities2KHR;
    PFN_vkGetDisplayPlaneCapabilitiesKHR m_GetDisplayPlaneCapabilitiesKHR;
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR m_GetDisplayPlaneSupportedDisplaysKHR;
    PFN_vkGetDrmDisplayEXT m_GetDrmDisplayEXT;
    PFN_vkGetInstanceProcAddr m_GetInstanceProcAddr;
    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT m_GetPhysicalDeviceCalibrateableTimeDomainsEXT;
    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR m_GetPhysicalDeviceCalibrateableTimeDomainsKHR;
    PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV m_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR m_GetPhysicalDeviceCooperativeMatrixPropertiesKHR;
    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV m_GetPhysicalDeviceCooperativeMatrixPropertiesNV;
    PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV m_GetPhysicalDeviceCooperativeVectorPropertiesNV;
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT m_GetPhysicalDeviceDirectFBPresentationSupportEXT;
#endif
    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR m_GetPhysicalDeviceDisplayPlaneProperties2KHR;
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR m_GetPhysicalDeviceDisplayPlanePropertiesKHR;
    PFN_vkGetPhysicalDeviceDisplayProperties2KHR m_GetPhysicalDeviceDisplayProperties2KHR;
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR m_GetPhysicalDeviceDisplayPropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalBufferProperties m_GetPhysicalDeviceExternalBufferProperties;
    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR m_GetPhysicalDeviceExternalBufferPropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalFenceProperties m_GetPhysicalDeviceExternalFenceProperties;
    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR m_GetPhysicalDeviceExternalFencePropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV m_GetPhysicalDeviceExternalImageFormatPropertiesNV;
    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties m_GetPhysicalDeviceExternalSemaphoreProperties;
    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR m_GetPhysicalDeviceExternalSemaphorePropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM m_GetPhysicalDeviceExternalTensorPropertiesARM;
    PFN_vkGetPhysicalDeviceFeatures m_GetPhysicalDeviceFeatures;
    PFN_vkGetPhysicalDeviceFeatures2 m_GetPhysicalDeviceFeatures2;
    PFN_vkGetPhysicalDeviceFeatures2KHR m_GetPhysicalDeviceFeatures2KHR;
    PFN_vkGetPhysicalDeviceFormatProperties m_GetPhysicalDeviceFormatProperties;
    PFN_vkGetPhysicalDeviceFormatProperties2 m_GetPhysicalDeviceFormatProperties2;
    PFN_vkGetPhysicalDeviceFormatProperties2KHR m_GetPhysicalDeviceFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR m_GetPhysicalDeviceFragmentShadingRatesKHR;
    PFN_vkGetPhysicalDeviceImageFormatProperties m_GetPhysicalDeviceImageFormatProperties;
    PFN_vkGetPhysicalDeviceImageFormatProperties2 m_GetPhysicalDeviceImageFormatProperties2;
    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR m_GetPhysicalDeviceImageFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceMemoryProperties m_GetPhysicalDeviceMemoryProperties;
    PFN_vkGetPhysicalDeviceMemoryProperties2 m_GetPhysicalDeviceMemoryProperties2;
    PFN_vkGetPhysicalDeviceMemoryProperties2KHR m_GetPhysicalDeviceMemoryProperties2KHR;
    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT m_GetPhysicalDeviceMultisamplePropertiesEXT;
    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV m_GetPhysicalDeviceOpticalFlowImageFormatsNV;
    PFN_vkGetPhysicalDevicePresentRectanglesKHR m_GetPhysicalDevicePresentRectanglesKHR;
    PFN_vkGetPhysicalDeviceProperties m_GetPhysicalDeviceProperties;
    PFN_vkGetPhysicalDeviceProperties2 m_GetPhysicalDeviceProperties2;
    PFN_vkGetPhysicalDeviceProperties2KHR m_GetPhysicalDeviceProperties2KHR;
    PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM m_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM;
    PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM m_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM;
    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR m_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties m_GetPhysicalDeviceQueueFamilyProperties;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 m_GetPhysicalDeviceQueueFamilyProperties2;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR m_GetPhysicalDeviceQueueFamilyProperties2KHR;
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX m_GetPhysicalDeviceScreenPresentationSupportQNX;
#endif
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties m_GetPhysicalDeviceSparseImageFormatProperties;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 m_GetPhysicalDeviceSparseImageFormatProperties2;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR m_GetPhysicalDeviceSparseImageFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV m_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT m_GetPhysicalDeviceSurfaceCapabilities2EXT;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR m_GetPhysicalDeviceSurfaceCapabilities2KHR;
    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR m_GetPhysicalDeviceSurfaceCapabilitiesKHR;
    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR m_GetPhysicalDeviceSurfaceFormats2KHR;
    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR m_GetPhysicalDeviceSurfaceFormatsKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT m_GetPhysicalDeviceSurfacePresentModes2EXT;
#endif
    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR m_GetPhysicalDeviceSurfacePresentModesKHR;
    PFN_vkGetPhysicalDeviceSurfaceSupportKHR m_GetPhysicalDeviceSurfaceSupportKHR;
    PFN_vkGetPhysicalDeviceToolProperties m_GetPhysicalDeviceToolProperties;
    PFN_vkGetPhysicalDeviceToolPropertiesEXT m_GetPhysicalDeviceToolPropertiesEXT;
    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR m_GetPhysicalDeviceVideoCapabilitiesKHR;
    PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR m_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR m_GetPhysicalDeviceVideoFormatPropertiesKHR;
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR m_GetPhysicalDeviceWaylandPresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR m_GetPhysicalDeviceWin32PresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR m_GetPhysicalDeviceXcbPresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR m_GetPhysicalDeviceXlibPresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    PFN_vkGetRandROutputDisplayEXT m_GetRandROutputDisplayEXT;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetWinrtDisplayNV m_GetWinrtDisplayNV;
#endif
    PFN_vkReleaseDisplayEXT m_ReleaseDisplayEXT;
    PFN_vkSubmitDebugUtilsMessageEXT m_SubmitDebugUtilsMessageEXT;
  };

  class VkPhysicalDeviceDispatch {
  public:
    VkPhysicalDeviceDispatch(VkPhysicalDevice pPhysicalDevice, const VkInstanceDispatch *pInstanceDispatch) {
      this->PhysicalDevice = pPhysicalDevice;
      this->pInstanceDispatch = pInstanceDispatch;
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return pInstanceDispatch->AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pInstanceDispatch->AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return pInstanceDispatch->AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return pInstanceDispatch->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return pInstanceDispatch->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }
    VkResult CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const { return pInstanceDispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return pInstanceDispatch->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return pInstanceDispatch->CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pInstanceDispatch->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { pInstanceDispatch->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { pInstanceDispatch->DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { pInstanceDispatch->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const { pInstanceDispatch->DestroyInstance(instance, pAllocator); }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { pInstanceDispatch->DestroySurfaceKHR(instance, surface, pAllocator); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return pInstanceDispatch->EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return pInstanceDispatch->EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pInstanceDispatch->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pInstanceDispatch->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return pInstanceDispatch->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return pInstanceDispatch->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return pInstanceDispatch->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return pInstanceDispatch->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return pInstanceDispatch->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return pInstanceDispatch->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return pInstanceDispatch->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return pInstanceDispatch->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return pInstanceDispatch->GetInstanceProcAddr(instance, pName); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pInstanceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pInstanceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return pInstanceDispatch->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return pInstanceDispatch->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { pInstanceDispatch->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { pInstanceDispatch->GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pInstanceDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pInstanceDispatch->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { pInstanceDispatch->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pInstanceDispatch->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pInstanceDispatch->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return pInstanceDispatch->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { pInstanceDispatch->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pInstanceDispatch->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pInstanceDispatch->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { pInstanceDispatch->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return pInstanceDispatch->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { pInstanceDispatch->GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pInstanceDispatch->GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pInstanceDispatch->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { pInstanceDispatch->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return pInstanceDispatch->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { pInstanceDispatch->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { pInstanceDispatch->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pInstanceDispatch->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pInstanceDispatch->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return pInstanceDispatch->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { pInstanceDispatch->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pInstanceDispatch->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pInstanceDispatch->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return pInstanceDispatch->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pInstanceDispatch->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pInstanceDispatch->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return pInstanceDispatch->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pInstanceDispatch->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pInstanceDispatch->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return pInstanceDispatch->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return pInstanceDispatch->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return pInstanceDispatch->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return pInstanceDispatch->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return pInstanceDispatch->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return pInstanceDispatch->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return pInstanceDispatch->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return pInstanceDispatch->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return pInstanceDispatch->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pInstanceDispatch->ReleaseDisplayEXT(physicalDevice, display); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { pInstanceDispatch->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
  public:
    VkPhysicalDevice PhysicalDevice;
    const VkInstanceDispatch *pInstanceDispatch;
  private:
  };

  class VkDeviceDispatch {
  public:
    VkDeviceDispatch(PFN_vkGetDeviceProcAddr NextGetDeviceProcAddr, VkDevice device, VkPhysicalDevice PhysicalDevice, const VkPhysicalDeviceDispatch* pPhysicalDeviceDispatch, const VkDeviceCreateInfo* pCreateInfo) {
      this->PhysicalDevice = PhysicalDevice;
      this->Device = device;
      this->pPhysicalDeviceDispatch = pPhysicalDeviceDispatch;
      for (uint32_t i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
        VkDeviceQueueCreateInfo queueInfo = pCreateInfo->pQueueCreateInfos[i];
        queueInfo.pNext = nullptr;
        DeviceQueueInfos.push_back(queueInfo);
      }
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_AcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT) NextGetDeviceProcAddr(device, "vkAcquireFullScreenExclusiveModeEXT");
#endif
      this->m_AcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) NextGetDeviceProcAddr(device, "vkAcquireNextImage2KHR");
      this->m_AcquireNextImageKHR = (PFN_vkAcquireNextImageKHR) NextGetDeviceProcAddr(device, "vkAcquireNextImageKHR");
      this->m_AcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkAcquirePerformanceConfigurationINTEL");
      this->m_AcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR) NextGetDeviceProcAddr(device, "vkAcquireProfilingLockKHR");
      this->m_AllocateCommandBuffers = (PFN_vkAllocateCommandBuffers) NextGetDeviceProcAddr(device, "vkAllocateCommandBuffers");
      this->m_AllocateDescriptorSets = (PFN_vkAllocateDescriptorSets) NextGetDeviceProcAddr(device, "vkAllocateDescriptorSets");
      this->m_AllocateMemory = (PFN_vkAllocateMemory) NextGetDeviceProcAddr(device, "vkAllocateMemory");
      this->m_AntiLagUpdateAMD = (PFN_vkAntiLagUpdateAMD) NextGetDeviceProcAddr(device, "vkAntiLagUpdateAMD");
      this->m_BeginCommandBuffer = (PFN_vkBeginCommandBuffer) NextGetDeviceProcAddr(device, "vkBeginCommandBuffer");
      this->m_BindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV) NextGetDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNV");
      this->m_BindBufferMemory = (PFN_vkBindBufferMemory) NextGetDeviceProcAddr(device, "vkBindBufferMemory");
      this->m_BindBufferMemory2 = (PFN_vkBindBufferMemory2) NextGetDeviceProcAddr(device, "vkBindBufferMemory2");
      this->m_BindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR) NextGetDeviceProcAddr(device, "vkBindBufferMemory2KHR");
      this->m_BindDataGraphPipelineSessionMemoryARM = (PFN_vkBindDataGraphPipelineSessionMemoryARM) NextGetDeviceProcAddr(device, "vkBindDataGraphPipelineSessionMemoryARM");
      this->m_BindImageMemory = (PFN_vkBindImageMemory) NextGetDeviceProcAddr(device, "vkBindImageMemory");
      this->m_BindImageMemory2 = (PFN_vkBindImageMemory2) NextGetDeviceProcAddr(device, "vkBindImageMemory2");
      this->m_BindImageMemory2KHR = (PFN_vkBindImageMemory2KHR) NextGetDeviceProcAddr(device, "vkBindImageMemory2KHR");
      this->m_BindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV) NextGetDeviceProcAddr(device, "vkBindOpticalFlowSessionImageNV");
      this->m_BindTensorMemoryARM = (PFN_vkBindTensorMemoryARM) NextGetDeviceProcAddr(device, "vkBindTensorMemoryARM");
      this->m_BindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR) NextGetDeviceProcAddr(device, "vkBindVideoSessionMemoryKHR");
      this->m_BuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR) NextGetDeviceProcAddr(device, "vkBuildAccelerationStructuresKHR");
      this->m_BuildMicromapsEXT = (PFN_vkBuildMicromapsEXT) NextGetDeviceProcAddr(device, "vkBuildMicromapsEXT");
      this->m_CmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT) NextGetDeviceProcAddr(device, "vkCmdBeginConditionalRenderingEXT");
      this->m_CmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdBeginDebugUtilsLabelEXT");
      this->m_CmdBeginPerTileExecutionQCOM = (PFN_vkCmdBeginPerTileExecutionQCOM) NextGetDeviceProcAddr(device, "vkCmdBeginPerTileExecutionQCOM");
      this->m_CmdBeginQuery = (PFN_vkCmdBeginQuery) NextGetDeviceProcAddr(device, "vkCmdBeginQuery");
      this->m_CmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdBeginQueryIndexedEXT");
      this->m_CmdBeginRenderPass = (PFN_vkCmdBeginRenderPass) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass");
      this->m_CmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass2");
      this->m_CmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass2KHR");
      this->m_CmdBeginRendering = (PFN_vkCmdBeginRendering) NextGetDeviceProcAddr(device, "vkCmdBeginRendering");
      this->m_CmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR) NextGetDeviceProcAddr(device, "vkCmdBeginRenderingKHR");
      this->m_CmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT) NextGetDeviceProcAddr(device, "vkCmdBeginTransformFeedbackEXT");
      this->m_CmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdBeginVideoCodingKHR");
      this->m_CmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
      this->m_CmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
      this->m_CmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBuffersEXT");
      this->m_CmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorSets");
      this->m_CmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorSets2KHR");
      this->m_CmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer) NextGetDeviceProcAddr(device, "vkCmdBindIndexBuffer");
      this->m_CmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdBindIndexBuffer2KHR");
      this->m_CmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI) NextGetDeviceProcAddr(device, "vkCmdBindInvocationMaskHUAWEI");
      this->m_CmdBindPipeline = (PFN_vkCmdBindPipeline) NextGetDeviceProcAddr(device, "vkCmdBindPipeline");
      this->m_CmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV) NextGetDeviceProcAddr(device, "vkCmdBindPipelineShaderGroupNV");
      this->m_CmdBindShadersEXT = (PFN_vkCmdBindShadersEXT) NextGetDeviceProcAddr(device, "vkCmdBindShadersEXT");
      this->m_CmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV) NextGetDeviceProcAddr(device, "vkCmdBindShadingRateImageNV");
      this->m_CmdBindTileMemoryQCOM = (PFN_vkCmdBindTileMemoryQCOM) NextGetDeviceProcAddr(device, "vkCmdBindTileMemoryQCOM");
      this->m_CmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT) NextGetDeviceProcAddr(device, "vkCmdBindTransformFeedbackBuffersEXT");
      this->m_CmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers");
      this->m_CmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2");
      this->m_CmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2EXT");
      this->m_CmdBlitImage = (PFN_vkCmdBlitImage) NextGetDeviceProcAddr(device, "vkCmdBlitImage");
      this->m_CmdBlitImage2 = (PFN_vkCmdBlitImage2) NextGetDeviceProcAddr(device, "vkCmdBlitImage2");
      this->m_CmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR) NextGetDeviceProcAddr(device, "vkCmdBlitImage2KHR");
      this->m_CmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNV");
      this->m_CmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresIndirectKHR");
      this->m_CmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresKHR");
      this->m_CmdBuildClusterAccelerationStructureIndirectNV = (PFN_vkCmdBuildClusterAccelerationStructureIndirectNV) NextGetDeviceProcAddr(device, "vkCmdBuildClusterAccelerationStructureIndirectNV");
      this->m_CmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT) NextGetDeviceProcAddr(device, "vkCmdBuildMicromapsEXT");
      this->m_CmdBuildPartitionedAccelerationStructuresNV = (PFN_vkCmdBuildPartitionedAccelerationStructuresNV) NextGetDeviceProcAddr(device, "vkCmdBuildPartitionedAccelerationStructuresNV");
      this->m_CmdClearAttachments = (PFN_vkCmdClearAttachments) NextGetDeviceProcAddr(device, "vkCmdClearAttachments");
      this->m_CmdClearColorImage = (PFN_vkCmdClearColorImage) NextGetDeviceProcAddr(device, "vkCmdClearColorImage");
      this->m_CmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage) NextGetDeviceProcAddr(device, "vkCmdClearDepthStencilImage");
      this->m_CmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdControlVideoCodingKHR");
      this->m_CmdConvertCooperativeVectorMatrixNV = (PFN_vkCmdConvertCooperativeVectorMatrixNV) NextGetDeviceProcAddr(device, "vkCmdConvertCooperativeVectorMatrixNV");
      this->m_CmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureKHR");
      this->m_CmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNV");
      this->m_CmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureToMemoryKHR");
      this->m_CmdCopyBuffer = (PFN_vkCmdCopyBuffer) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer");
      this->m_CmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer2");
      this->m_CmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer2KHR");
      this->m_CmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage");
      this->m_CmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2");
      this->m_CmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2KHR");
      this->m_CmdCopyImage = (PFN_vkCmdCopyImage) NextGetDeviceProcAddr(device, "vkCmdCopyImage");
      this->m_CmdCopyImage2 = (PFN_vkCmdCopyImage2) NextGetDeviceProcAddr(device, "vkCmdCopyImage2");
      this->m_CmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyImage2KHR");
      this->m_CmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer");
      this->m_CmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2");
      this->m_CmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2KHR");
      this->m_CmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryIndirectNV");
      this->m_CmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToAccelerationStructureKHR");
      this->m_CmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToImageIndirectNV");
      this->m_CmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToMicromapEXT");
      this->m_CmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMicromapEXT");
      this->m_CmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMicromapToMemoryEXT");
      this->m_CmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults) NextGetDeviceProcAddr(device, "vkCmdCopyQueryPoolResults");
      this->m_CmdCopyTensorARM = (PFN_vkCmdCopyTensorARM) NextGetDeviceProcAddr(device, "vkCmdCopyTensorARM");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV) NextGetDeviceProcAddr(device, "vkCmdCudaLaunchKernelNV");
#endif
      this->m_CmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT");
      this->m_CmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT");
      this->m_CmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT");
      this->m_CmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR) NextGetDeviceProcAddr(device, "vkCmdDecodeVideoKHR");
      this->m_CmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV) NextGetDeviceProcAddr(device, "vkCmdDecompressMemoryIndirectCountNV");
      this->m_CmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV) NextGetDeviceProcAddr(device, "vkCmdDecompressMemoryNV");
      this->m_CmdDispatch = (PFN_vkCmdDispatch) NextGetDeviceProcAddr(device, "vkCmdDispatch");
      this->m_CmdDispatchBase = (PFN_vkCmdDispatchBase) NextGetDeviceProcAddr(device, "vkCmdDispatchBase");
      this->m_CmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR) NextGetDeviceProcAddr(device, "vkCmdDispatchBaseKHR");
      this->m_CmdDispatchDataGraphARM = (PFN_vkCmdDispatchDataGraphARM) NextGetDeviceProcAddr(device, "vkCmdDispatchDataGraphARM");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectCountAMDX");
#endif
      this->m_CmdDispatchIndirect = (PFN_vkCmdDispatchIndirect) NextGetDeviceProcAddr(device, "vkCmdDispatchIndirect");
      this->m_CmdDispatchTileQCOM = (PFN_vkCmdDispatchTileQCOM) NextGetDeviceProcAddr(device, "vkCmdDispatchTileQCOM");
      this->m_CmdDraw = (PFN_vkCmdDraw) NextGetDeviceProcAddr(device, "vkCmdDraw");
      this->m_CmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI) NextGetDeviceProcAddr(device, "vkCmdDrawClusterHUAWEI");
      this->m_CmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI) NextGetDeviceProcAddr(device, "vkCmdDrawClusterIndirectHUAWEI");
      this->m_CmdDrawIndexed = (PFN_vkCmdDrawIndexed) NextGetDeviceProcAddr(device, "vkCmdDrawIndexed");
      this->m_CmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirect");
      this->m_CmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCount");
      this->m_CmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountAMD");
      this->m_CmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountKHR");
      this->m_CmdDrawIndirect = (PFN_vkCmdDrawIndirect) NextGetDeviceProcAddr(device, "vkCmdDrawIndirect");
      this->m_CmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectByteCountEXT");
      this->m_CmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCount");
      this->m_CmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCountAMD");
      this->m_CmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCountKHR");
      this->m_CmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksEXT");
      this->m_CmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountEXT");
      this->m_CmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountNV");
      this->m_CmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectEXT");
      this->m_CmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectNV");
      this->m_CmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksNV");
      this->m_CmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMultiEXT");
      this->m_CmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMultiIndexedEXT");
      this->m_CmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR) NextGetDeviceProcAddr(device, "vkCmdEncodeVideoKHR");
      this->m_CmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT) NextGetDeviceProcAddr(device, "vkCmdEndConditionalRenderingEXT");
      this->m_CmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdEndDebugUtilsLabelEXT");
      this->m_CmdEndPerTileExecutionQCOM = (PFN_vkCmdEndPerTileExecutionQCOM) NextGetDeviceProcAddr(device, "vkCmdEndPerTileExecutionQCOM");
      this->m_CmdEndQuery = (PFN_vkCmdEndQuery) NextGetDeviceProcAddr(device, "vkCmdEndQuery");
      this->m_CmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdEndQueryIndexedEXT");
      this->m_CmdEndRenderPass = (PFN_vkCmdEndRenderPass) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass");
      this->m_CmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass2");
      this->m_CmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass2KHR");
      this->m_CmdEndRendering = (PFN_vkCmdEndRendering) NextGetDeviceProcAddr(device, "vkCmdEndRendering");
      this->m_CmdEndRendering2EXT = (PFN_vkCmdEndRendering2EXT) NextGetDeviceProcAddr(device, "vkCmdEndRendering2EXT");
      this->m_CmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR) NextGetDeviceProcAddr(device, "vkCmdEndRenderingKHR");
      this->m_CmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT) NextGetDeviceProcAddr(device, "vkCmdEndTransformFeedbackEXT");
      this->m_CmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdEndVideoCodingKHR");
      this->m_CmdExecuteCommands = (PFN_vkCmdExecuteCommands) NextGetDeviceProcAddr(device, "vkCmdExecuteCommands");
      this->m_CmdExecuteGeneratedCommandsEXT = (PFN_vkCmdExecuteGeneratedCommandsEXT) NextGetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsEXT");
      this->m_CmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV) NextGetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsNV");
      this->m_CmdFillBuffer = (PFN_vkCmdFillBuffer) NextGetDeviceProcAddr(device, "vkCmdFillBuffer");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX) NextGetDeviceProcAddr(device, "vkCmdInitializeGraphScratchMemoryAMDX");
#endif
      this->m_CmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdInsertDebugUtilsLabelEXT");
      this->m_CmdNextSubpass = (PFN_vkCmdNextSubpass) NextGetDeviceProcAddr(device, "vkCmdNextSubpass");
      this->m_CmdNextSubpass2 = (PFN_vkCmdNextSubpass2) NextGetDeviceProcAddr(device, "vkCmdNextSubpass2");
      this->m_CmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR) NextGetDeviceProcAddr(device, "vkCmdNextSubpass2KHR");
      this->m_CmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV) NextGetDeviceProcAddr(device, "vkCmdOpticalFlowExecuteNV");
      this->m_CmdPipelineBarrier = (PFN_vkCmdPipelineBarrier) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier");
      this->m_CmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier2");
      this->m_CmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier2KHR");
      this->m_CmdPreprocessGeneratedCommandsEXT = (PFN_vkCmdPreprocessGeneratedCommandsEXT) NextGetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsEXT");
      this->m_CmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV) NextGetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsNV");
      this->m_CmdPushConstants = (PFN_vkCmdPushConstants) NextGetDeviceProcAddr(device, "vkCmdPushConstants");
      this->m_CmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR) NextGetDeviceProcAddr(device, "vkCmdPushConstants2KHR");
      this->m_CmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSet2KHR");
      this->m_CmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetKHR");
      this->m_CmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate2KHR");
      this->m_CmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplateKHR");
      this->m_CmdResetEvent = (PFN_vkCmdResetEvent) NextGetDeviceProcAddr(device, "vkCmdResetEvent");
      this->m_CmdResetEvent2 = (PFN_vkCmdResetEvent2) NextGetDeviceProcAddr(device, "vkCmdResetEvent2");
      this->m_CmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR) NextGetDeviceProcAddr(device, "vkCmdResetEvent2KHR");
      this->m_CmdResetQueryPool = (PFN_vkCmdResetQueryPool) NextGetDeviceProcAddr(device, "vkCmdResetQueryPool");
      this->m_CmdResolveImage = (PFN_vkCmdResolveImage) NextGetDeviceProcAddr(device, "vkCmdResolveImage");
      this->m_CmdResolveImage2 = (PFN_vkCmdResolveImage2) NextGetDeviceProcAddr(device, "vkCmdResolveImage2");
      this->m_CmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR) NextGetDeviceProcAddr(device, "vkCmdResolveImage2KHR");
      this->m_CmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAlphaToCoverageEnableEXT");
      this->m_CmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAlphaToOneEnableEXT");
      this->m_CmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
      this->m_CmdSetBlendConstants = (PFN_vkCmdSetBlendConstants) NextGetDeviceProcAddr(device, "vkCmdSetBlendConstants");
      this->m_CmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV) NextGetDeviceProcAddr(device, "vkCmdSetCheckpointNV");
      this->m_CmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV) NextGetDeviceProcAddr(device, "vkCmdSetCoarseSampleOrderNV");
      this->m_CmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendAdvancedEXT");
      this->m_CmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendEnableEXT");
      this->m_CmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendEquationEXT");
      this->m_CmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorWriteEnableEXT");
      this->m_CmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorWriteMaskEXT");
      this->m_CmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetConservativeRasterizationModeEXT");
      this->m_CmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationModeNV");
      this->m_CmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableEnableNV");
      this->m_CmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableNV");
      this->m_CmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageReductionModeNV");
      this->m_CmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageToColorEnableNV");
      this->m_CmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageToColorLocationNV");
      this->m_CmdSetCullMode = (PFN_vkCmdSetCullMode) NextGetDeviceProcAddr(device, "vkCmdSetCullMode");
      this->m_CmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetCullModeEXT");
      this->m_CmdSetDepthBias = (PFN_vkCmdSetDepthBias) NextGetDeviceProcAddr(device, "vkCmdSetDepthBias");
      this->m_CmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBias2EXT");
      this->m_CmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnable");
      this->m_CmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnableEXT");
      this->m_CmdSetDepthBounds = (PFN_vkCmdSetDepthBounds) NextGetDeviceProcAddr(device, "vkCmdSetDepthBounds");
      this->m_CmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnable");
      this->m_CmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnableEXT");
      this->m_CmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClampEnableEXT");
      this->m_CmdSetDepthClampRangeEXT = (PFN_vkCmdSetDepthClampRangeEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClampRangeEXT");
      this->m_CmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClipEnableEXT");
      this->m_CmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClipNegativeOneToOneEXT");
      this->m_CmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp) NextGetDeviceProcAddr(device, "vkCmdSetDepthCompareOp");
      this->m_CmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthCompareOpEXT");
      this->m_CmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthTestEnable");
      this->m_CmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthTestEnableEXT");
      this->m_CmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnable");
      this->m_CmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnableEXT");
      this->m_CmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT) NextGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsets2EXT");
      this->m_CmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT) NextGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsetsEXT");
      this->m_CmdSetDeviceMask = (PFN_vkCmdSetDeviceMask) NextGetDeviceProcAddr(device, "vkCmdSetDeviceMask");
      this->m_CmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR) NextGetDeviceProcAddr(device, "vkCmdSetDeviceMaskKHR");
      this->m_CmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEXT");
      this->m_CmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEnableEXT");
      this->m_CmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleModeEXT");
      this->m_CmdSetEvent = (PFN_vkCmdSetEvent) NextGetDeviceProcAddr(device, "vkCmdSetEvent");
      this->m_CmdSetEvent2 = (PFN_vkCmdSetEvent2) NextGetDeviceProcAddr(device, "vkCmdSetEvent2");
      this->m_CmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR) NextGetDeviceProcAddr(device, "vkCmdSetEvent2KHR");
      this->m_CmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorEnableNV");
      this->m_CmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV) NextGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorNV");
      this->m_CmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT) NextGetDeviceProcAddr(device, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
      this->m_CmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV) NextGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateEnumNV");
      this->m_CmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR) NextGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateKHR");
      this->m_CmdSetFrontFace = (PFN_vkCmdSetFrontFace) NextGetDeviceProcAddr(device, "vkCmdSetFrontFace");
      this->m_CmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT) NextGetDeviceProcAddr(device, "vkCmdSetFrontFaceEXT");
      this->m_CmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineRasterizationModeEXT");
      this->m_CmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleEXT");
      this->m_CmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleEnableEXT");
      this->m_CmdSetLineStippleKHR = (PFN_vkCmdSetLineStippleKHR) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleKHR");
      this->m_CmdSetLineWidth = (PFN_vkCmdSetLineWidth) NextGetDeviceProcAddr(device, "vkCmdSetLineWidth");
      this->m_CmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetLogicOpEXT");
      this->m_CmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetLogicOpEnableEXT");
      this->m_CmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT) NextGetDeviceProcAddr(device, "vkCmdSetPatchControlPointsEXT");
      this->m_CmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceMarkerINTEL");
      this->m_CmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceOverrideINTEL");
      this->m_CmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceStreamMarkerINTEL");
      this->m_CmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetPolygonModeEXT");
      this->m_CmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnable");
      this->m_CmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnableEXT");
      this->m_CmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopology");
      this->m_CmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopologyEXT");
      this->m_CmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetProvokingVertexModeEXT");
      this->m_CmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizationSamplesEXT");
      this->m_CmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizationStreamEXT");
      this->m_CmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable) NextGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnable");
      this->m_CmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnableEXT");
      this->m_CmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR) NextGetDeviceProcAddr(device, "vkCmdSetRayTracingPipelineStackSizeKHR");
      this->m_CmdSetRenderingAttachmentLocationsKHR = (PFN_vkCmdSetRenderingAttachmentLocationsKHR) NextGetDeviceProcAddr(device, "vkCmdSetRenderingAttachmentLocationsKHR");
      this->m_CmdSetRenderingInputAttachmentIndicesKHR = (PFN_vkCmdSetRenderingInputAttachmentIndicesKHR) NextGetDeviceProcAddr(device, "vkCmdSetRenderingInputAttachmentIndicesKHR");
      this->m_CmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetRepresentativeFragmentTestEnableNV");
      this->m_CmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEXT");
      this->m_CmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEnableEXT");
      this->m_CmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleMaskEXT");
      this->m_CmdSetScissor = (PFN_vkCmdSetScissor) NextGetDeviceProcAddr(device, "vkCmdSetScissor");
      this->m_CmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount) NextGetDeviceProcAddr(device, "vkCmdSetScissorWithCount");
      this->m_CmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT) NextGetDeviceProcAddr(device, "vkCmdSetScissorWithCountEXT");
      this->m_CmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetShadingRateImageEnableNV");
      this->m_CmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask) NextGetDeviceProcAddr(device, "vkCmdSetStencilCompareMask");
      this->m_CmdSetStencilOp = (PFN_vkCmdSetStencilOp) NextGetDeviceProcAddr(device, "vkCmdSetStencilOp");
      this->m_CmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetStencilOpEXT");
      this->m_CmdSetStencilReference = (PFN_vkCmdSetStencilReference) NextGetDeviceProcAddr(device, "vkCmdSetStencilReference");
      this->m_CmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetStencilTestEnable");
      this->m_CmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetStencilTestEnableEXT");
      this->m_CmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask) NextGetDeviceProcAddr(device, "vkCmdSetStencilWriteMask");
      this->m_CmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT) NextGetDeviceProcAddr(device, "vkCmdSetTessellationDomainOriginEXT");
      this->m_CmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT) NextGetDeviceProcAddr(device, "vkCmdSetVertexInputEXT");
      this->m_CmdSetViewport = (PFN_vkCmdSetViewport) NextGetDeviceProcAddr(device, "vkCmdSetViewport");
      this->m_CmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportShadingRatePaletteNV");
      this->m_CmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportSwizzleNV");
      this->m_CmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportWScalingEnableNV");
      this->m_CmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportWScalingNV");
      this->m_CmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount) NextGetDeviceProcAddr(device, "vkCmdSetViewportWithCount");
      this->m_CmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT) NextGetDeviceProcAddr(device, "vkCmdSetViewportWithCountEXT");
      this->m_CmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI) NextGetDeviceProcAddr(device, "vkCmdSubpassShadingHUAWEI");
      this->m_CmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysIndirect2KHR");
      this->m_CmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysIndirectKHR");
      this->m_CmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysKHR");
      this->m_CmdTraceRaysNV = (PFN_vkCmdTraceRaysNV) NextGetDeviceProcAddr(device, "vkCmdTraceRaysNV");
      this->m_CmdUpdateBuffer = (PFN_vkCmdUpdateBuffer) NextGetDeviceProcAddr(device, "vkCmdUpdateBuffer");
      this->m_CmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV) NextGetDeviceProcAddr(device, "vkCmdUpdatePipelineIndirectBufferNV");
      this->m_CmdWaitEvents = (PFN_vkCmdWaitEvents) NextGetDeviceProcAddr(device, "vkCmdWaitEvents");
      this->m_CmdWaitEvents2 = (PFN_vkCmdWaitEvents2) NextGetDeviceProcAddr(device, "vkCmdWaitEvents2");
      this->m_CmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR) NextGetDeviceProcAddr(device, "vkCmdWaitEvents2KHR");
      this->m_CmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR) NextGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesKHR");
      this->m_CmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV) NextGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesNV");
      this->m_CmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD) NextGetDeviceProcAddr(device, "vkCmdWriteBufferMarker2AMD");
      this->m_CmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD) NextGetDeviceProcAddr(device, "vkCmdWriteBufferMarkerAMD");
      this->m_CmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT) NextGetDeviceProcAddr(device, "vkCmdWriteMicromapsPropertiesEXT");
      this->m_CmdWriteTimestamp = (PFN_vkCmdWriteTimestamp) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp");
      this->m_CmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp2");
      this->m_CmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp2KHR");
      this->m_CompileDeferredNV = (PFN_vkCompileDeferredNV) NextGetDeviceProcAddr(device, "vkCompileDeferredNV");
      this->m_ConvertCooperativeVectorMatrixNV = (PFN_vkConvertCooperativeVectorMatrixNV) NextGetDeviceProcAddr(device, "vkConvertCooperativeVectorMatrixNV");
      this->m_CopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCopyAccelerationStructureKHR");
      this->m_CopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR) NextGetDeviceProcAddr(device, "vkCopyAccelerationStructureToMemoryKHR");
      this->m_CopyImageToImageEXT = (PFN_vkCopyImageToImageEXT) NextGetDeviceProcAddr(device, "vkCopyImageToImageEXT");
      this->m_CopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT) NextGetDeviceProcAddr(device, "vkCopyImageToMemoryEXT");
      this->m_CopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCopyMemoryToAccelerationStructureKHR");
      this->m_CopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT) NextGetDeviceProcAddr(device, "vkCopyMemoryToImageEXT");
      this->m_CopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT) NextGetDeviceProcAddr(device, "vkCopyMemoryToMicromapEXT");
      this->m_CopyMicromapEXT = (PFN_vkCopyMicromapEXT) NextGetDeviceProcAddr(device, "vkCopyMicromapEXT");
      this->m_CopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT) NextGetDeviceProcAddr(device, "vkCopyMicromapToMemoryEXT");
      this->m_CreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCreateAccelerationStructureKHR");
      this->m_CreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCreateAccelerationStructureNV");
      this->m_CreateBuffer = (PFN_vkCreateBuffer) NextGetDeviceProcAddr(device, "vkCreateBuffer");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_CreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA) NextGetDeviceProcAddr(device, "vkCreateBufferCollectionFUCHSIA");
#endif
      this->m_CreateBufferView = (PFN_vkCreateBufferView) NextGetDeviceProcAddr(device, "vkCreateBufferView");
      this->m_CreateCommandPool = (PFN_vkCreateCommandPool) NextGetDeviceProcAddr(device, "vkCreateCommandPool");
      this->m_CreateComputePipelines = (PFN_vkCreateComputePipelines) NextGetDeviceProcAddr(device, "vkCreateComputePipelines");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV) NextGetDeviceProcAddr(device, "vkCreateCudaFunctionNV");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CreateCudaModuleNV = (PFN_vkCreateCudaModuleNV) NextGetDeviceProcAddr(device, "vkCreateCudaModuleNV");
#endif
      this->m_CreateDataGraphPipelineSessionARM = (PFN_vkCreateDataGraphPipelineSessionARM) NextGetDeviceProcAddr(device, "vkCreateDataGraphPipelineSessionARM");
      this->m_CreateDataGraphPipelinesARM = (PFN_vkCreateDataGraphPipelinesARM) NextGetDeviceProcAddr(device, "vkCreateDataGraphPipelinesARM");
      this->m_CreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR) NextGetDeviceProcAddr(device, "vkCreateDeferredOperationKHR");
      this->m_CreateDescriptorPool = (PFN_vkCreateDescriptorPool) NextGetDeviceProcAddr(device, "vkCreateDescriptorPool");
      this->m_CreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout) NextGetDeviceProcAddr(device, "vkCreateDescriptorSetLayout");
      this->m_CreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate) NextGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplate");
      this->m_CreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR) NextGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplateKHR");
      this->m_CreateEvent = (PFN_vkCreateEvent) NextGetDeviceProcAddr(device, "vkCreateEvent");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_CreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX) NextGetDeviceProcAddr(device, "vkCreateExecutionGraphPipelinesAMDX");
#endif
      this->m_CreateExternalComputeQueueNV = (PFN_vkCreateExternalComputeQueueNV) NextGetDeviceProcAddr(device, "vkCreateExternalComputeQueueNV");
      this->m_CreateFence = (PFN_vkCreateFence) NextGetDeviceProcAddr(device, "vkCreateFence");
      this->m_CreateFramebuffer = (PFN_vkCreateFramebuffer) NextGetDeviceProcAddr(device, "vkCreateFramebuffer");
      this->m_CreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines) NextGetDeviceProcAddr(device, "vkCreateGraphicsPipelines");
      this->m_CreateImage = (PFN_vkCreateImage) NextGetDeviceProcAddr(device, "vkCreateImage");
      this->m_CreateImageView = (PFN_vkCreateImageView) NextGetDeviceProcAddr(device, "vkCreateImageView");
      this->m_CreateIndirectCommandsLayoutEXT = (PFN_vkCreateIndirectCommandsLayoutEXT) NextGetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutEXT");
      this->m_CreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV) NextGetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutNV");
      this->m_CreateIndirectExecutionSetEXT = (PFN_vkCreateIndirectExecutionSetEXT) NextGetDeviceProcAddr(device, "vkCreateIndirectExecutionSetEXT");
      this->m_CreateMicromapEXT = (PFN_vkCreateMicromapEXT) NextGetDeviceProcAddr(device, "vkCreateMicromapEXT");
      this->m_CreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV) NextGetDeviceProcAddr(device, "vkCreateOpticalFlowSessionNV");
      this->m_CreatePipelineBinariesKHR = (PFN_vkCreatePipelineBinariesKHR) NextGetDeviceProcAddr(device, "vkCreatePipelineBinariesKHR");
      this->m_CreatePipelineCache = (PFN_vkCreatePipelineCache) NextGetDeviceProcAddr(device, "vkCreatePipelineCache");
      this->m_CreatePipelineLayout = (PFN_vkCreatePipelineLayout) NextGetDeviceProcAddr(device, "vkCreatePipelineLayout");
      this->m_CreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot) NextGetDeviceProcAddr(device, "vkCreatePrivateDataSlot");
      this->m_CreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT) NextGetDeviceProcAddr(device, "vkCreatePrivateDataSlotEXT");
      this->m_CreateQueryPool = (PFN_vkCreateQueryPool) NextGetDeviceProcAddr(device, "vkCreateQueryPool");
      this->m_CreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR) NextGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesKHR");
      this->m_CreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV) NextGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesNV");
      this->m_CreateRenderPass = (PFN_vkCreateRenderPass) NextGetDeviceProcAddr(device, "vkCreateRenderPass");
      this->m_CreateRenderPass2 = (PFN_vkCreateRenderPass2) NextGetDeviceProcAddr(device, "vkCreateRenderPass2");
      this->m_CreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCreateRenderPass2KHR");
      this->m_CreateSampler = (PFN_vkCreateSampler) NextGetDeviceProcAddr(device, "vkCreateSampler");
      this->m_CreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion) NextGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversion");
      this->m_CreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR) NextGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversionKHR");
      this->m_CreateSemaphore = (PFN_vkCreateSemaphore) NextGetDeviceProcAddr(device, "vkCreateSemaphore");
      this->m_CreateShaderModule = (PFN_vkCreateShaderModule) NextGetDeviceProcAddr(device, "vkCreateShaderModule");
      this->m_CreateShadersEXT = (PFN_vkCreateShadersEXT) NextGetDeviceProcAddr(device, "vkCreateShadersEXT");
      this->m_CreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR) NextGetDeviceProcAddr(device, "vkCreateSharedSwapchainsKHR");
      this->m_CreateSwapchainKHR = (PFN_vkCreateSwapchainKHR) NextGetDeviceProcAddr(device, "vkCreateSwapchainKHR");
      this->m_CreateTensorARM = (PFN_vkCreateTensorARM) NextGetDeviceProcAddr(device, "vkCreateTensorARM");
      this->m_CreateTensorViewARM = (PFN_vkCreateTensorViewARM) NextGetDeviceProcAddr(device, "vkCreateTensorViewARM");
      this->m_CreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT) NextGetDeviceProcAddr(device, "vkCreateValidationCacheEXT");
      this->m_CreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR) NextGetDeviceProcAddr(device, "vkCreateVideoSessionKHR");
      this->m_CreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkCreateVideoSessionParametersKHR");
      this->m_DebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT) NextGetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT");
      this->m_DebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT) NextGetDeviceProcAddr(device, "vkDebugMarkerSetObjectTagEXT");
      this->m_DeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR) NextGetDeviceProcAddr(device, "vkDeferredOperationJoinKHR");
      this->m_DestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkDestroyAccelerationStructureKHR");
      this->m_DestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkDestroyAccelerationStructureNV");
      this->m_DestroyBuffer = (PFN_vkDestroyBuffer) NextGetDeviceProcAddr(device, "vkDestroyBuffer");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_DestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA) NextGetDeviceProcAddr(device, "vkDestroyBufferCollectionFUCHSIA");
#endif
      this->m_DestroyBufferView = (PFN_vkDestroyBufferView) NextGetDeviceProcAddr(device, "vkDestroyBufferView");
      this->m_DestroyCommandPool = (PFN_vkDestroyCommandPool) NextGetDeviceProcAddr(device, "vkDestroyCommandPool");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_DestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV) NextGetDeviceProcAddr(device, "vkDestroyCudaFunctionNV");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_DestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV) NextGetDeviceProcAddr(device, "vkDestroyCudaModuleNV");
#endif
      this->m_DestroyDataGraphPipelineSessionARM = (PFN_vkDestroyDataGraphPipelineSessionARM) NextGetDeviceProcAddr(device, "vkDestroyDataGraphPipelineSessionARM");
      this->m_DestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR) NextGetDeviceProcAddr(device, "vkDestroyDeferredOperationKHR");
      this->m_DestroyDescriptorPool = (PFN_vkDestroyDescriptorPool) NextGetDeviceProcAddr(device, "vkDestroyDescriptorPool");
      this->m_DestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout) NextGetDeviceProcAddr(device, "vkDestroyDescriptorSetLayout");
      this->m_DestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate) NextGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplate");
      this->m_DestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR) NextGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplateKHR");
      this->m_DestroyDevice = (PFN_vkDestroyDevice) NextGetDeviceProcAddr(device, "vkDestroyDevice");
      this->m_DestroyEvent = (PFN_vkDestroyEvent) NextGetDeviceProcAddr(device, "vkDestroyEvent");
      this->m_DestroyExternalComputeQueueNV = (PFN_vkDestroyExternalComputeQueueNV) NextGetDeviceProcAddr(device, "vkDestroyExternalComputeQueueNV");
      this->m_DestroyFence = (PFN_vkDestroyFence) NextGetDeviceProcAddr(device, "vkDestroyFence");
      this->m_DestroyFramebuffer = (PFN_vkDestroyFramebuffer) NextGetDeviceProcAddr(device, "vkDestroyFramebuffer");
      this->m_DestroyImage = (PFN_vkDestroyImage) NextGetDeviceProcAddr(device, "vkDestroyImage");
      this->m_DestroyImageView = (PFN_vkDestroyImageView) NextGetDeviceProcAddr(device, "vkDestroyImageView");
      this->m_DestroyIndirectCommandsLayoutEXT = (PFN_vkDestroyIndirectCommandsLayoutEXT) NextGetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutEXT");
      this->m_DestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV) NextGetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutNV");
      this->m_DestroyIndirectExecutionSetEXT = (PFN_vkDestroyIndirectExecutionSetEXT) NextGetDeviceProcAddr(device, "vkDestroyIndirectExecutionSetEXT");
      this->m_DestroyMicromapEXT = (PFN_vkDestroyMicromapEXT) NextGetDeviceProcAddr(device, "vkDestroyMicromapEXT");
      this->m_DestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV) NextGetDeviceProcAddr(device, "vkDestroyOpticalFlowSessionNV");
      this->m_DestroyPipeline = (PFN_vkDestroyPipeline) NextGetDeviceProcAddr(device, "vkDestroyPipeline");
      this->m_DestroyPipelineBinaryKHR = (PFN_vkDestroyPipelineBinaryKHR) NextGetDeviceProcAddr(device, "vkDestroyPipelineBinaryKHR");
      this->m_DestroyPipelineCache = (PFN_vkDestroyPipelineCache) NextGetDeviceProcAddr(device, "vkDestroyPipelineCache");
      this->m_DestroyPipelineLayout = (PFN_vkDestroyPipelineLayout) NextGetDeviceProcAddr(device, "vkDestroyPipelineLayout");
      this->m_DestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot) NextGetDeviceProcAddr(device, "vkDestroyPrivateDataSlot");
      this->m_DestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT) NextGetDeviceProcAddr(device, "vkDestroyPrivateDataSlotEXT");
      this->m_DestroyQueryPool = (PFN_vkDestroyQueryPool) NextGetDeviceProcAddr(device, "vkDestroyQueryPool");
      this->m_DestroyRenderPass = (PFN_vkDestroyRenderPass) NextGetDeviceProcAddr(device, "vkDestroyRenderPass");
      this->m_DestroySampler = (PFN_vkDestroySampler) NextGetDeviceProcAddr(device, "vkDestroySampler");
      this->m_DestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion) NextGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversion");
      this->m_DestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR) NextGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversionKHR");
      this->m_DestroySemaphore = (PFN_vkDestroySemaphore) NextGetDeviceProcAddr(device, "vkDestroySemaphore");
      this->m_DestroyShaderEXT = (PFN_vkDestroyShaderEXT) NextGetDeviceProcAddr(device, "vkDestroyShaderEXT");
      this->m_DestroyShaderModule = (PFN_vkDestroyShaderModule) NextGetDeviceProcAddr(device, "vkDestroyShaderModule");
      this->m_DestroySwapchainKHR = (PFN_vkDestroySwapchainKHR) NextGetDeviceProcAddr(device, "vkDestroySwapchainKHR");
      this->m_DestroyTensorARM = (PFN_vkDestroyTensorARM) NextGetDeviceProcAddr(device, "vkDestroyTensorARM");
      this->m_DestroyTensorViewARM = (PFN_vkDestroyTensorViewARM) NextGetDeviceProcAddr(device, "vkDestroyTensorViewARM");
      this->m_DestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT) NextGetDeviceProcAddr(device, "vkDestroyValidationCacheEXT");
      this->m_DestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR) NextGetDeviceProcAddr(device, "vkDestroyVideoSessionKHR");
      this->m_DestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkDestroyVideoSessionParametersKHR");
      this->m_DeviceWaitIdle = (PFN_vkDeviceWaitIdle) NextGetDeviceProcAddr(device, "vkDeviceWaitIdle");
      this->m_DisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT) NextGetDeviceProcAddr(device, "vkDisplayPowerControlEXT");
      this->m_EndCommandBuffer = (PFN_vkEndCommandBuffer) NextGetDeviceProcAddr(device, "vkEndCommandBuffer");
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->m_ExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT) NextGetDeviceProcAddr(device, "vkExportMetalObjectsEXT");
#endif
      this->m_FlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges) NextGetDeviceProcAddr(device, "vkFlushMappedMemoryRanges");
      this->m_FreeCommandBuffers = (PFN_vkFreeCommandBuffers) NextGetDeviceProcAddr(device, "vkFreeCommandBuffers");
      this->m_FreeDescriptorSets = (PFN_vkFreeDescriptorSets) NextGetDeviceProcAddr(device, "vkFreeDescriptorSets");
      this->m_FreeMemory = (PFN_vkFreeMemory) NextGetDeviceProcAddr(device, "vkFreeMemory");
      this->m_GetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureBuildSizesKHR");
      this->m_GetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureDeviceAddressKHR");
      this->m_GetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureHandleNV");
      this->m_GetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNV");
      this->m_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->m_GetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID) NextGetDeviceProcAddr(device, "vkGetAndroidHardwareBufferPropertiesANDROID");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_GetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA) NextGetDeviceProcAddr(device, "vkGetBufferCollectionPropertiesFUCHSIA");
#endif
      this->m_GetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddress");
      this->m_GetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddressEXT");
      this->m_GetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddressKHR");
      this->m_GetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements");
      this->m_GetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2");
      this->m_GetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2KHR");
      this->m_GetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddress");
      this->m_GetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddressKHR");
      this->m_GetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
      this->m_GetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT) NextGetDeviceProcAddr(device, "vkGetCalibratedTimestampsEXT");
      this->m_GetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR) NextGetDeviceProcAddr(device, "vkGetCalibratedTimestampsKHR");
      this->m_GetClusterAccelerationStructureBuildSizesNV = (PFN_vkGetClusterAccelerationStructureBuildSizesNV) NextGetDeviceProcAddr(device, "vkGetClusterAccelerationStructureBuildSizesNV");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_GetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV) NextGetDeviceProcAddr(device, "vkGetCudaModuleCacheNV");
#endif
      this->m_GetDataGraphPipelineAvailablePropertiesARM = (PFN_vkGetDataGraphPipelineAvailablePropertiesARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineAvailablePropertiesARM");
      this->m_GetDataGraphPipelinePropertiesARM = (PFN_vkGetDataGraphPipelinePropertiesARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelinePropertiesARM");
      this->m_GetDataGraphPipelineSessionBindPointRequirementsARM = (PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionBindPointRequirementsARM");
      this->m_GetDataGraphPipelineSessionMemoryRequirementsARM = (PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionMemoryRequirementsARM");
      this->m_GetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR) NextGetDeviceProcAddr(device, "vkGetDeferredOperationMaxConcurrencyKHR");
      this->m_GetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR) NextGetDeviceProcAddr(device, "vkGetDeferredOperationResultKHR");
      this->m_GetDescriptorEXT = (PFN_vkGetDescriptorEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorEXT");
      this->m_GetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE) NextGetDeviceProcAddr(device, "vkGetDescriptorSetHostMappingVALVE");
      this->m_GetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutBindingOffsetEXT");
      this->m_GetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
      this->m_GetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSizeEXT");
      this->m_GetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupport");
      this->m_GetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupportKHR");
      this->m_GetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR) NextGetDeviceProcAddr(device, "vkGetDeviceAccelerationStructureCompatibilityKHR");
      this->m_GetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirements");
      this->m_GetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirementsKHR");
      this->m_GetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT) NextGetDeviceProcAddr(device, "vkGetDeviceFaultInfoEXT");
      this->m_GetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeatures");
      this->m_GetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
      this->m_GetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPresentCapabilitiesKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT) NextGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModes2EXT");
#endif
      this->m_GetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModesKHR");
      this->m_GetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirements");
      this->m_GetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirementsKHR");
      this->m_GetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirements");
      this->m_GetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirementsKHR");
      this->m_GetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageSubresourceLayoutKHR");
      this->m_GetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryCommitment");
      this->m_GetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddress");
      this->m_GetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
      this->m_GetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT) NextGetDeviceProcAddr(device, "vkGetDeviceMicromapCompatibilityEXT");
      this->m_GetDeviceProcAddr = NextGetDeviceProcAddr;
      this->m_GetDeviceQueue = (PFN_vkGetDeviceQueue) NextGetDeviceProcAddr(device, "vkGetDeviceQueue");
      this->m_GetDeviceQueue2 = (PFN_vkGetDeviceQueue2) NextGetDeviceProcAddr(device, "vkGetDeviceQueue2");
      this->m_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI) NextGetDeviceProcAddr(device, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
      this->m_GetDeviceTensorMemoryRequirementsARM = (PFN_vkGetDeviceTensorMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDeviceTensorMemoryRequirementsARM");
      this->m_GetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM) NextGetDeviceProcAddr(device, "vkGetDynamicRenderingTilePropertiesQCOM");
      this->m_GetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkGetEncodedVideoSessionParametersKHR");
      this->m_GetEventStatus = (PFN_vkGetEventStatus) NextGetDeviceProcAddr(device, "vkGetEventStatus");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_GetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX) NextGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineNodeIndexAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->m_GetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX) NextGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineScratchSizeAMDX");
#endif
      this->m_GetExternalComputeQueueDataNV = (PFN_vkGetExternalComputeQueueDataNV) NextGetDeviceProcAddr(device, "vkGetExternalComputeQueueDataNV");
      this->m_GetFenceFdKHR = (PFN_vkGetFenceFdKHR) NextGetDeviceProcAddr(device, "vkGetFenceFdKHR");
      this->m_GetFenceStatus = (PFN_vkGetFenceStatus) NextGetDeviceProcAddr(device, "vkGetFenceStatus");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetFenceWin32HandleKHR");
#endif
      this->m_GetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM) NextGetDeviceProcAddr(device, "vkGetFramebufferTilePropertiesQCOM");
      this->m_GetGeneratedCommandsMemoryRequirementsEXT = (PFN_vkGetGeneratedCommandsMemoryRequirementsEXT) NextGetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsEXT");
      this->m_GetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsNV");
      this->m_GetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT) NextGetDeviceProcAddr(device, "vkGetImageDrmFormatModifierPropertiesEXT");
      this->m_GetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements");
      this->m_GetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2");
      this->m_GetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2KHR");
      this->m_GetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetImageOpaqueCaptureDescriptorDataEXT");
      this->m_GetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements");
      this->m_GetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2");
      this->m_GetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2KHR");
      this->m_GetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout");
      this->m_GetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2EXT");
      this->m_GetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2KHR");
      this->m_GetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
      this->m_GetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV) NextGetDeviceProcAddr(device, "vkGetLatencyTimingsNV");
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->m_GetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID) NextGetDeviceProcAddr(device, "vkGetMemoryAndroidHardwareBufferANDROID");
#endif
      this->m_GetMemoryFdKHR = (PFN_vkGetMemoryFdKHR) NextGetDeviceProcAddr(device, "vkGetMemoryFdKHR");
      this->m_GetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR) NextGetDeviceProcAddr(device, "vkGetMemoryFdPropertiesKHR");
      this->m_GetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT) NextGetDeviceProcAddr(device, "vkGetMemoryHostPointerPropertiesEXT");
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->m_GetMemoryMetalHandleEXT = (PFN_vkGetMemoryMetalHandleEXT) NextGetDeviceProcAddr(device, "vkGetMemoryMetalHandleEXT");
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->m_GetMemoryMetalHandlePropertiesEXT = (PFN_vkGetMemoryMetalHandlePropertiesEXT) NextGetDeviceProcAddr(device, "vkGetMemoryMetalHandlePropertiesEXT");
#endif
      this->m_GetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV) NextGetDeviceProcAddr(device, "vkGetMemoryRemoteAddressNV");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandleNV");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandlePropertiesKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_GetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkGetMemoryZirconHandleFUCHSIA");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_GetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA) NextGetDeviceProcAddr(device, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
#endif
      this->m_GetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT) NextGetDeviceProcAddr(device, "vkGetMicromapBuildSizesEXT");
      this->m_GetPartitionedAccelerationStructuresBuildSizesNV = (PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV) NextGetDeviceProcAddr(device, "vkGetPartitionedAccelerationStructuresBuildSizesNV");
      this->m_GetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE) NextGetDeviceProcAddr(device, "vkGetPastPresentationTimingGOOGLE");
      this->m_GetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL) NextGetDeviceProcAddr(device, "vkGetPerformanceParameterINTEL");
      this->m_GetPipelineBinaryDataKHR = (PFN_vkGetPipelineBinaryDataKHR) NextGetDeviceProcAddr(device, "vkGetPipelineBinaryDataKHR");
      this->m_GetPipelineCacheData = (PFN_vkGetPipelineCacheData) NextGetDeviceProcAddr(device, "vkGetPipelineCacheData");
      this->m_GetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutableInternalRepresentationsKHR");
      this->m_GetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutablePropertiesKHR");
      this->m_GetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutableStatisticsKHR");
      this->m_GetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV) NextGetDeviceProcAddr(device, "vkGetPipelineIndirectDeviceAddressNV");
      this->m_GetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetPipelineIndirectMemoryRequirementsNV");
      this->m_GetPipelineKeyKHR = (PFN_vkGetPipelineKeyKHR) NextGetDeviceProcAddr(device, "vkGetPipelineKeyKHR");
      this->m_GetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT) NextGetDeviceProcAddr(device, "vkGetPipelinePropertiesEXT");
      this->m_GetPrivateData = (PFN_vkGetPrivateData) NextGetDeviceProcAddr(device, "vkGetPrivateData");
      this->m_GetPrivateDataEXT = (PFN_vkGetPrivateDataEXT) NextGetDeviceProcAddr(device, "vkGetPrivateDataEXT");
      this->m_GetQueryPoolResults = (PFN_vkGetQueryPoolResults) NextGetDeviceProcAddr(device, "vkGetQueryPoolResults");
      this->m_GetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV) NextGetDeviceProcAddr(device, "vkGetQueueCheckpointData2NV");
      this->m_GetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV) NextGetDeviceProcAddr(device, "vkGetQueueCheckpointDataNV");
      this->m_GetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
      this->m_GetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesKHR");
      this->m_GetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesNV");
      this->m_GetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupStackSizeKHR");
      this->m_GetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE) NextGetDeviceProcAddr(device, "vkGetRefreshCycleDurationGOOGLE");
      this->m_GetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity) NextGetDeviceProcAddr(device, "vkGetRenderAreaGranularity");
      this->m_GetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR) NextGetDeviceProcAddr(device, "vkGetRenderingAreaGranularityKHR");
      this->m_GetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->m_GetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX) NextGetDeviceProcAddr(device, "vkGetScreenBufferPropertiesQNX");
#endif
      this->m_GetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue) NextGetDeviceProcAddr(device, "vkGetSemaphoreCounterValue");
      this->m_GetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreCounterValueKHR");
      this->m_GetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_GetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_GetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkGetSemaphoreZirconHandleFUCHSIA");
#endif
      this->m_GetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT) NextGetDeviceProcAddr(device, "vkGetShaderBinaryDataEXT");
      this->m_GetShaderInfoAMD = (PFN_vkGetShaderInfoAMD) NextGetDeviceProcAddr(device, "vkGetShaderInfoAMD");
      this->m_GetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT) NextGetDeviceProcAddr(device, "vkGetShaderModuleCreateInfoIdentifierEXT");
      this->m_GetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT) NextGetDeviceProcAddr(device, "vkGetShaderModuleIdentifierEXT");
      this->m_GetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT) NextGetDeviceProcAddr(device, "vkGetSwapchainCounterEXT");
      this->m_GetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) NextGetDeviceProcAddr(device, "vkGetSwapchainImagesKHR");
      this->m_GetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR) NextGetDeviceProcAddr(device, "vkGetSwapchainStatusKHR");
      this->m_GetTensorMemoryRequirementsARM = (PFN_vkGetTensorMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetTensorMemoryRequirementsARM");
      this->m_GetTensorOpaqueCaptureDescriptorDataARM = (PFN_vkGetTensorOpaqueCaptureDescriptorDataARM) NextGetDeviceProcAddr(device, "vkGetTensorOpaqueCaptureDescriptorDataARM");
      this->m_GetTensorViewOpaqueCaptureDescriptorDataARM = (PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM) NextGetDeviceProcAddr(device, "vkGetTensorViewOpaqueCaptureDescriptorDataARM");
      this->m_GetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT) NextGetDeviceProcAddr(device, "vkGetValidationCacheDataEXT");
      this->m_GetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetVideoSessionMemoryRequirementsKHR");
      this->m_ImportFenceFdKHR = (PFN_vkImportFenceFdKHR) NextGetDeviceProcAddr(device, "vkImportFenceFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_ImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR) NextGetDeviceProcAddr(device, "vkImportFenceWin32HandleKHR");
#endif
      this->m_ImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR) NextGetDeviceProcAddr(device, "vkImportSemaphoreFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_ImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR) NextGetDeviceProcAddr(device, "vkImportSemaphoreWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_ImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkImportSemaphoreZirconHandleFUCHSIA");
#endif
      this->m_InitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL) NextGetDeviceProcAddr(device, "vkInitializePerformanceApiINTEL");
      this->m_InvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges) NextGetDeviceProcAddr(device, "vkInvalidateMappedMemoryRanges");
      this->m_LatencySleepNV = (PFN_vkLatencySleepNV) NextGetDeviceProcAddr(device, "vkLatencySleepNV");
      this->m_MapMemory = (PFN_vkMapMemory) NextGetDeviceProcAddr(device, "vkMapMemory");
      this->m_MapMemory2KHR = (PFN_vkMapMemory2KHR) NextGetDeviceProcAddr(device, "vkMapMemory2KHR");
      this->m_MergePipelineCaches = (PFN_vkMergePipelineCaches) NextGetDeviceProcAddr(device, "vkMergePipelineCaches");
      this->m_MergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT) NextGetDeviceProcAddr(device, "vkMergeValidationCachesEXT");
      this->m_QueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueBeginDebugUtilsLabelEXT");
      this->m_QueueBindSparse = (PFN_vkQueueBindSparse) NextGetDeviceProcAddr(device, "vkQueueBindSparse");
      this->m_QueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueEndDebugUtilsLabelEXT");
      this->m_QueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueInsertDebugUtilsLabelEXT");
      this->m_QueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV) NextGetDeviceProcAddr(device, "vkQueueNotifyOutOfBandNV");
      this->m_QueuePresentKHR = (PFN_vkQueuePresentKHR) NextGetDeviceProcAddr(device, "vkQueuePresentKHR");
      this->m_QueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkQueueSetPerformanceConfigurationINTEL");
      this->m_QueueSubmit = (PFN_vkQueueSubmit) NextGetDeviceProcAddr(device, "vkQueueSubmit");
      this->m_QueueSubmit2 = (PFN_vkQueueSubmit2) NextGetDeviceProcAddr(device, "vkQueueSubmit2");
      this->m_QueueSubmit2KHR = (PFN_vkQueueSubmit2KHR) NextGetDeviceProcAddr(device, "vkQueueSubmit2KHR");
      this->m_QueueWaitIdle = (PFN_vkQueueWaitIdle) NextGetDeviceProcAddr(device, "vkQueueWaitIdle");
      this->m_RegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT) NextGetDeviceProcAddr(device, "vkRegisterDeviceEventEXT");
      this->m_RegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT) NextGetDeviceProcAddr(device, "vkRegisterDisplayEventEXT");
      this->m_ReleaseCapturedPipelineDataKHR = (PFN_vkReleaseCapturedPipelineDataKHR) NextGetDeviceProcAddr(device, "vkReleaseCapturedPipelineDataKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->m_ReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT) NextGetDeviceProcAddr(device, "vkReleaseFullScreenExclusiveModeEXT");
#endif
      this->m_ReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkReleasePerformanceConfigurationINTEL");
      this->m_ReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR) NextGetDeviceProcAddr(device, "vkReleaseProfilingLockKHR");
      this->m_ReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT) NextGetDeviceProcAddr(device, "vkReleaseSwapchainImagesEXT");
      this->m_ReleaseSwapchainImagesKHR = (PFN_vkReleaseSwapchainImagesKHR) NextGetDeviceProcAddr(device, "vkReleaseSwapchainImagesKHR");
      this->m_ResetCommandBuffer = (PFN_vkResetCommandBuffer) NextGetDeviceProcAddr(device, "vkResetCommandBuffer");
      this->m_ResetCommandPool = (PFN_vkResetCommandPool) NextGetDeviceProcAddr(device, "vkResetCommandPool");
      this->m_ResetDescriptorPool = (PFN_vkResetDescriptorPool) NextGetDeviceProcAddr(device, "vkResetDescriptorPool");
      this->m_ResetEvent = (PFN_vkResetEvent) NextGetDeviceProcAddr(device, "vkResetEvent");
      this->m_ResetFences = (PFN_vkResetFences) NextGetDeviceProcAddr(device, "vkResetFences");
      this->m_ResetQueryPool = (PFN_vkResetQueryPool) NextGetDeviceProcAddr(device, "vkResetQueryPool");
      this->m_ResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT) NextGetDeviceProcAddr(device, "vkResetQueryPoolEXT");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_SetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA) NextGetDeviceProcAddr(device, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->m_SetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA) NextGetDeviceProcAddr(device, "vkSetBufferCollectionImageConstraintsFUCHSIA");
#endif
      this->m_SetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT) NextGetDeviceProcAddr(device, "vkSetDebugUtilsObjectNameEXT");
      this->m_SetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT) NextGetDeviceProcAddr(device, "vkSetDebugUtilsObjectTagEXT");
      this->m_SetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT) NextGetDeviceProcAddr(device, "vkSetDeviceMemoryPriorityEXT");
      this->m_SetEvent = (PFN_vkSetEvent) NextGetDeviceProcAddr(device, "vkSetEvent");
      this->m_SetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT) NextGetDeviceProcAddr(device, "vkSetHdrMetadataEXT");
      this->m_SetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV) NextGetDeviceProcAddr(device, "vkSetLatencyMarkerNV");
      this->m_SetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV) NextGetDeviceProcAddr(device, "vkSetLatencySleepModeNV");
      this->m_SetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD) NextGetDeviceProcAddr(device, "vkSetLocalDimmingAMD");
      this->m_SetPrivateData = (PFN_vkSetPrivateData) NextGetDeviceProcAddr(device, "vkSetPrivateData");
      this->m_SetPrivateDataEXT = (PFN_vkSetPrivateDataEXT) NextGetDeviceProcAddr(device, "vkSetPrivateDataEXT");
      this->m_SignalSemaphore = (PFN_vkSignalSemaphore) NextGetDeviceProcAddr(device, "vkSignalSemaphore");
      this->m_SignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR) NextGetDeviceProcAddr(device, "vkSignalSemaphoreKHR");
      this->m_TransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT) NextGetDeviceProcAddr(device, "vkTransitionImageLayoutEXT");
      this->m_TrimCommandPool = (PFN_vkTrimCommandPool) NextGetDeviceProcAddr(device, "vkTrimCommandPool");
      this->m_TrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR) NextGetDeviceProcAddr(device, "vkTrimCommandPoolKHR");
      this->m_UninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL) NextGetDeviceProcAddr(device, "vkUninitializePerformanceApiINTEL");
      this->m_UnmapMemory = (PFN_vkUnmapMemory) NextGetDeviceProcAddr(device, "vkUnmapMemory");
      this->m_UnmapMemory2KHR = (PFN_vkUnmapMemory2KHR) NextGetDeviceProcAddr(device, "vkUnmapMemory2KHR");
      this->m_UpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplate");
      this->m_UpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplateKHR");
      this->m_UpdateDescriptorSets = (PFN_vkUpdateDescriptorSets) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSets");
      this->m_UpdateIndirectExecutionSetPipelineEXT = (PFN_vkUpdateIndirectExecutionSetPipelineEXT) NextGetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetPipelineEXT");
      this->m_UpdateIndirectExecutionSetShaderEXT = (PFN_vkUpdateIndirectExecutionSetShaderEXT) NextGetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetShaderEXT");
      this->m_UpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkUpdateVideoSessionParametersKHR");
      this->m_WaitForFences = (PFN_vkWaitForFences) NextGetDeviceProcAddr(device, "vkWaitForFences");
      this->m_WaitForPresent2KHR = (PFN_vkWaitForPresent2KHR) NextGetDeviceProcAddr(device, "vkWaitForPresent2KHR");
      this->m_WaitForPresentKHR = (PFN_vkWaitForPresentKHR) NextGetDeviceProcAddr(device, "vkWaitForPresentKHR");
      this->m_WaitSemaphores = (PFN_vkWaitSemaphores) NextGetDeviceProcAddr(device, "vkWaitSemaphores");
      this->m_WaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR) NextGetDeviceProcAddr(device, "vkWaitSemaphoresKHR");
      this->m_WriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR) NextGetDeviceProcAddr(device, "vkWriteAccelerationStructuresPropertiesKHR");
      this->m_WriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT) NextGetDeviceProcAddr(device, "vkWriteMicromapsPropertiesEXT");
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return pPhysicalDeviceDispatch->AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return m_AcquireFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) const { return m_AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex); }
    VkResult AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) const { return m_AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex); }
    VkResult AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) const { return m_AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration); }
    VkResult AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) const { return m_AcquireProfilingLockKHR(device, pInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pPhysicalDeviceDispatch->AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return pPhysicalDeviceDispatch->AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
      VkResult AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) const {
          VkResult ret = m_AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
          if (ret == VK_SUCCESS) {
              for (uint32_t i = 0; i < pAllocateInfo->commandBufferCount; i++)
                tables::AssignDispatchTable(pCommandBuffers[i], this);
          }
          return ret;
      };
    VkResult AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) const { return m_AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets); }
    VkResult AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) const { return m_AllocateMemory(device, pAllocateInfo, pAllocator, pMemory); }
    void AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) const { m_AntiLagUpdateAMD(device, pData); }
    VkResult BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) const { return m_BeginCommandBuffer(commandBuffer, pBeginInfo); }
    VkResult BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) const { return m_BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return m_BindBufferMemory(device, buffer, memory, memoryOffset); }
    VkResult BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return m_BindBufferMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return m_BindBufferMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) const { return m_BindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return m_BindImageMemory(device, image, memory, memoryOffset); }
    VkResult BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return m_BindImageMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return m_BindImageMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) const { return m_BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout); }
    VkResult BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) const { return m_BindTensorMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) const { return m_BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos); }
    VkResult BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { return m_BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos); }
    VkResult BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { return m_BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos); }
    void CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) const { m_CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin); }
    void CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { m_CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) const { m_CmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo); }
    void CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) const { m_CmdBeginQuery(commandBuffer, queryPool, query, flags); }
    void CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) const { m_CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index); }
    void CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) const { m_CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents); }
    void CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { m_CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { m_CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { m_CmdBeginRendering(commandBuffer, pRenderingInfo); }
    void CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { m_CmdBeginRenderingKHR(commandBuffer, pRenderingInfo); }
    void CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { m_CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) const { m_CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) const { m_CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) const { m_CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set); }
    void CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) const { m_CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos); }
    void CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) const { m_CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); }
    void CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) const { m_CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo); }
    void CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) const { m_CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType); }
    void CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) const { m_CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType); }
    void CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { m_CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout); }
    void CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { m_CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) const { m_CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex); }
    void CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) const { m_CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders); }
    void CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { m_CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout); }
    void CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) const { m_CmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo); }
    void CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) const { m_CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes); }
    void CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) const { m_CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets); }
    void CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { m_CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { m_CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) const { m_CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter); }
    void CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { m_CmdBlitImage2(commandBuffer, pBlitImageInfo); }
    void CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { m_CmdBlitImage2KHR(commandBuffer, pBlitImageInfo); }
    void CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) const { m_CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset); }
    void CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) const { m_CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
    void CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { m_CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos); }
    void CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) const { m_CmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos); }
    void CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { m_CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos); }
    void CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) const { m_CmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo); }
    void CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) const { m_CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects); }
    void CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { m_CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges); }
    void CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { m_CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges); }
    void CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) const { m_CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo); }
    void CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) const { m_CmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos); }
    void CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) const { m_CmdCopyAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) const { m_CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode); }
    void CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { m_CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo); }
    void CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) const { m_CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions); }
    void CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { m_CmdCopyBuffer2(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { m_CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { m_CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { m_CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { m_CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) const { m_CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { m_CmdCopyImage2(commandBuffer, pCopyImageInfo); }
    void CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { m_CmdCopyImage2KHR(commandBuffer, pCopyImageInfo); }
    void CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { m_CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions); }
    void CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { m_CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { m_CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) const { m_CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride); }
    void CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { m_CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) const { m_CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources); }
    void CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { m_CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) const { m_CmdCopyMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { m_CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo); }
    void CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) const { m_CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags); }
    void CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) const { m_CmdCopyTensorARM(commandBuffer, pCopyTensorInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) const { m_CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo); }
#endif
    void CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { m_CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo); }
    void CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) const { m_CmdDebugMarkerEndEXT(commandBuffer); }
    void CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { m_CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo); }
    void CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) const { m_CmdDecodeVideoKHR(commandBuffer, pDecodeInfo); }
    void CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) const { m_CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
    void CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) const { m_CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions); }
    void CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { m_CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { m_CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { m_CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) const { m_CmdDispatchDataGraphARM(commandBuffer, session, pInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { m_CmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { m_CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) const { m_CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo); }
#endif
    void CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { m_CmdDispatchIndirect(commandBuffer, buffer, offset); }
    void CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) const { m_CmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo); }
    void CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const { m_CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance); }
    void CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { m_CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { m_CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset); }
    void CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const { m_CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
    void CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { m_CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { m_CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const { m_CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride); }
    void CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { m_CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { m_CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { m_CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { m_CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) const { m_CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask); }
    void CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) const { m_CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride); }
    void CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) const { m_CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset); }
    void CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) const { m_CmdEncodeVideoKHR(commandBuffer, pEncodeInfo); }
    void CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) const { m_CmdEndConditionalRenderingEXT(commandBuffer); }
    void CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) const { m_CmdEndDebugUtilsLabelEXT(commandBuffer); }
    void CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) const { m_CmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo); }
    void CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) const { m_CmdEndQuery(commandBuffer, queryPool, query); }
    void CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) const { m_CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index); }
    void CmdEndRenderPass(VkCommandBuffer commandBuffer) const { m_CmdEndRenderPass(commandBuffer); }
    void CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { m_CmdEndRenderPass2(commandBuffer, pSubpassEndInfo); }
    void CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { m_CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo); }
    void CmdEndRendering(VkCommandBuffer commandBuffer) const { m_CmdEndRendering(commandBuffer); }
    void CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) const { m_CmdEndRendering2EXT(commandBuffer, pRenderingEndInfo); }
    void CmdEndRenderingKHR(VkCommandBuffer commandBuffer) const { m_CmdEndRenderingKHR(commandBuffer); }
    void CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { m_CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) const { m_CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo); }
    void CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { m_CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers); }
    void CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) const { m_CmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { m_CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) const { m_CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) const { m_CmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize); }
#endif
    void CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { m_CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) const { m_CmdNextSubpass(commandBuffer, contents); }
    void CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { m_CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { m_CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) const { m_CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo); }
    void CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { m_CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { m_CmdPipelineBarrier2(commandBuffer, pDependencyInfo); }
    void CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { m_CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo); }
    void CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) const { m_CmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer); }
    void CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { m_CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo); }
    void CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) const { m_CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues); }
    void CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) const { m_CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo); }
    void CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) const { m_CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo); }
    void CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) const { m_CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
    void CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) const { m_CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo); }
    void CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) const { m_CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
    void CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { m_CmdResetEvent(commandBuffer, event, stageMask); }
    void CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { m_CmdResetEvent2(commandBuffer, event, stageMask); }
    void CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { m_CmdResetEvent2KHR(commandBuffer, event, stageMask); }
    void CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { m_CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount); }
    void CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) const { m_CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { m_CmdResolveImage2(commandBuffer, pResolveImageInfo); }
    void CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { m_CmdResolveImage2KHR(commandBuffer, pResolveImageInfo); }
    void CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) const { m_CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable); }
    void CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) const { m_CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable); }
    void CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) const { m_CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask); }
    void CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) const { m_CmdSetBlendConstants(commandBuffer, blendConstants); }
    void CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) const { m_CmdSetCheckpointNV(commandBuffer, pCheckpointMarker); }
    void CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) const { m_CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders); }
    void CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) const { m_CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced); }
    void CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) const { m_CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables); }
    void CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) const { m_CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations); }
    void CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) const { m_CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables); }
    void CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) const { m_CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks); }
    void CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) const { m_CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode); }
    void CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) const { m_CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode); }
    void CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) const { m_CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable); }
    void CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) const { m_CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable); }
    void CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) const { m_CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode); }
    void CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) const { m_CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable); }
    void CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) const { m_CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation); }
    void CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { m_CmdSetCullMode(commandBuffer, cullMode); }
    void CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { m_CmdSetCullModeEXT(commandBuffer, cullMode); }
    void CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const { m_CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
    void CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) const { m_CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo); }
    void CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { m_CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { m_CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) const { m_CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds); }
    void CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { m_CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { m_CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) const { m_CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable); }
    void CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) const { m_CmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange); }
    void CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) const { m_CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable); }
    void CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) const { m_CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne); }
    void CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { m_CmdSetDepthCompareOp(commandBuffer, depthCompareOp); }
    void CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { m_CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp); }
    void CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { m_CmdSetDepthTestEnable(commandBuffer, depthTestEnable); }
    void CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { m_CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable); }
    void CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { m_CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable); }
    void CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { m_CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable); }
    void CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) const { m_CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo); }
    void CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) const { m_CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets); }
    void CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { m_CmdSetDeviceMask(commandBuffer, deviceMask); }
    void CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { m_CmdSetDeviceMaskKHR(commandBuffer, deviceMask); }
    void CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) const { m_CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles); }
    void CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) const { m_CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable); }
    void CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) const { m_CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode); }
    void CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { m_CmdSetEvent(commandBuffer, event, stageMask); }
    void CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { m_CmdSetEvent2(commandBuffer, event, pDependencyInfo); }
    void CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { m_CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo); }
    void CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) const { m_CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
    void CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) const { m_CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors); }
    void CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) const { m_CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize); }
    void CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { m_CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps); }
    void CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { m_CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps); }
    void CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { m_CmdSetFrontFace(commandBuffer, frontFace); }
    void CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { m_CmdSetFrontFaceEXT(commandBuffer, frontFace); }
    void CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) const { m_CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode); }
    void CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { m_CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) const { m_CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable); }
    void CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { m_CmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) const { m_CmdSetLineWidth(commandBuffer, lineWidth); }
    void CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) const { m_CmdSetLogicOpEXT(commandBuffer, logicOp); }
    void CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) const { m_CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable); }
    void CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) const { m_CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints); }
    VkResult CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) const { return m_CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo); }
    VkResult CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) const { return m_CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo); }
    VkResult CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) const { return m_CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo); }
    void CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) const { m_CmdSetPolygonModeEXT(commandBuffer, polygonMode); }
    void CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { m_CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { m_CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { m_CmdSetPrimitiveTopology(commandBuffer, primitiveTopology); }
    void CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { m_CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology); }
    void CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) const { m_CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode); }
    void CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) const { m_CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples); }
    void CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) const { m_CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream); }
    void CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { m_CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { m_CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) const { m_CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize); }
    void CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) const { m_CmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo); }
    void CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) const { m_CmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo); }
    void CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) const { m_CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable); }
    void CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) const { m_CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo); }
    void CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) const { m_CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable); }
    void CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) const { m_CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask); }
    void CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) const { m_CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors); }
    void CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { m_CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors); }
    void CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { m_CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors); }
    void CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) const { m_CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable); }
    void CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) const { m_CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask); }
    void CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { m_CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { m_CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) const { m_CmdSetStencilReference(commandBuffer, faceMask, reference); }
    void CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { m_CmdSetStencilTestEnable(commandBuffer, stencilTestEnable); }
    void CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { m_CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable); }
    void CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) const { m_CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask); }
    void CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) const { m_CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin); }
    void CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) const { m_CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions); }
    void CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) const { m_CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports); }
    void CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) const { m_CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes); }
    void CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) const { m_CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles); }
    void CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) const { m_CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable); }
    void CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) const { m_CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings); }
    void CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { m_CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports); }
    void CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { m_CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports); }
    void CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) const { m_CmdSubpassShadingHUAWEI(commandBuffer); }
    void CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) const { m_CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress); }
    void CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) const { m_CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress); }
    void CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const { m_CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth); }
    void CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) const { m_CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
    void CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) const { m_CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData); }
    void CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { m_CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { m_CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { m_CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { m_CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { m_CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { m_CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { m_CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker); }
    void CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { m_CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker); }
    void CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { m_CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery); }
    void CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) const { m_CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query); }
    void CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { m_CmdWriteTimestamp2(commandBuffer, stage, queryPool, query); }
    void CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { m_CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query); }
    VkResult CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) const { return m_CompileDeferredNV(device, pipeline, shader); }
    VkResult ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) const { return m_ConvertCooperativeVectorMatrixNV(device, pInfo); }
    VkResult CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) const { return m_CopyAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { return m_CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo); }
    VkResult CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) const { return m_CopyImageToImageEXT(device, pCopyImageToImageInfo); }
    VkResult CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) const { return m_CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo); }
    VkResult CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { return m_CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) const { return m_CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo); }
    VkResult CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { return m_CopyMemoryToMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) const { return m_CopyMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { return m_CopyMicromapToMemoryEXT(device, deferredOperation, pInfo); }
    VkResult CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) const { return m_CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure); }
    VkResult CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) const { return m_CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) const { return m_CreateBuffer(device, pCreateInfo, pAllocator, pBuffer); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) const { return m_CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection); }
#endif
    VkResult CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) const { return m_CreateBufferView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) const { return m_CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool); }
    VkResult CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) const { return m_CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) const { return m_CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule); }
#endif
    VkResult CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) const { return m_CreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return pPhysicalDeviceDispatch->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return pPhysicalDeviceDispatch->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }
    VkResult CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) const { return m_CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation); }
    VkResult CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) const { return m_CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool); }
    VkResult CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) const { return m_CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout); }
    VkResult CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return m_CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return m_CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const { return pPhysicalDeviceDispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return pPhysicalDeviceDispatch->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) const { return m_CreateEvent(device, pCreateInfo, pAllocator, pEvent); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#endif
    VkResult CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) const { return m_CreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue); }
    VkResult CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return m_CreateFence(device, pCreateInfo, pAllocator, pFence); }
    VkResult CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) const { return m_CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer); }
    VkResult CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) const { return m_CreateImage(device, pCreateInfo, pAllocator, pImage); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) const { return m_CreateImageView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) const { return m_CreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) const { return m_CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) const { return m_CreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet); }
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return pPhysicalDeviceDispatch->CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) const { return m_CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap); }
    VkResult CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) const { return m_CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) const { return m_CreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries); }
    VkResult CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) const { return m_CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache); }
    VkResult CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) const { return m_CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout); }
    VkResult CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return m_CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return m_CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) const { return m_CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool); }
    VkResult CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return m_CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return m_CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return m_CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return m_CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) const { return m_CreateSampler(device, pCreateInfo, pAllocator, pSampler); }
    VkResult CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return m_CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion); }
    VkResult CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return m_CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) const { return m_CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore); }
    VkResult CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) const { return m_CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule); }
    VkResult CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) const { return m_CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders); }
    VkResult CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) const { return m_CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains); }
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) const { return m_CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain); }
    VkResult CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) const { return m_CreateTensorARM(device, pCreateInfo, pAllocator, pTensor); }
    VkResult CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) const { return m_CreateTensorViewARM(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) const { return m_CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache); }
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) const { return m_CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession); }
    VkResult CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) const { return m_CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pPhysicalDeviceDispatch->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) const { return m_DebugMarkerSetObjectNameEXT(device, pNameInfo); }
    VkResult DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) const { return m_DebugMarkerSetObjectTagEXT(device, pTagInfo); }
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { pPhysicalDeviceDispatch->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    VkResult DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) const { return m_DeferredOperationJoinKHR(device, operation); }
    void DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) const { m_DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator); }
    void DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) const { m_DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator); }
    void DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) const { m_DestroyBuffer(device, buffer, pAllocator); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    void DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) const { m_DestroyBufferCollectionFUCHSIA(device, collection, pAllocator); }
#endif
    void DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) const { m_DestroyBufferView(device, bufferView, pAllocator); }
    void DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) const { m_DestroyCommandPool(device, commandPool, pAllocator); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) const { m_DestroyCudaFunctionNV(device, function, pAllocator); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) const { m_DestroyCudaModuleNV(device, module, pAllocator); }
#endif
    void DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) const { m_DestroyDataGraphPipelineSessionARM(device, session, pAllocator); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { pPhysicalDeviceDispatch->DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { pPhysicalDeviceDispatch->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) const { m_DestroyDeferredOperationKHR(device, operation, pAllocator); }
    void DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) const { m_DestroyDescriptorPool(device, descriptorPool, pAllocator); }
    void DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) const { m_DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator); }
    void DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { m_DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { m_DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDevice(VkDevice object, const VkAllocationCallbacks* pAllocator) const {
      vkroots::tables::DestroyDispatchTable(object);
      m_DestroyDevice(object, pAllocator);
    }
    void DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) const { m_DestroyEvent(device, event, pAllocator); }
    void DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) const { m_DestroyExternalComputeQueueNV(device, externalQueue, pAllocator); }
    void DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) const { m_DestroyFence(device, fence, pAllocator); }
    void DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) const { m_DestroyFramebuffer(device, framebuffer, pAllocator); }
    void DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) const { m_DestroyImage(device, image, pAllocator); }
    void DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) const { m_DestroyImageView(device, imageView, pAllocator); }
    void DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { m_DestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { m_DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) const { m_DestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator); }
    void DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const { pPhysicalDeviceDispatch->DestroyInstance(instance, pAllocator); }
    void DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) const { m_DestroyMicromapEXT(device, micromap, pAllocator); }
    void DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) const { m_DestroyOpticalFlowSessionNV(device, session, pAllocator); }
    void DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) const { m_DestroyPipeline(device, pipeline, pAllocator); }
    void DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) const { m_DestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator); }
    void DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) const { m_DestroyPipelineCache(device, pipelineCache, pAllocator); }
    void DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) const { m_DestroyPipelineLayout(device, pipelineLayout, pAllocator); }
    void DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { m_DestroyPrivateDataSlot(device, privateDataSlot, pAllocator); }
    void DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { m_DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator); }
    void DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) const { m_DestroyQueryPool(device, queryPool, pAllocator); }
    void DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) const { m_DestroyRenderPass(device, renderPass, pAllocator); }
    void DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) const { m_DestroySampler(device, sampler, pAllocator); }
    void DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { m_DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator); }
    void DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { m_DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator); }
    void DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) const { m_DestroySemaphore(device, semaphore, pAllocator); }
    void DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) const { m_DestroyShaderEXT(device, shader, pAllocator); }
    void DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) const { m_DestroyShaderModule(device, shaderModule, pAllocator); }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { pPhysicalDeviceDispatch->DestroySurfaceKHR(instance, surface, pAllocator); }
    void DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) const { m_DestroySwapchainKHR(device, swapchain, pAllocator); }
    void DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) const { m_DestroyTensorARM(device, tensor, pAllocator); }
    void DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) const { m_DestroyTensorViewARM(device, tensorView, pAllocator); }
    void DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) const { m_DestroyValidationCacheEXT(device, validationCache, pAllocator); }
    void DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) const { m_DestroyVideoSessionKHR(device, videoSession, pAllocator); }
    void DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) const { m_DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator); }
    VkResult DeviceWaitIdle(VkDevice device) const { return m_DeviceWaitIdle(device); }
    VkResult DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) const { return m_DisplayPowerControlEXT(device, display, pDisplayPowerInfo); }
    VkResult EndCommandBuffer(VkCommandBuffer commandBuffer) const { return m_EndCommandBuffer(commandBuffer); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return pPhysicalDeviceDispatch->EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return pPhysicalDeviceDispatch->EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pPhysicalDeviceDispatch->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pPhysicalDeviceDispatch->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return pPhysicalDeviceDispatch->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return pPhysicalDeviceDispatch->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    void ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) const { m_ExportMetalObjectsEXT(device, pMetalObjectsInfo); }
#endif
    VkResult FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return m_FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
      void FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const {
          for (uint32_t i = 0; i < commandBufferCount; i++)
            tables::UnassignDispatchTable(pCommandBuffers[i]);
          m_FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
      };
    VkResult FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) const { return m_FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets); }
    void FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) const { m_FreeMemory(device, memory, pAllocator); }
    void GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { m_GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo); }
    VkDeviceAddress GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) const { return m_GetAccelerationStructureDeviceAddressKHR(device, pInfo); }
    VkResult GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) const { return m_GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData); }
    void GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) const { m_GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return m_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) const { return m_GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) const { return m_GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties); }
#endif
    VkDeviceAddress GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return m_GetBufferDeviceAddress(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return m_GetBufferDeviceAddressEXT(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return m_GetBufferDeviceAddressKHR(device, pInfo); }
    void GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) const { m_GetBufferMemoryRequirements(device, buffer, pMemoryRequirements); }
    void GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    uint64_t GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return m_GetBufferOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return m_GetBufferOpaqueCaptureAddressKHR(device, pInfo); }
    VkResult GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return m_GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    VkResult GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return m_GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    VkResult GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return m_GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    void GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { m_GetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) const { return m_GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData); }
#endif
    VkResult GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) const { return m_GetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties); }
    VkResult GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) const { return m_GetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties); }
    VkResult GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) const { return m_GetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount, pBindPointRequirements); }
    void GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    uint32_t GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) const { return m_GetDeferredOperationMaxConcurrencyKHR(device, operation); }
    VkResult GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) const { return m_GetDeferredOperationResultKHR(device, operation); }
    void GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) const { m_GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor); }
    void GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) const { m_GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData); }
    void GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) const { m_GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset); }
    void GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) const { m_GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping); }
    void GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) const { m_GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes); }
    void GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { m_GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport); }
    void GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { m_GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport); }
    void GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { m_GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility); }
    void GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    VkResult GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) const { return m_GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo); }
    void GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { m_GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    void GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { m_GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    VkResult GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) const { return m_GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return m_GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes); }
#endif
    VkResult GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return m_GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes); }
    void GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { m_GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { m_GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) const { m_GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout); }
    void GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) const { m_GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return m_GetDeviceMemoryOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return m_GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo); }
    void GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { m_GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility); }
    PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char *pName) const { return m_GetDeviceProcAddr(device, pName); }
    void GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) const { m_GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue); }
    void GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) const { m_GetDeviceQueue2(device, pQueueInfo, pQueue); }
    VkResult GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) const { return m_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize); }
    void GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return pPhysicalDeviceDispatch->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return pPhysicalDeviceDispatch->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return pPhysicalDeviceDispatch->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return pPhysicalDeviceDispatch->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return pPhysicalDeviceDispatch->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return pPhysicalDeviceDispatch->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    VkResult GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) const { return m_GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties); }
    VkResult GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) const { return m_GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData); }
    VkResult GetEventStatus(VkDevice device, VkEvent event) const { return m_GetEventStatus(device, event); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) const { return m_GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) const { return m_GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo); }
#endif
    void GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) const { m_GetExternalComputeQueueDataNV(externalQueue, params, pData); }
    VkResult GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) const { return m_GetFenceFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetFenceStatus(VkDevice device, VkFence fence) const { return m_GetFenceStatus(device, fence); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return m_GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
    VkResult GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) const { return m_GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties); }
    void GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements); }
    void GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) const { return m_GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties); }
    void GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) const { m_GetImageMemoryRequirements(device, image, pMemoryRequirements); }
    void GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    VkResult GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return m_GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    void GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) const { m_GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { m_GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { m_GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) const { m_GetImageSubresourceLayout(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { m_GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { m_GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout); }
    VkResult GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return m_GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return pPhysicalDeviceDispatch->GetInstanceProcAddr(instance, pName); }
    void GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { m_GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) const { return m_GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer); }
#endif
    VkResult GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) const { return m_GetMemoryFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) const { return m_GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties); }
    VkResult GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) const { return m_GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) const { return m_GetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) const { return m_GetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties); }
#endif
    VkResult GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) const { return m_GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return m_GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) const { return m_GetMemoryWin32HandleNV(device, memory, handleType, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) const { return m_GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return m_GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) const { return m_GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties); }
#endif
    void GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) const { m_GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo); }
    void GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { m_GetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo); }
    VkResult GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) const { return m_GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings); }
    VkResult GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) const { return m_GetPerformanceParameterINTEL(device, parameter, pValue); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return pPhysicalDeviceDispatch->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pPhysicalDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return pPhysicalDeviceDispatch->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
    VkResult GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) const { return m_GetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData); }
    VkResult GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) const { return m_GetPipelineCacheData(device, pipelineCache, pDataSize, pData); }
    VkResult GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) const { return m_GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations); }
    VkResult GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) const { return m_GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties); }
    VkResult GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) const { return m_GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics); }
    VkDeviceAddress GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) const { return m_GetPipelineIndirectDeviceAddressNV(device, pInfo); }
    void GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements); }
    VkResult GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) const { return m_GetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey); }
    VkResult GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) const { return m_GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties); }
    void GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { m_GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData); }
    void GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { m_GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData); }
    VkResult GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) const { return m_GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags); }
    void GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) const { m_GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData); }
    void GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) const { m_GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData); }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return pPhysicalDeviceDispatch->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
    VkResult GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return m_GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return m_GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return m_GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkDeviceSize GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) const { return m_GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader); }
    VkResult GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) const { return m_GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties); }
    void GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) const { m_GetRenderAreaGranularity(device, renderPass, pGranularity); }
    void GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) const { m_GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity); }
    VkResult GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return m_GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) const { return m_GetScreenBufferPropertiesQNX(device, buffer, pProperties); }
#endif
    VkResult GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return m_GetSemaphoreCounterValue(device, semaphore, pValue); }
    VkResult GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return m_GetSemaphoreCounterValueKHR(device, semaphore, pValue); }
    VkResult GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) const { return m_GetSemaphoreFdKHR(device, pGetFdInfo, pFd); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return m_GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return m_GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
    VkResult GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) const { return m_GetShaderBinaryDataEXT(device, shader, pDataSize, pData); }
    VkResult GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) const { return m_GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo); }
    void GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) const { m_GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier); }
    void GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) const { m_GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier); }
    VkResult GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) const { return m_GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue); }
    VkResult GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) const { return m_GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages); }
    VkResult GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) const { return m_GetSwapchainStatusKHR(device, swapchain); }
    void GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { m_GetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return m_GetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return m_GetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) const { return m_GetValidationCacheDataEXT(device, validationCache, pDataSize, pData); }
    VkResult GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) const { return m_GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return pPhysicalDeviceDispatch->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) const { return m_ImportFenceFdKHR(device, pImportFenceFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) const { return m_ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo); }
#endif
    VkResult ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) const { return m_ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) const { return m_ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) const { return m_ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo); }
#endif
    VkResult InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) const { return m_InitializePerformanceApiINTEL(device, pInitializeInfo); }
    VkResult InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return m_InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    VkResult LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) const { return m_LatencySleepNV(device, swapchain, pSleepInfo); }
    VkResult MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) const { return m_MapMemory(device, memory, offset, size, flags, ppData); }
    VkResult MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) const { return m_MapMemory2KHR(device, pMemoryMapInfo, ppData); }
    VkResult MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) const { return m_MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches); }
    VkResult MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) const { return m_MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches); }
    void QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { m_QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo); }
    VkResult QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) const { return m_QueueBindSparse(queue, bindInfoCount, pBindInfo, fence); }
    void QueueEndDebugUtilsLabelEXT(VkQueue queue) const { m_QueueEndDebugUtilsLabelEXT(queue); }
    void QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { m_QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo); }
    void QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) const { m_QueueNotifyOutOfBandNV(queue, pQueueTypeInfo); }
    VkResult QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) const { return m_QueuePresentKHR(queue, pPresentInfo); }
    VkResult QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) const { return m_QueueSetPerformanceConfigurationINTEL(queue, configuration); }
    VkResult QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) const { return m_QueueSubmit(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return m_QueueSubmit2(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return m_QueueSubmit2KHR(queue, submitCount, pSubmits, fence); }
    VkResult QueueWaitIdle(VkQueue queue) const { return m_QueueWaitIdle(queue); }
    VkResult RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return m_RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence); }
    VkResult RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return m_RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence); }
    VkResult ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) const { return m_ReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator); }
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pPhysicalDeviceDispatch->ReleaseDisplayEXT(physicalDevice, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return m_ReleaseFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) const { return m_ReleasePerformanceConfigurationINTEL(device, configuration); }
    void ReleaseProfilingLockKHR(VkDevice device) const { m_ReleaseProfilingLockKHR(device); }
    VkResult ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return m_ReleaseSwapchainImagesEXT(device, pReleaseInfo); }
    VkResult ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return m_ReleaseSwapchainImagesKHR(device, pReleaseInfo); }
    VkResult ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) const { return m_ResetCommandBuffer(commandBuffer, flags); }
    VkResult ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) const { return m_ResetCommandPool(device, commandPool, flags); }
    VkResult ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) const { return m_ResetDescriptorPool(device, descriptorPool, flags); }
    VkResult ResetEvent(VkDevice device, VkEvent event) const { return m_ResetEvent(device, event); }
    VkResult ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) const { return m_ResetFences(device, fenceCount, pFences); }
    void ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { m_ResetQueryPool(device, queryPool, firstQuery, queryCount); }
    void ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { m_ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) const { return m_SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) const { return m_SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo); }
#endif
    VkResult SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) const { return m_SetDebugUtilsObjectNameEXT(device, pNameInfo); }
    VkResult SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) const { return m_SetDebugUtilsObjectTagEXT(device, pTagInfo); }
    void SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) const { m_SetDeviceMemoryPriorityEXT(device, memory, priority); }
    VkResult SetEvent(VkDevice device, VkEvent event) const { return m_SetEvent(device, event); }
    void SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) const { m_SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata); }
    void SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { m_SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo); }
    VkResult SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) const { return m_SetLatencySleepModeNV(device, swapchain, pSleepModeInfo); }
    void SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) const { m_SetLocalDimmingAMD(device, swapChain, localDimmingEnable); }
    VkResult SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return m_SetPrivateData(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return m_SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return m_SignalSemaphore(device, pSignalInfo); }
    VkResult SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return m_SignalSemaphoreKHR(device, pSignalInfo); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { pPhysicalDeviceDispatch->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
    VkResult TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) const { return m_TransitionImageLayoutEXT(device, transitionCount, pTransitions); }
    void TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { m_TrimCommandPool(device, commandPool, flags); }
    void TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { m_TrimCommandPoolKHR(device, commandPool, flags); }
    void UninitializePerformanceApiINTEL(VkDevice device) const { m_UninitializePerformanceApiINTEL(device); }
    void UnmapMemory(VkDevice device, VkDeviceMemory memory) const { m_UnmapMemory(device, memory); }
    VkResult UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) const { return m_UnmapMemory2KHR(device, pMemoryUnmapInfo); }
    void UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { m_UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { m_UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) const { m_UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies); }
    void UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) const { m_UpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    void UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) const { m_UpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    VkResult UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) const { return m_UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo); }
    VkResult WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) const { return m_WaitForFences(device, fenceCount, pFences, waitAll, timeout); }
    VkResult WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) const { return m_WaitForPresent2KHR(device, swapchain, pPresentWait2Info); }
    VkResult WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) const { return m_WaitForPresentKHR(device, swapchain, presentId, timeout); }
    VkResult WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return m_WaitSemaphores(device, pWaitInfo, timeout); }
    VkResult WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return m_WaitSemaphoresKHR(device, pWaitInfo, timeout); }
    VkResult WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return m_WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride); }
    VkResult WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return m_WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride); }
  public:
    VkDevice Device;
    VkPhysicalDevice PhysicalDevice;
    const VkPhysicalDeviceDispatch* pPhysicalDeviceDispatch;
    std::vector<VkDeviceQueueCreateInfo> DeviceQueueInfos;
  private:
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkAcquireFullScreenExclusiveModeEXT m_AcquireFullScreenExclusiveModeEXT;
#endif
    PFN_vkAcquireNextImage2KHR m_AcquireNextImage2KHR;
    PFN_vkAcquireNextImageKHR m_AcquireNextImageKHR;
    PFN_vkAcquirePerformanceConfigurationINTEL m_AcquirePerformanceConfigurationINTEL;
    PFN_vkAcquireProfilingLockKHR m_AcquireProfilingLockKHR;
    PFN_vkAllocateCommandBuffers m_AllocateCommandBuffers;
    PFN_vkAllocateDescriptorSets m_AllocateDescriptorSets;
    PFN_vkAllocateMemory m_AllocateMemory;
    PFN_vkAntiLagUpdateAMD m_AntiLagUpdateAMD;
    PFN_vkBeginCommandBuffer m_BeginCommandBuffer;
    PFN_vkBindAccelerationStructureMemoryNV m_BindAccelerationStructureMemoryNV;
    PFN_vkBindBufferMemory m_BindBufferMemory;
    PFN_vkBindBufferMemory2 m_BindBufferMemory2;
    PFN_vkBindBufferMemory2KHR m_BindBufferMemory2KHR;
    PFN_vkBindDataGraphPipelineSessionMemoryARM m_BindDataGraphPipelineSessionMemoryARM;
    PFN_vkBindImageMemory m_BindImageMemory;
    PFN_vkBindImageMemory2 m_BindImageMemory2;
    PFN_vkBindImageMemory2KHR m_BindImageMemory2KHR;
    PFN_vkBindOpticalFlowSessionImageNV m_BindOpticalFlowSessionImageNV;
    PFN_vkBindTensorMemoryARM m_BindTensorMemoryARM;
    PFN_vkBindVideoSessionMemoryKHR m_BindVideoSessionMemoryKHR;
    PFN_vkBuildAccelerationStructuresKHR m_BuildAccelerationStructuresKHR;
    PFN_vkBuildMicromapsEXT m_BuildMicromapsEXT;
    PFN_vkCmdBeginConditionalRenderingEXT m_CmdBeginConditionalRenderingEXT;
    PFN_vkCmdBeginDebugUtilsLabelEXT m_CmdBeginDebugUtilsLabelEXT;
    PFN_vkCmdBeginPerTileExecutionQCOM m_CmdBeginPerTileExecutionQCOM;
    PFN_vkCmdBeginQuery m_CmdBeginQuery;
    PFN_vkCmdBeginQueryIndexedEXT m_CmdBeginQueryIndexedEXT;
    PFN_vkCmdBeginRenderPass m_CmdBeginRenderPass;
    PFN_vkCmdBeginRenderPass2 m_CmdBeginRenderPass2;
    PFN_vkCmdBeginRenderPass2KHR m_CmdBeginRenderPass2KHR;
    PFN_vkCmdBeginRendering m_CmdBeginRendering;
    PFN_vkCmdBeginRenderingKHR m_CmdBeginRenderingKHR;
    PFN_vkCmdBeginTransformFeedbackEXT m_CmdBeginTransformFeedbackEXT;
    PFN_vkCmdBeginVideoCodingKHR m_CmdBeginVideoCodingKHR;
    PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT m_CmdBindDescriptorBufferEmbeddedSamplers2EXT;
    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT m_CmdBindDescriptorBufferEmbeddedSamplersEXT;
    PFN_vkCmdBindDescriptorBuffersEXT m_CmdBindDescriptorBuffersEXT;
    PFN_vkCmdBindDescriptorSets m_CmdBindDescriptorSets;
    PFN_vkCmdBindDescriptorSets2KHR m_CmdBindDescriptorSets2KHR;
    PFN_vkCmdBindIndexBuffer m_CmdBindIndexBuffer;
    PFN_vkCmdBindIndexBuffer2KHR m_CmdBindIndexBuffer2KHR;
    PFN_vkCmdBindInvocationMaskHUAWEI m_CmdBindInvocationMaskHUAWEI;
    PFN_vkCmdBindPipeline m_CmdBindPipeline;
    PFN_vkCmdBindPipelineShaderGroupNV m_CmdBindPipelineShaderGroupNV;
    PFN_vkCmdBindShadersEXT m_CmdBindShadersEXT;
    PFN_vkCmdBindShadingRateImageNV m_CmdBindShadingRateImageNV;
    PFN_vkCmdBindTileMemoryQCOM m_CmdBindTileMemoryQCOM;
    PFN_vkCmdBindTransformFeedbackBuffersEXT m_CmdBindTransformFeedbackBuffersEXT;
    PFN_vkCmdBindVertexBuffers m_CmdBindVertexBuffers;
    PFN_vkCmdBindVertexBuffers2 m_CmdBindVertexBuffers2;
    PFN_vkCmdBindVertexBuffers2EXT m_CmdBindVertexBuffers2EXT;
    PFN_vkCmdBlitImage m_CmdBlitImage;
    PFN_vkCmdBlitImage2 m_CmdBlitImage2;
    PFN_vkCmdBlitImage2KHR m_CmdBlitImage2KHR;
    PFN_vkCmdBuildAccelerationStructureNV m_CmdBuildAccelerationStructureNV;
    PFN_vkCmdBuildAccelerationStructuresIndirectKHR m_CmdBuildAccelerationStructuresIndirectKHR;
    PFN_vkCmdBuildAccelerationStructuresKHR m_CmdBuildAccelerationStructuresKHR;
    PFN_vkCmdBuildClusterAccelerationStructureIndirectNV m_CmdBuildClusterAccelerationStructureIndirectNV;
    PFN_vkCmdBuildMicromapsEXT m_CmdBuildMicromapsEXT;
    PFN_vkCmdBuildPartitionedAccelerationStructuresNV m_CmdBuildPartitionedAccelerationStructuresNV;
    PFN_vkCmdClearAttachments m_CmdClearAttachments;
    PFN_vkCmdClearColorImage m_CmdClearColorImage;
    PFN_vkCmdClearDepthStencilImage m_CmdClearDepthStencilImage;
    PFN_vkCmdControlVideoCodingKHR m_CmdControlVideoCodingKHR;
    PFN_vkCmdConvertCooperativeVectorMatrixNV m_CmdConvertCooperativeVectorMatrixNV;
    PFN_vkCmdCopyAccelerationStructureKHR m_CmdCopyAccelerationStructureKHR;
    PFN_vkCmdCopyAccelerationStructureNV m_CmdCopyAccelerationStructureNV;
    PFN_vkCmdCopyAccelerationStructureToMemoryKHR m_CmdCopyAccelerationStructureToMemoryKHR;
    PFN_vkCmdCopyBuffer m_CmdCopyBuffer;
    PFN_vkCmdCopyBuffer2 m_CmdCopyBuffer2;
    PFN_vkCmdCopyBuffer2KHR m_CmdCopyBuffer2KHR;
    PFN_vkCmdCopyBufferToImage m_CmdCopyBufferToImage;
    PFN_vkCmdCopyBufferToImage2 m_CmdCopyBufferToImage2;
    PFN_vkCmdCopyBufferToImage2KHR m_CmdCopyBufferToImage2KHR;
    PFN_vkCmdCopyImage m_CmdCopyImage;
    PFN_vkCmdCopyImage2 m_CmdCopyImage2;
    PFN_vkCmdCopyImage2KHR m_CmdCopyImage2KHR;
    PFN_vkCmdCopyImageToBuffer m_CmdCopyImageToBuffer;
    PFN_vkCmdCopyImageToBuffer2 m_CmdCopyImageToBuffer2;
    PFN_vkCmdCopyImageToBuffer2KHR m_CmdCopyImageToBuffer2KHR;
    PFN_vkCmdCopyMemoryIndirectNV m_CmdCopyMemoryIndirectNV;
    PFN_vkCmdCopyMemoryToAccelerationStructureKHR m_CmdCopyMemoryToAccelerationStructureKHR;
    PFN_vkCmdCopyMemoryToImageIndirectNV m_CmdCopyMemoryToImageIndirectNV;
    PFN_vkCmdCopyMemoryToMicromapEXT m_CmdCopyMemoryToMicromapEXT;
    PFN_vkCmdCopyMicromapEXT m_CmdCopyMicromapEXT;
    PFN_vkCmdCopyMicromapToMemoryEXT m_CmdCopyMicromapToMemoryEXT;
    PFN_vkCmdCopyQueryPoolResults m_CmdCopyQueryPoolResults;
    PFN_vkCmdCopyTensorARM m_CmdCopyTensorARM;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdCudaLaunchKernelNV m_CmdCudaLaunchKernelNV;
#endif
    PFN_vkCmdDebugMarkerBeginEXT m_CmdDebugMarkerBeginEXT;
    PFN_vkCmdDebugMarkerEndEXT m_CmdDebugMarkerEndEXT;
    PFN_vkCmdDebugMarkerInsertEXT m_CmdDebugMarkerInsertEXT;
    PFN_vkCmdDecodeVideoKHR m_CmdDecodeVideoKHR;
    PFN_vkCmdDecompressMemoryIndirectCountNV m_CmdDecompressMemoryIndirectCountNV;
    PFN_vkCmdDecompressMemoryNV m_CmdDecompressMemoryNV;
    PFN_vkCmdDispatch m_CmdDispatch;
    PFN_vkCmdDispatchBase m_CmdDispatchBase;
    PFN_vkCmdDispatchBaseKHR m_CmdDispatchBaseKHR;
    PFN_vkCmdDispatchDataGraphARM m_CmdDispatchDataGraphARM;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphAMDX m_CmdDispatchGraphAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphIndirectAMDX m_CmdDispatchGraphIndirectAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphIndirectCountAMDX m_CmdDispatchGraphIndirectCountAMDX;
#endif
    PFN_vkCmdDispatchIndirect m_CmdDispatchIndirect;
    PFN_vkCmdDispatchTileQCOM m_CmdDispatchTileQCOM;
    PFN_vkCmdDraw m_CmdDraw;
    PFN_vkCmdDrawClusterHUAWEI m_CmdDrawClusterHUAWEI;
    PFN_vkCmdDrawClusterIndirectHUAWEI m_CmdDrawClusterIndirectHUAWEI;
    PFN_vkCmdDrawIndexed m_CmdDrawIndexed;
    PFN_vkCmdDrawIndexedIndirect m_CmdDrawIndexedIndirect;
    PFN_vkCmdDrawIndexedIndirectCount m_CmdDrawIndexedIndirectCount;
    PFN_vkCmdDrawIndexedIndirectCountAMD m_CmdDrawIndexedIndirectCountAMD;
    PFN_vkCmdDrawIndexedIndirectCountKHR m_CmdDrawIndexedIndirectCountKHR;
    PFN_vkCmdDrawIndirect m_CmdDrawIndirect;
    PFN_vkCmdDrawIndirectByteCountEXT m_CmdDrawIndirectByteCountEXT;
    PFN_vkCmdDrawIndirectCount m_CmdDrawIndirectCount;
    PFN_vkCmdDrawIndirectCountAMD m_CmdDrawIndirectCountAMD;
    PFN_vkCmdDrawIndirectCountKHR m_CmdDrawIndirectCountKHR;
    PFN_vkCmdDrawMeshTasksEXT m_CmdDrawMeshTasksEXT;
    PFN_vkCmdDrawMeshTasksIndirectCountEXT m_CmdDrawMeshTasksIndirectCountEXT;
    PFN_vkCmdDrawMeshTasksIndirectCountNV m_CmdDrawMeshTasksIndirectCountNV;
    PFN_vkCmdDrawMeshTasksIndirectEXT m_CmdDrawMeshTasksIndirectEXT;
    PFN_vkCmdDrawMeshTasksIndirectNV m_CmdDrawMeshTasksIndirectNV;
    PFN_vkCmdDrawMeshTasksNV m_CmdDrawMeshTasksNV;
    PFN_vkCmdDrawMultiEXT m_CmdDrawMultiEXT;
    PFN_vkCmdDrawMultiIndexedEXT m_CmdDrawMultiIndexedEXT;
    PFN_vkCmdEncodeVideoKHR m_CmdEncodeVideoKHR;
    PFN_vkCmdEndConditionalRenderingEXT m_CmdEndConditionalRenderingEXT;
    PFN_vkCmdEndDebugUtilsLabelEXT m_CmdEndDebugUtilsLabelEXT;
    PFN_vkCmdEndPerTileExecutionQCOM m_CmdEndPerTileExecutionQCOM;
    PFN_vkCmdEndQuery m_CmdEndQuery;
    PFN_vkCmdEndQueryIndexedEXT m_CmdEndQueryIndexedEXT;
    PFN_vkCmdEndRenderPass m_CmdEndRenderPass;
    PFN_vkCmdEndRenderPass2 m_CmdEndRenderPass2;
    PFN_vkCmdEndRenderPass2KHR m_CmdEndRenderPass2KHR;
    PFN_vkCmdEndRendering m_CmdEndRendering;
    PFN_vkCmdEndRendering2EXT m_CmdEndRendering2EXT;
    PFN_vkCmdEndRenderingKHR m_CmdEndRenderingKHR;
    PFN_vkCmdEndTransformFeedbackEXT m_CmdEndTransformFeedbackEXT;
    PFN_vkCmdEndVideoCodingKHR m_CmdEndVideoCodingKHR;
    PFN_vkCmdExecuteCommands m_CmdExecuteCommands;
    PFN_vkCmdExecuteGeneratedCommandsEXT m_CmdExecuteGeneratedCommandsEXT;
    PFN_vkCmdExecuteGeneratedCommandsNV m_CmdExecuteGeneratedCommandsNV;
    PFN_vkCmdFillBuffer m_CmdFillBuffer;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdInitializeGraphScratchMemoryAMDX m_CmdInitializeGraphScratchMemoryAMDX;
#endif
    PFN_vkCmdInsertDebugUtilsLabelEXT m_CmdInsertDebugUtilsLabelEXT;
    PFN_vkCmdNextSubpass m_CmdNextSubpass;
    PFN_vkCmdNextSubpass2 m_CmdNextSubpass2;
    PFN_vkCmdNextSubpass2KHR m_CmdNextSubpass2KHR;
    PFN_vkCmdOpticalFlowExecuteNV m_CmdOpticalFlowExecuteNV;
    PFN_vkCmdPipelineBarrier m_CmdPipelineBarrier;
    PFN_vkCmdPipelineBarrier2 m_CmdPipelineBarrier2;
    PFN_vkCmdPipelineBarrier2KHR m_CmdPipelineBarrier2KHR;
    PFN_vkCmdPreprocessGeneratedCommandsEXT m_CmdPreprocessGeneratedCommandsEXT;
    PFN_vkCmdPreprocessGeneratedCommandsNV m_CmdPreprocessGeneratedCommandsNV;
    PFN_vkCmdPushConstants m_CmdPushConstants;
    PFN_vkCmdPushConstants2KHR m_CmdPushConstants2KHR;
    PFN_vkCmdPushDescriptorSet2KHR m_CmdPushDescriptorSet2KHR;
    PFN_vkCmdPushDescriptorSetKHR m_CmdPushDescriptorSetKHR;
    PFN_vkCmdPushDescriptorSetWithTemplate2KHR m_CmdPushDescriptorSetWithTemplate2KHR;
    PFN_vkCmdPushDescriptorSetWithTemplateKHR m_CmdPushDescriptorSetWithTemplateKHR;
    PFN_vkCmdResetEvent m_CmdResetEvent;
    PFN_vkCmdResetEvent2 m_CmdResetEvent2;
    PFN_vkCmdResetEvent2KHR m_CmdResetEvent2KHR;
    PFN_vkCmdResetQueryPool m_CmdResetQueryPool;
    PFN_vkCmdResolveImage m_CmdResolveImage;
    PFN_vkCmdResolveImage2 m_CmdResolveImage2;
    PFN_vkCmdResolveImage2KHR m_CmdResolveImage2KHR;
    PFN_vkCmdSetAlphaToCoverageEnableEXT m_CmdSetAlphaToCoverageEnableEXT;
    PFN_vkCmdSetAlphaToOneEnableEXT m_CmdSetAlphaToOneEnableEXT;
    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT m_CmdSetAttachmentFeedbackLoopEnableEXT;
    PFN_vkCmdSetBlendConstants m_CmdSetBlendConstants;
    PFN_vkCmdSetCheckpointNV m_CmdSetCheckpointNV;
    PFN_vkCmdSetCoarseSampleOrderNV m_CmdSetCoarseSampleOrderNV;
    PFN_vkCmdSetColorBlendAdvancedEXT m_CmdSetColorBlendAdvancedEXT;
    PFN_vkCmdSetColorBlendEnableEXT m_CmdSetColorBlendEnableEXT;
    PFN_vkCmdSetColorBlendEquationEXT m_CmdSetColorBlendEquationEXT;
    PFN_vkCmdSetColorWriteEnableEXT m_CmdSetColorWriteEnableEXT;
    PFN_vkCmdSetColorWriteMaskEXT m_CmdSetColorWriteMaskEXT;
    PFN_vkCmdSetConservativeRasterizationModeEXT m_CmdSetConservativeRasterizationModeEXT;
    PFN_vkCmdSetCoverageModulationModeNV m_CmdSetCoverageModulationModeNV;
    PFN_vkCmdSetCoverageModulationTableEnableNV m_CmdSetCoverageModulationTableEnableNV;
    PFN_vkCmdSetCoverageModulationTableNV m_CmdSetCoverageModulationTableNV;
    PFN_vkCmdSetCoverageReductionModeNV m_CmdSetCoverageReductionModeNV;
    PFN_vkCmdSetCoverageToColorEnableNV m_CmdSetCoverageToColorEnableNV;
    PFN_vkCmdSetCoverageToColorLocationNV m_CmdSetCoverageToColorLocationNV;
    PFN_vkCmdSetCullMode m_CmdSetCullMode;
    PFN_vkCmdSetCullModeEXT m_CmdSetCullModeEXT;
    PFN_vkCmdSetDepthBias m_CmdSetDepthBias;
    PFN_vkCmdSetDepthBias2EXT m_CmdSetDepthBias2EXT;
    PFN_vkCmdSetDepthBiasEnable m_CmdSetDepthBiasEnable;
    PFN_vkCmdSetDepthBiasEnableEXT m_CmdSetDepthBiasEnableEXT;
    PFN_vkCmdSetDepthBounds m_CmdSetDepthBounds;
    PFN_vkCmdSetDepthBoundsTestEnable m_CmdSetDepthBoundsTestEnable;
    PFN_vkCmdSetDepthBoundsTestEnableEXT m_CmdSetDepthBoundsTestEnableEXT;
    PFN_vkCmdSetDepthClampEnableEXT m_CmdSetDepthClampEnableEXT;
    PFN_vkCmdSetDepthClampRangeEXT m_CmdSetDepthClampRangeEXT;
    PFN_vkCmdSetDepthClipEnableEXT m_CmdSetDepthClipEnableEXT;
    PFN_vkCmdSetDepthClipNegativeOneToOneEXT m_CmdSetDepthClipNegativeOneToOneEXT;
    PFN_vkCmdSetDepthCompareOp m_CmdSetDepthCompareOp;
    PFN_vkCmdSetDepthCompareOpEXT m_CmdSetDepthCompareOpEXT;
    PFN_vkCmdSetDepthTestEnable m_CmdSetDepthTestEnable;
    PFN_vkCmdSetDepthTestEnableEXT m_CmdSetDepthTestEnableEXT;
    PFN_vkCmdSetDepthWriteEnable m_CmdSetDepthWriteEnable;
    PFN_vkCmdSetDepthWriteEnableEXT m_CmdSetDepthWriteEnableEXT;
    PFN_vkCmdSetDescriptorBufferOffsets2EXT m_CmdSetDescriptorBufferOffsets2EXT;
    PFN_vkCmdSetDescriptorBufferOffsetsEXT m_CmdSetDescriptorBufferOffsetsEXT;
    PFN_vkCmdSetDeviceMask m_CmdSetDeviceMask;
    PFN_vkCmdSetDeviceMaskKHR m_CmdSetDeviceMaskKHR;
    PFN_vkCmdSetDiscardRectangleEXT m_CmdSetDiscardRectangleEXT;
    PFN_vkCmdSetDiscardRectangleEnableEXT m_CmdSetDiscardRectangleEnableEXT;
    PFN_vkCmdSetDiscardRectangleModeEXT m_CmdSetDiscardRectangleModeEXT;
    PFN_vkCmdSetEvent m_CmdSetEvent;
    PFN_vkCmdSetEvent2 m_CmdSetEvent2;
    PFN_vkCmdSetEvent2KHR m_CmdSetEvent2KHR;
    PFN_vkCmdSetExclusiveScissorEnableNV m_CmdSetExclusiveScissorEnableNV;
    PFN_vkCmdSetExclusiveScissorNV m_CmdSetExclusiveScissorNV;
    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT m_CmdSetExtraPrimitiveOverestimationSizeEXT;
    PFN_vkCmdSetFragmentShadingRateEnumNV m_CmdSetFragmentShadingRateEnumNV;
    PFN_vkCmdSetFragmentShadingRateKHR m_CmdSetFragmentShadingRateKHR;
    PFN_vkCmdSetFrontFace m_CmdSetFrontFace;
    PFN_vkCmdSetFrontFaceEXT m_CmdSetFrontFaceEXT;
    PFN_vkCmdSetLineRasterizationModeEXT m_CmdSetLineRasterizationModeEXT;
    PFN_vkCmdSetLineStippleEXT m_CmdSetLineStippleEXT;
    PFN_vkCmdSetLineStippleEnableEXT m_CmdSetLineStippleEnableEXT;
    PFN_vkCmdSetLineStippleKHR m_CmdSetLineStippleKHR;
    PFN_vkCmdSetLineWidth m_CmdSetLineWidth;
    PFN_vkCmdSetLogicOpEXT m_CmdSetLogicOpEXT;
    PFN_vkCmdSetLogicOpEnableEXT m_CmdSetLogicOpEnableEXT;
    PFN_vkCmdSetPatchControlPointsEXT m_CmdSetPatchControlPointsEXT;
    PFN_vkCmdSetPerformanceMarkerINTEL m_CmdSetPerformanceMarkerINTEL;
    PFN_vkCmdSetPerformanceOverrideINTEL m_CmdSetPerformanceOverrideINTEL;
    PFN_vkCmdSetPerformanceStreamMarkerINTEL m_CmdSetPerformanceStreamMarkerINTEL;
    PFN_vkCmdSetPolygonModeEXT m_CmdSetPolygonModeEXT;
    PFN_vkCmdSetPrimitiveRestartEnable m_CmdSetPrimitiveRestartEnable;
    PFN_vkCmdSetPrimitiveRestartEnableEXT m_CmdSetPrimitiveRestartEnableEXT;
    PFN_vkCmdSetPrimitiveTopology m_CmdSetPrimitiveTopology;
    PFN_vkCmdSetPrimitiveTopologyEXT m_CmdSetPrimitiveTopologyEXT;
    PFN_vkCmdSetProvokingVertexModeEXT m_CmdSetProvokingVertexModeEXT;
    PFN_vkCmdSetRasterizationSamplesEXT m_CmdSetRasterizationSamplesEXT;
    PFN_vkCmdSetRasterizationStreamEXT m_CmdSetRasterizationStreamEXT;
    PFN_vkCmdSetRasterizerDiscardEnable m_CmdSetRasterizerDiscardEnable;
    PFN_vkCmdSetRasterizerDiscardEnableEXT m_CmdSetRasterizerDiscardEnableEXT;
    PFN_vkCmdSetRayTracingPipelineStackSizeKHR m_CmdSetRayTracingPipelineStackSizeKHR;
    PFN_vkCmdSetRenderingAttachmentLocationsKHR m_CmdSetRenderingAttachmentLocationsKHR;
    PFN_vkCmdSetRenderingInputAttachmentIndicesKHR m_CmdSetRenderingInputAttachmentIndicesKHR;
    PFN_vkCmdSetRepresentativeFragmentTestEnableNV m_CmdSetRepresentativeFragmentTestEnableNV;
    PFN_vkCmdSetSampleLocationsEXT m_CmdSetSampleLocationsEXT;
    PFN_vkCmdSetSampleLocationsEnableEXT m_CmdSetSampleLocationsEnableEXT;
    PFN_vkCmdSetSampleMaskEXT m_CmdSetSampleMaskEXT;
    PFN_vkCmdSetScissor m_CmdSetScissor;
    PFN_vkCmdSetScissorWithCount m_CmdSetScissorWithCount;
    PFN_vkCmdSetScissorWithCountEXT m_CmdSetScissorWithCountEXT;
    PFN_vkCmdSetShadingRateImageEnableNV m_CmdSetShadingRateImageEnableNV;
    PFN_vkCmdSetStencilCompareMask m_CmdSetStencilCompareMask;
    PFN_vkCmdSetStencilOp m_CmdSetStencilOp;
    PFN_vkCmdSetStencilOpEXT m_CmdSetStencilOpEXT;
    PFN_vkCmdSetStencilReference m_CmdSetStencilReference;
    PFN_vkCmdSetStencilTestEnable m_CmdSetStencilTestEnable;
    PFN_vkCmdSetStencilTestEnableEXT m_CmdSetStencilTestEnableEXT;
    PFN_vkCmdSetStencilWriteMask m_CmdSetStencilWriteMask;
    PFN_vkCmdSetTessellationDomainOriginEXT m_CmdSetTessellationDomainOriginEXT;
    PFN_vkCmdSetVertexInputEXT m_CmdSetVertexInputEXT;
    PFN_vkCmdSetViewport m_CmdSetViewport;
    PFN_vkCmdSetViewportShadingRatePaletteNV m_CmdSetViewportShadingRatePaletteNV;
    PFN_vkCmdSetViewportSwizzleNV m_CmdSetViewportSwizzleNV;
    PFN_vkCmdSetViewportWScalingEnableNV m_CmdSetViewportWScalingEnableNV;
    PFN_vkCmdSetViewportWScalingNV m_CmdSetViewportWScalingNV;
    PFN_vkCmdSetViewportWithCount m_CmdSetViewportWithCount;
    PFN_vkCmdSetViewportWithCountEXT m_CmdSetViewportWithCountEXT;
    PFN_vkCmdSubpassShadingHUAWEI m_CmdSubpassShadingHUAWEI;
    PFN_vkCmdTraceRaysIndirect2KHR m_CmdTraceRaysIndirect2KHR;
    PFN_vkCmdTraceRaysIndirectKHR m_CmdTraceRaysIndirectKHR;
    PFN_vkCmdTraceRaysKHR m_CmdTraceRaysKHR;
    PFN_vkCmdTraceRaysNV m_CmdTraceRaysNV;
    PFN_vkCmdUpdateBuffer m_CmdUpdateBuffer;
    PFN_vkCmdUpdatePipelineIndirectBufferNV m_CmdUpdatePipelineIndirectBufferNV;
    PFN_vkCmdWaitEvents m_CmdWaitEvents;
    PFN_vkCmdWaitEvents2 m_CmdWaitEvents2;
    PFN_vkCmdWaitEvents2KHR m_CmdWaitEvents2KHR;
    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR m_CmdWriteAccelerationStructuresPropertiesKHR;
    PFN_vkCmdWriteAccelerationStructuresPropertiesNV m_CmdWriteAccelerationStructuresPropertiesNV;
    PFN_vkCmdWriteBufferMarker2AMD m_CmdWriteBufferMarker2AMD;
    PFN_vkCmdWriteBufferMarkerAMD m_CmdWriteBufferMarkerAMD;
    PFN_vkCmdWriteMicromapsPropertiesEXT m_CmdWriteMicromapsPropertiesEXT;
    PFN_vkCmdWriteTimestamp m_CmdWriteTimestamp;
    PFN_vkCmdWriteTimestamp2 m_CmdWriteTimestamp2;
    PFN_vkCmdWriteTimestamp2KHR m_CmdWriteTimestamp2KHR;
    PFN_vkCompileDeferredNV m_CompileDeferredNV;
    PFN_vkConvertCooperativeVectorMatrixNV m_ConvertCooperativeVectorMatrixNV;
    PFN_vkCopyAccelerationStructureKHR m_CopyAccelerationStructureKHR;
    PFN_vkCopyAccelerationStructureToMemoryKHR m_CopyAccelerationStructureToMemoryKHR;
    PFN_vkCopyImageToImageEXT m_CopyImageToImageEXT;
    PFN_vkCopyImageToMemoryEXT m_CopyImageToMemoryEXT;
    PFN_vkCopyMemoryToAccelerationStructureKHR m_CopyMemoryToAccelerationStructureKHR;
    PFN_vkCopyMemoryToImageEXT m_CopyMemoryToImageEXT;
    PFN_vkCopyMemoryToMicromapEXT m_CopyMemoryToMicromapEXT;
    PFN_vkCopyMicromapEXT m_CopyMicromapEXT;
    PFN_vkCopyMicromapToMemoryEXT m_CopyMicromapToMemoryEXT;
    PFN_vkCreateAccelerationStructureKHR m_CreateAccelerationStructureKHR;
    PFN_vkCreateAccelerationStructureNV m_CreateAccelerationStructureNV;
    PFN_vkCreateBuffer m_CreateBuffer;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkCreateBufferCollectionFUCHSIA m_CreateBufferCollectionFUCHSIA;
#endif
    PFN_vkCreateBufferView m_CreateBufferView;
    PFN_vkCreateCommandPool m_CreateCommandPool;
    PFN_vkCreateComputePipelines m_CreateComputePipelines;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateCudaFunctionNV m_CreateCudaFunctionNV;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateCudaModuleNV m_CreateCudaModuleNV;
#endif
    PFN_vkCreateDataGraphPipelineSessionARM m_CreateDataGraphPipelineSessionARM;
    PFN_vkCreateDataGraphPipelinesARM m_CreateDataGraphPipelinesARM;
    PFN_vkCreateDeferredOperationKHR m_CreateDeferredOperationKHR;
    PFN_vkCreateDescriptorPool m_CreateDescriptorPool;
    PFN_vkCreateDescriptorSetLayout m_CreateDescriptorSetLayout;
    PFN_vkCreateDescriptorUpdateTemplate m_CreateDescriptorUpdateTemplate;
    PFN_vkCreateDescriptorUpdateTemplateKHR m_CreateDescriptorUpdateTemplateKHR;
    PFN_vkCreateEvent m_CreateEvent;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateExecutionGraphPipelinesAMDX m_CreateExecutionGraphPipelinesAMDX;
#endif
    PFN_vkCreateExternalComputeQueueNV m_CreateExternalComputeQueueNV;
    PFN_vkCreateFence m_CreateFence;
    PFN_vkCreateFramebuffer m_CreateFramebuffer;
    PFN_vkCreateGraphicsPipelines m_CreateGraphicsPipelines;
    PFN_vkCreateImage m_CreateImage;
    PFN_vkCreateImageView m_CreateImageView;
    PFN_vkCreateIndirectCommandsLayoutEXT m_CreateIndirectCommandsLayoutEXT;
    PFN_vkCreateIndirectCommandsLayoutNV m_CreateIndirectCommandsLayoutNV;
    PFN_vkCreateIndirectExecutionSetEXT m_CreateIndirectExecutionSetEXT;
    PFN_vkCreateMicromapEXT m_CreateMicromapEXT;
    PFN_vkCreateOpticalFlowSessionNV m_CreateOpticalFlowSessionNV;
    PFN_vkCreatePipelineBinariesKHR m_CreatePipelineBinariesKHR;
    PFN_vkCreatePipelineCache m_CreatePipelineCache;
    PFN_vkCreatePipelineLayout m_CreatePipelineLayout;
    PFN_vkCreatePrivateDataSlot m_CreatePrivateDataSlot;
    PFN_vkCreatePrivateDataSlotEXT m_CreatePrivateDataSlotEXT;
    PFN_vkCreateQueryPool m_CreateQueryPool;
    PFN_vkCreateRayTracingPipelinesKHR m_CreateRayTracingPipelinesKHR;
    PFN_vkCreateRayTracingPipelinesNV m_CreateRayTracingPipelinesNV;
    PFN_vkCreateRenderPass m_CreateRenderPass;
    PFN_vkCreateRenderPass2 m_CreateRenderPass2;
    PFN_vkCreateRenderPass2KHR m_CreateRenderPass2KHR;
    PFN_vkCreateSampler m_CreateSampler;
    PFN_vkCreateSamplerYcbcrConversion m_CreateSamplerYcbcrConversion;
    PFN_vkCreateSamplerYcbcrConversionKHR m_CreateSamplerYcbcrConversionKHR;
    PFN_vkCreateSemaphore m_CreateSemaphore;
    PFN_vkCreateShaderModule m_CreateShaderModule;
    PFN_vkCreateShadersEXT m_CreateShadersEXT;
    PFN_vkCreateSharedSwapchainsKHR m_CreateSharedSwapchainsKHR;
    PFN_vkCreateSwapchainKHR m_CreateSwapchainKHR;
    PFN_vkCreateTensorARM m_CreateTensorARM;
    PFN_vkCreateTensorViewARM m_CreateTensorViewARM;
    PFN_vkCreateValidationCacheEXT m_CreateValidationCacheEXT;
    PFN_vkCreateVideoSessionKHR m_CreateVideoSessionKHR;
    PFN_vkCreateVideoSessionParametersKHR m_CreateVideoSessionParametersKHR;
    PFN_vkDebugMarkerSetObjectNameEXT m_DebugMarkerSetObjectNameEXT;
    PFN_vkDebugMarkerSetObjectTagEXT m_DebugMarkerSetObjectTagEXT;
    PFN_vkDeferredOperationJoinKHR m_DeferredOperationJoinKHR;
    PFN_vkDestroyAccelerationStructureKHR m_DestroyAccelerationStructureKHR;
    PFN_vkDestroyAccelerationStructureNV m_DestroyAccelerationStructureNV;
    PFN_vkDestroyBuffer m_DestroyBuffer;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkDestroyBufferCollectionFUCHSIA m_DestroyBufferCollectionFUCHSIA;
#endif
    PFN_vkDestroyBufferView m_DestroyBufferView;
    PFN_vkDestroyCommandPool m_DestroyCommandPool;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkDestroyCudaFunctionNV m_DestroyCudaFunctionNV;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkDestroyCudaModuleNV m_DestroyCudaModuleNV;
#endif
    PFN_vkDestroyDataGraphPipelineSessionARM m_DestroyDataGraphPipelineSessionARM;
    PFN_vkDestroyDeferredOperationKHR m_DestroyDeferredOperationKHR;
    PFN_vkDestroyDescriptorPool m_DestroyDescriptorPool;
    PFN_vkDestroyDescriptorSetLayout m_DestroyDescriptorSetLayout;
    PFN_vkDestroyDescriptorUpdateTemplate m_DestroyDescriptorUpdateTemplate;
    PFN_vkDestroyDescriptorUpdateTemplateKHR m_DestroyDescriptorUpdateTemplateKHR;
    PFN_vkDestroyDevice m_DestroyDevice;
    PFN_vkDestroyEvent m_DestroyEvent;
    PFN_vkDestroyExternalComputeQueueNV m_DestroyExternalComputeQueueNV;
    PFN_vkDestroyFence m_DestroyFence;
    PFN_vkDestroyFramebuffer m_DestroyFramebuffer;
    PFN_vkDestroyImage m_DestroyImage;
    PFN_vkDestroyImageView m_DestroyImageView;
    PFN_vkDestroyIndirectCommandsLayoutEXT m_DestroyIndirectCommandsLayoutEXT;
    PFN_vkDestroyIndirectCommandsLayoutNV m_DestroyIndirectCommandsLayoutNV;
    PFN_vkDestroyIndirectExecutionSetEXT m_DestroyIndirectExecutionSetEXT;
    PFN_vkDestroyMicromapEXT m_DestroyMicromapEXT;
    PFN_vkDestroyOpticalFlowSessionNV m_DestroyOpticalFlowSessionNV;
    PFN_vkDestroyPipeline m_DestroyPipeline;
    PFN_vkDestroyPipelineBinaryKHR m_DestroyPipelineBinaryKHR;
    PFN_vkDestroyPipelineCache m_DestroyPipelineCache;
    PFN_vkDestroyPipelineLayout m_DestroyPipelineLayout;
    PFN_vkDestroyPrivateDataSlot m_DestroyPrivateDataSlot;
    PFN_vkDestroyPrivateDataSlotEXT m_DestroyPrivateDataSlotEXT;
    PFN_vkDestroyQueryPool m_DestroyQueryPool;
    PFN_vkDestroyRenderPass m_DestroyRenderPass;
    PFN_vkDestroySampler m_DestroySampler;
    PFN_vkDestroySamplerYcbcrConversion m_DestroySamplerYcbcrConversion;
    PFN_vkDestroySamplerYcbcrConversionKHR m_DestroySamplerYcbcrConversionKHR;
    PFN_vkDestroySemaphore m_DestroySemaphore;
    PFN_vkDestroyShaderEXT m_DestroyShaderEXT;
    PFN_vkDestroyShaderModule m_DestroyShaderModule;
    PFN_vkDestroySwapchainKHR m_DestroySwapchainKHR;
    PFN_vkDestroyTensorARM m_DestroyTensorARM;
    PFN_vkDestroyTensorViewARM m_DestroyTensorViewARM;
    PFN_vkDestroyValidationCacheEXT m_DestroyValidationCacheEXT;
    PFN_vkDestroyVideoSessionKHR m_DestroyVideoSessionKHR;
    PFN_vkDestroyVideoSessionParametersKHR m_DestroyVideoSessionParametersKHR;
    PFN_vkDeviceWaitIdle m_DeviceWaitIdle;
    PFN_vkDisplayPowerControlEXT m_DisplayPowerControlEXT;
    PFN_vkEndCommandBuffer m_EndCommandBuffer;
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkExportMetalObjectsEXT m_ExportMetalObjectsEXT;
#endif
    PFN_vkFlushMappedMemoryRanges m_FlushMappedMemoryRanges;
    PFN_vkFreeCommandBuffers m_FreeCommandBuffers;
    PFN_vkFreeDescriptorSets m_FreeDescriptorSets;
    PFN_vkFreeMemory m_FreeMemory;
    PFN_vkGetAccelerationStructureBuildSizesKHR m_GetAccelerationStructureBuildSizesKHR;
    PFN_vkGetAccelerationStructureDeviceAddressKHR m_GetAccelerationStructureDeviceAddressKHR;
    PFN_vkGetAccelerationStructureHandleNV m_GetAccelerationStructureHandleNV;
    PFN_vkGetAccelerationStructureMemoryRequirementsNV m_GetAccelerationStructureMemoryRequirementsNV;
    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT m_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkGetAndroidHardwareBufferPropertiesANDROID m_GetAndroidHardwareBufferPropertiesANDROID;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetBufferCollectionPropertiesFUCHSIA m_GetBufferCollectionPropertiesFUCHSIA;
#endif
    PFN_vkGetBufferDeviceAddress m_GetBufferDeviceAddress;
    PFN_vkGetBufferDeviceAddressEXT m_GetBufferDeviceAddressEXT;
    PFN_vkGetBufferDeviceAddressKHR m_GetBufferDeviceAddressKHR;
    PFN_vkGetBufferMemoryRequirements m_GetBufferMemoryRequirements;
    PFN_vkGetBufferMemoryRequirements2 m_GetBufferMemoryRequirements2;
    PFN_vkGetBufferMemoryRequirements2KHR m_GetBufferMemoryRequirements2KHR;
    PFN_vkGetBufferOpaqueCaptureAddress m_GetBufferOpaqueCaptureAddress;
    PFN_vkGetBufferOpaqueCaptureAddressKHR m_GetBufferOpaqueCaptureAddressKHR;
    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT m_GetBufferOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetCalibratedTimestampsEXT m_GetCalibratedTimestampsEXT;
    PFN_vkGetCalibratedTimestampsKHR m_GetCalibratedTimestampsKHR;
    PFN_vkGetClusterAccelerationStructureBuildSizesNV m_GetClusterAccelerationStructureBuildSizesNV;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetCudaModuleCacheNV m_GetCudaModuleCacheNV;
#endif
    PFN_vkGetDataGraphPipelineAvailablePropertiesARM m_GetDataGraphPipelineAvailablePropertiesARM;
    PFN_vkGetDataGraphPipelinePropertiesARM m_GetDataGraphPipelinePropertiesARM;
    PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM m_GetDataGraphPipelineSessionBindPointRequirementsARM;
    PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM m_GetDataGraphPipelineSessionMemoryRequirementsARM;
    PFN_vkGetDeferredOperationMaxConcurrencyKHR m_GetDeferredOperationMaxConcurrencyKHR;
    PFN_vkGetDeferredOperationResultKHR m_GetDeferredOperationResultKHR;
    PFN_vkGetDescriptorEXT m_GetDescriptorEXT;
    PFN_vkGetDescriptorSetHostMappingVALVE m_GetDescriptorSetHostMappingVALVE;
    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT m_GetDescriptorSetLayoutBindingOffsetEXT;
    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE m_GetDescriptorSetLayoutHostMappingInfoVALVE;
    PFN_vkGetDescriptorSetLayoutSizeEXT m_GetDescriptorSetLayoutSizeEXT;
    PFN_vkGetDescriptorSetLayoutSupport m_GetDescriptorSetLayoutSupport;
    PFN_vkGetDescriptorSetLayoutSupportKHR m_GetDescriptorSetLayoutSupportKHR;
    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR m_GetDeviceAccelerationStructureCompatibilityKHR;
    PFN_vkGetDeviceBufferMemoryRequirements m_GetDeviceBufferMemoryRequirements;
    PFN_vkGetDeviceBufferMemoryRequirementsKHR m_GetDeviceBufferMemoryRequirementsKHR;
    PFN_vkGetDeviceFaultInfoEXT m_GetDeviceFaultInfoEXT;
    PFN_vkGetDeviceGroupPeerMemoryFeatures m_GetDeviceGroupPeerMemoryFeatures;
    PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR m_GetDeviceGroupPeerMemoryFeaturesKHR;
    PFN_vkGetDeviceGroupPresentCapabilitiesKHR m_GetDeviceGroupPresentCapabilitiesKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetDeviceGroupSurfacePresentModes2EXT m_GetDeviceGroupSurfacePresentModes2EXT;
#endif
    PFN_vkGetDeviceGroupSurfacePresentModesKHR m_GetDeviceGroupSurfacePresentModesKHR;
    PFN_vkGetDeviceImageMemoryRequirements m_GetDeviceImageMemoryRequirements;
    PFN_vkGetDeviceImageMemoryRequirementsKHR m_GetDeviceImageMemoryRequirementsKHR;
    PFN_vkGetDeviceImageSparseMemoryRequirements m_GetDeviceImageSparseMemoryRequirements;
    PFN_vkGetDeviceImageSparseMemoryRequirementsKHR m_GetDeviceImageSparseMemoryRequirementsKHR;
    PFN_vkGetDeviceImageSubresourceLayoutKHR m_GetDeviceImageSubresourceLayoutKHR;
    PFN_vkGetDeviceMemoryCommitment m_GetDeviceMemoryCommitment;
    PFN_vkGetDeviceMemoryOpaqueCaptureAddress m_GetDeviceMemoryOpaqueCaptureAddress;
    PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR m_GetDeviceMemoryOpaqueCaptureAddressKHR;
    PFN_vkGetDeviceMicromapCompatibilityEXT m_GetDeviceMicromapCompatibilityEXT;
    PFN_vkGetDeviceProcAddr m_GetDeviceProcAddr;
    PFN_vkGetDeviceQueue m_GetDeviceQueue;
    PFN_vkGetDeviceQueue2 m_GetDeviceQueue2;
    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI m_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
    PFN_vkGetDeviceTensorMemoryRequirementsARM m_GetDeviceTensorMemoryRequirementsARM;
    PFN_vkGetDynamicRenderingTilePropertiesQCOM m_GetDynamicRenderingTilePropertiesQCOM;
    PFN_vkGetEncodedVideoSessionParametersKHR m_GetEncodedVideoSessionParametersKHR;
    PFN_vkGetEventStatus m_GetEventStatus;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetExecutionGraphPipelineNodeIndexAMDX m_GetExecutionGraphPipelineNodeIndexAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetExecutionGraphPipelineScratchSizeAMDX m_GetExecutionGraphPipelineScratchSizeAMDX;
#endif
    PFN_vkGetExternalComputeQueueDataNV m_GetExternalComputeQueueDataNV;
    PFN_vkGetFenceFdKHR m_GetFenceFdKHR;
    PFN_vkGetFenceStatus m_GetFenceStatus;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetFenceWin32HandleKHR m_GetFenceWin32HandleKHR;
#endif
    PFN_vkGetFramebufferTilePropertiesQCOM m_GetFramebufferTilePropertiesQCOM;
    PFN_vkGetGeneratedCommandsMemoryRequirementsEXT m_GetGeneratedCommandsMemoryRequirementsEXT;
    PFN_vkGetGeneratedCommandsMemoryRequirementsNV m_GetGeneratedCommandsMemoryRequirementsNV;
    PFN_vkGetImageDrmFormatModifierPropertiesEXT m_GetImageDrmFormatModifierPropertiesEXT;
    PFN_vkGetImageMemoryRequirements m_GetImageMemoryRequirements;
    PFN_vkGetImageMemoryRequirements2 m_GetImageMemoryRequirements2;
    PFN_vkGetImageMemoryRequirements2KHR m_GetImageMemoryRequirements2KHR;
    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT m_GetImageOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetImageSparseMemoryRequirements m_GetImageSparseMemoryRequirements;
    PFN_vkGetImageSparseMemoryRequirements2 m_GetImageSparseMemoryRequirements2;
    PFN_vkGetImageSparseMemoryRequirements2KHR m_GetImageSparseMemoryRequirements2KHR;
    PFN_vkGetImageSubresourceLayout m_GetImageSubresourceLayout;
    PFN_vkGetImageSubresourceLayout2EXT m_GetImageSubresourceLayout2EXT;
    PFN_vkGetImageSubresourceLayout2KHR m_GetImageSubresourceLayout2KHR;
    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT m_GetImageViewOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetLatencyTimingsNV m_GetLatencyTimingsNV;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkGetMemoryAndroidHardwareBufferANDROID m_GetMemoryAndroidHardwareBufferANDROID;
#endif
    PFN_vkGetMemoryFdKHR m_GetMemoryFdKHR;
    PFN_vkGetMemoryFdPropertiesKHR m_GetMemoryFdPropertiesKHR;
    PFN_vkGetMemoryHostPointerPropertiesEXT m_GetMemoryHostPointerPropertiesEXT;
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkGetMemoryMetalHandleEXT m_GetMemoryMetalHandleEXT;
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkGetMemoryMetalHandlePropertiesEXT m_GetMemoryMetalHandlePropertiesEXT;
#endif
    PFN_vkGetMemoryRemoteAddressNV m_GetMemoryRemoteAddressNV;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandleKHR m_GetMemoryWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandleNV m_GetMemoryWin32HandleNV;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandlePropertiesKHR m_GetMemoryWin32HandlePropertiesKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetMemoryZirconHandleFUCHSIA m_GetMemoryZirconHandleFUCHSIA;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA m_GetMemoryZirconHandlePropertiesFUCHSIA;
#endif
    PFN_vkGetMicromapBuildSizesEXT m_GetMicromapBuildSizesEXT;
    PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV m_GetPartitionedAccelerationStructuresBuildSizesNV;
    PFN_vkGetPastPresentationTimingGOOGLE m_GetPastPresentationTimingGOOGLE;
    PFN_vkGetPerformanceParameterINTEL m_GetPerformanceParameterINTEL;
    PFN_vkGetPipelineBinaryDataKHR m_GetPipelineBinaryDataKHR;
    PFN_vkGetPipelineCacheData m_GetPipelineCacheData;
    PFN_vkGetPipelineExecutableInternalRepresentationsKHR m_GetPipelineExecutableInternalRepresentationsKHR;
    PFN_vkGetPipelineExecutablePropertiesKHR m_GetPipelineExecutablePropertiesKHR;
    PFN_vkGetPipelineExecutableStatisticsKHR m_GetPipelineExecutableStatisticsKHR;
    PFN_vkGetPipelineIndirectDeviceAddressNV m_GetPipelineIndirectDeviceAddressNV;
    PFN_vkGetPipelineIndirectMemoryRequirementsNV m_GetPipelineIndirectMemoryRequirementsNV;
    PFN_vkGetPipelineKeyKHR m_GetPipelineKeyKHR;
    PFN_vkGetPipelinePropertiesEXT m_GetPipelinePropertiesEXT;
    PFN_vkGetPrivateData m_GetPrivateData;
    PFN_vkGetPrivateDataEXT m_GetPrivateDataEXT;
    PFN_vkGetQueryPoolResults m_GetQueryPoolResults;
    PFN_vkGetQueueCheckpointData2NV m_GetQueueCheckpointData2NV;
    PFN_vkGetQueueCheckpointDataNV m_GetQueueCheckpointDataNV;
    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR m_GetRayTracingCaptureReplayShaderGroupHandlesKHR;
    PFN_vkGetRayTracingShaderGroupHandlesKHR m_GetRayTracingShaderGroupHandlesKHR;
    PFN_vkGetRayTracingShaderGroupHandlesNV m_GetRayTracingShaderGroupHandlesNV;
    PFN_vkGetRayTracingShaderGroupStackSizeKHR m_GetRayTracingShaderGroupStackSizeKHR;
    PFN_vkGetRefreshCycleDurationGOOGLE m_GetRefreshCycleDurationGOOGLE;
    PFN_vkGetRenderAreaGranularity m_GetRenderAreaGranularity;
    PFN_vkGetRenderingAreaGranularityKHR m_GetRenderingAreaGranularityKHR;
    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT m_GetSamplerOpaqueCaptureDescriptorDataEXT;
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkGetScreenBufferPropertiesQNX m_GetScreenBufferPropertiesQNX;
#endif
    PFN_vkGetSemaphoreCounterValue m_GetSemaphoreCounterValue;
    PFN_vkGetSemaphoreCounterValueKHR m_GetSemaphoreCounterValueKHR;
    PFN_vkGetSemaphoreFdKHR m_GetSemaphoreFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetSemaphoreWin32HandleKHR m_GetSemaphoreWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetSemaphoreZirconHandleFUCHSIA m_GetSemaphoreZirconHandleFUCHSIA;
#endif
    PFN_vkGetShaderBinaryDataEXT m_GetShaderBinaryDataEXT;
    PFN_vkGetShaderInfoAMD m_GetShaderInfoAMD;
    PFN_vkGetShaderModuleCreateInfoIdentifierEXT m_GetShaderModuleCreateInfoIdentifierEXT;
    PFN_vkGetShaderModuleIdentifierEXT m_GetShaderModuleIdentifierEXT;
    PFN_vkGetSwapchainCounterEXT m_GetSwapchainCounterEXT;
    PFN_vkGetSwapchainImagesKHR m_GetSwapchainImagesKHR;
    PFN_vkGetSwapchainStatusKHR m_GetSwapchainStatusKHR;
    PFN_vkGetTensorMemoryRequirementsARM m_GetTensorMemoryRequirementsARM;
    PFN_vkGetTensorOpaqueCaptureDescriptorDataARM m_GetTensorOpaqueCaptureDescriptorDataARM;
    PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM m_GetTensorViewOpaqueCaptureDescriptorDataARM;
    PFN_vkGetValidationCacheDataEXT m_GetValidationCacheDataEXT;
    PFN_vkGetVideoSessionMemoryRequirementsKHR m_GetVideoSessionMemoryRequirementsKHR;
    PFN_vkImportFenceFdKHR m_ImportFenceFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportFenceWin32HandleKHR m_ImportFenceWin32HandleKHR;
#endif
    PFN_vkImportSemaphoreFdKHR m_ImportSemaphoreFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportSemaphoreWin32HandleKHR m_ImportSemaphoreWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkImportSemaphoreZirconHandleFUCHSIA m_ImportSemaphoreZirconHandleFUCHSIA;
#endif
    PFN_vkInitializePerformanceApiINTEL m_InitializePerformanceApiINTEL;
    PFN_vkInvalidateMappedMemoryRanges m_InvalidateMappedMemoryRanges;
    PFN_vkLatencySleepNV m_LatencySleepNV;
    PFN_vkMapMemory m_MapMemory;
    PFN_vkMapMemory2KHR m_MapMemory2KHR;
    PFN_vkMergePipelineCaches m_MergePipelineCaches;
    PFN_vkMergeValidationCachesEXT m_MergeValidationCachesEXT;
    PFN_vkQueueBeginDebugUtilsLabelEXT m_QueueBeginDebugUtilsLabelEXT;
    PFN_vkQueueBindSparse m_QueueBindSparse;
    PFN_vkQueueEndDebugUtilsLabelEXT m_QueueEndDebugUtilsLabelEXT;
    PFN_vkQueueInsertDebugUtilsLabelEXT m_QueueInsertDebugUtilsLabelEXT;
    PFN_vkQueueNotifyOutOfBandNV m_QueueNotifyOutOfBandNV;
    PFN_vkQueuePresentKHR m_QueuePresentKHR;
    PFN_vkQueueSetPerformanceConfigurationINTEL m_QueueSetPerformanceConfigurationINTEL;
    PFN_vkQueueSubmit m_QueueSubmit;
    PFN_vkQueueSubmit2 m_QueueSubmit2;
    PFN_vkQueueSubmit2KHR m_QueueSubmit2KHR;
    PFN_vkQueueWaitIdle m_QueueWaitIdle;
    PFN_vkRegisterDeviceEventEXT m_RegisterDeviceEventEXT;
    PFN_vkRegisterDisplayEventEXT m_RegisterDisplayEventEXT;
    PFN_vkReleaseCapturedPipelineDataKHR m_ReleaseCapturedPipelineDataKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkReleaseFullScreenExclusiveModeEXT m_ReleaseFullScreenExclusiveModeEXT;
#endif
    PFN_vkReleasePerformanceConfigurationINTEL m_ReleasePerformanceConfigurationINTEL;
    PFN_vkReleaseProfilingLockKHR m_ReleaseProfilingLockKHR;
    PFN_vkReleaseSwapchainImagesEXT m_ReleaseSwapchainImagesEXT;
    PFN_vkReleaseSwapchainImagesKHR m_ReleaseSwapchainImagesKHR;
    PFN_vkResetCommandBuffer m_ResetCommandBuffer;
    PFN_vkResetCommandPool m_ResetCommandPool;
    PFN_vkResetDescriptorPool m_ResetDescriptorPool;
    PFN_vkResetEvent m_ResetEvent;
    PFN_vkResetFences m_ResetFences;
    PFN_vkResetQueryPool m_ResetQueryPool;
    PFN_vkResetQueryPoolEXT m_ResetQueryPoolEXT;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA m_SetBufferCollectionBufferConstraintsFUCHSIA;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkSetBufferCollectionImageConstraintsFUCHSIA m_SetBufferCollectionImageConstraintsFUCHSIA;
#endif
    PFN_vkSetDebugUtilsObjectNameEXT m_SetDebugUtilsObjectNameEXT;
    PFN_vkSetDebugUtilsObjectTagEXT m_SetDebugUtilsObjectTagEXT;
    PFN_vkSetDeviceMemoryPriorityEXT m_SetDeviceMemoryPriorityEXT;
    PFN_vkSetEvent m_SetEvent;
    PFN_vkSetHdrMetadataEXT m_SetHdrMetadataEXT;
    PFN_vkSetLatencyMarkerNV m_SetLatencyMarkerNV;
    PFN_vkSetLatencySleepModeNV m_SetLatencySleepModeNV;
    PFN_vkSetLocalDimmingAMD m_SetLocalDimmingAMD;
    PFN_vkSetPrivateData m_SetPrivateData;
    PFN_vkSetPrivateDataEXT m_SetPrivateDataEXT;
    PFN_vkSignalSemaphore m_SignalSemaphore;
    PFN_vkSignalSemaphoreKHR m_SignalSemaphoreKHR;
    PFN_vkTransitionImageLayoutEXT m_TransitionImageLayoutEXT;
    PFN_vkTrimCommandPool m_TrimCommandPool;
    PFN_vkTrimCommandPoolKHR m_TrimCommandPoolKHR;
    PFN_vkUninitializePerformanceApiINTEL m_UninitializePerformanceApiINTEL;
    PFN_vkUnmapMemory m_UnmapMemory;
    PFN_vkUnmapMemory2KHR m_UnmapMemory2KHR;
    PFN_vkUpdateDescriptorSetWithTemplate m_UpdateDescriptorSetWithTemplate;
    PFN_vkUpdateDescriptorSetWithTemplateKHR m_UpdateDescriptorSetWithTemplateKHR;
    PFN_vkUpdateDescriptorSets m_UpdateDescriptorSets;
    PFN_vkUpdateIndirectExecutionSetPipelineEXT m_UpdateIndirectExecutionSetPipelineEXT;
    PFN_vkUpdateIndirectExecutionSetShaderEXT m_UpdateIndirectExecutionSetShaderEXT;
    PFN_vkUpdateVideoSessionParametersKHR m_UpdateVideoSessionParametersKHR;
    PFN_vkWaitForFences m_WaitForFences;
    PFN_vkWaitForPresent2KHR m_WaitForPresent2KHR;
    PFN_vkWaitForPresentKHR m_WaitForPresentKHR;
    PFN_vkWaitSemaphores m_WaitSemaphores;
    PFN_vkWaitSemaphoresKHR m_WaitSemaphoresKHR;
    PFN_vkWriteAccelerationStructuresPropertiesKHR m_WriteAccelerationStructuresPropertiesKHR;
    PFN_vkWriteMicromapsPropertiesEXT m_WriteMicromapsPropertiesEXT;
  };

  class VkQueueDispatch {
  public:
    VkQueueDispatch(VkQueue pQueue, const VkDeviceDispatch *pDeviceDispatch) {
      this->Queue = pQueue;
      this->pDeviceDispatch = pDeviceDispatch;
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return pDeviceDispatch->AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->AcquireFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex); }
    VkResult AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex); }
    VkResult AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) const { return pDeviceDispatch->AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration); }
    VkResult AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) const { return pDeviceDispatch->AcquireProfilingLockKHR(device, pInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return pDeviceDispatch->AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
    VkResult AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) const { return pDeviceDispatch->AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers); }
    VkResult AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets); }
    VkResult AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) const { return pDeviceDispatch->AllocateMemory(device, pAllocateInfo, pAllocator, pMemory); }
    void AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) const { pDeviceDispatch->AntiLagUpdateAMD(device, pData); }
    VkResult BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) const { return pDeviceDispatch->BeginCommandBuffer(commandBuffer, pBeginInfo); }
    VkResult BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) const { return pDeviceDispatch->BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindBufferMemory(device, buffer, memory, memoryOffset); }
    VkResult BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindImageMemory(device, image, memory, memoryOffset); }
    VkResult BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) const { return pDeviceDispatch->BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout); }
    VkResult BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindTensorMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) const { return pDeviceDispatch->BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos); }
    VkResult BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { return pDeviceDispatch->BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos); }
    VkResult BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { return pDeviceDispatch->BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos); }
    void CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) const { pDeviceDispatch->CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin); }
    void CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) const { pDeviceDispatch->CmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo); }
    void CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) const { pDeviceDispatch->CmdBeginQuery(commandBuffer, queryPool, query, flags); }
    void CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) const { pDeviceDispatch->CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index); }
    void CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) const { pDeviceDispatch->CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents); }
    void CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRendering(commandBuffer, pRenderingInfo); }
    void CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRenderingKHR(commandBuffer, pRenderingInfo); }
    void CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) const { pDeviceDispatch->CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set); }
    void CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) const { pDeviceDispatch->CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos); }
    void CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) const { pDeviceDispatch->CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); }
    void CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) const { pDeviceDispatch->CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo); }
    void CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType); }
    void CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType); }
    void CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout); }
    void CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) const { pDeviceDispatch->CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex); }
    void CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) const { pDeviceDispatch->CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders); }
    void CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout); }
    void CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) const { pDeviceDispatch->CmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo); }
    void CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) const { pDeviceDispatch->CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes); }
    void CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets); }
    void CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) const { pDeviceDispatch->CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter); }
    void CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2(commandBuffer, pBlitImageInfo); }
    void CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2KHR(commandBuffer, pBlitImageInfo); }
    void CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) const { pDeviceDispatch->CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset); }
    void CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) const { pDeviceDispatch->CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
    void CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { pDeviceDispatch->CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos); }
    void CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) const { pDeviceDispatch->CmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos); }
    void CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { pDeviceDispatch->CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos); }
    void CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) const { pDeviceDispatch->CmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo); }
    void CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) const { pDeviceDispatch->CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects); }
    void CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges); }
    void CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges); }
    void CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) const { pDeviceDispatch->CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo); }
    void CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) const { pDeviceDispatch->CmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos); }
    void CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) const { pDeviceDispatch->CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode); }
    void CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo); }
    void CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) const { pDeviceDispatch->CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions); }
    void CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2(commandBuffer, pCopyImageInfo); }
    void CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2KHR(commandBuffer, pCopyImageInfo); }
    void CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions); }
    void CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) const { pDeviceDispatch->CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride); }
    void CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) const { pDeviceDispatch->CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources); }
    void CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo); }
    void CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) const { pDeviceDispatch->CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags); }
    void CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) const { pDeviceDispatch->CmdCopyTensorARM(commandBuffer, pCopyTensorInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) const { pDeviceDispatch->CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo); }
#endif
    void CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo); }
    void CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdDebugMarkerEndEXT(commandBuffer); }
    void CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo); }
    void CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) const { pDeviceDispatch->CmdDecodeVideoKHR(commandBuffer, pDecodeInfo); }
    void CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) const { pDeviceDispatch->CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
    void CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) const { pDeviceDispatch->CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions); }
    void CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) const { pDeviceDispatch->CmdDispatchDataGraphARM(commandBuffer, session, pInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo); }
#endif
    void CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDispatchIndirect(commandBuffer, buffer, offset); }
    void CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) const { pDeviceDispatch->CmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo); }
    void CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const { pDeviceDispatch->CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance); }
    void CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset); }
    void CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const { pDeviceDispatch->CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
    void CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const { pDeviceDispatch->CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride); }
    void CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) const { pDeviceDispatch->CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask); }
    void CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) const { pDeviceDispatch->CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride); }
    void CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) const { pDeviceDispatch->CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset); }
    void CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) const { pDeviceDispatch->CmdEncodeVideoKHR(commandBuffer, pEncodeInfo); }
    void CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndConditionalRenderingEXT(commandBuffer); }
    void CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndDebugUtilsLabelEXT(commandBuffer); }
    void CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) const { pDeviceDispatch->CmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo); }
    void CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdEndQuery(commandBuffer, queryPool, query); }
    void CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) const { pDeviceDispatch->CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index); }
    void CmdEndRenderPass(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderPass(commandBuffer); }
    void CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2(commandBuffer, pSubpassEndInfo); }
    void CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo); }
    void CmdEndRendering(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRendering(commandBuffer); }
    void CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) const { pDeviceDispatch->CmdEndRendering2EXT(commandBuffer, pRenderingEndInfo); }
    void CmdEndRenderingKHR(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderingKHR(commandBuffer); }
    void CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) const { pDeviceDispatch->CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo); }
    void CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers); }
    void CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) const { pDeviceDispatch->CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) const { pDeviceDispatch->CmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize); }
#endif
    void CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) const { pDeviceDispatch->CmdNextSubpass(commandBuffer, contents); }
    void CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) const { pDeviceDispatch->CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo); }
    void CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2(commandBuffer, pDependencyInfo); }
    void CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo); }
    void CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer); }
    void CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo); }
    void CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) const { pDeviceDispatch->CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues); }
    void CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) const { pDeviceDispatch->CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo); }
    void CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) const { pDeviceDispatch->CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo); }
    void CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) const { pDeviceDispatch->CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
    void CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo); }
    void CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
    void CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdResetEvent(commandBuffer, event, stageMask); }
    void CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2(commandBuffer, event, stageMask); }
    void CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2KHR(commandBuffer, event, stageMask); }
    void CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount); }
    void CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) const { pDeviceDispatch->CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2(commandBuffer, pResolveImageInfo); }
    void CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2KHR(commandBuffer, pResolveImageInfo); }
    void CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) const { pDeviceDispatch->CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable); }
    void CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) const { pDeviceDispatch->CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable); }
    void CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) const { pDeviceDispatch->CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask); }
    void CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) const { pDeviceDispatch->CmdSetBlendConstants(commandBuffer, blendConstants); }
    void CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) const { pDeviceDispatch->CmdSetCheckpointNV(commandBuffer, pCheckpointMarker); }
    void CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) const { pDeviceDispatch->CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders); }
    void CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) const { pDeviceDispatch->CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced); }
    void CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) const { pDeviceDispatch->CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables); }
    void CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) const { pDeviceDispatch->CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations); }
    void CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) const { pDeviceDispatch->CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables); }
    void CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) const { pDeviceDispatch->CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks); }
    void CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) const { pDeviceDispatch->CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode); }
    void CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) const { pDeviceDispatch->CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode); }
    void CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) const { pDeviceDispatch->CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable); }
    void CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) const { pDeviceDispatch->CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable); }
    void CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) const { pDeviceDispatch->CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode); }
    void CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) const { pDeviceDispatch->CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable); }
    void CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) const { pDeviceDispatch->CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation); }
    void CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullMode(commandBuffer, cullMode); }
    void CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullModeEXT(commandBuffer, cullMode); }
    void CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const { pDeviceDispatch->CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
    void CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) const { pDeviceDispatch->CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo); }
    void CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) const { pDeviceDispatch->CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds); }
    void CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) const { pDeviceDispatch->CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable); }
    void CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) const { pDeviceDispatch->CmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange); }
    void CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) const { pDeviceDispatch->CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable); }
    void CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) const { pDeviceDispatch->CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne); }
    void CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOp(commandBuffer, depthCompareOp); }
    void CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp); }
    void CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnable(commandBuffer, depthTestEnable); }
    void CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable); }
    void CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable); }
    void CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable); }
    void CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) const { pDeviceDispatch->CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo); }
    void CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets); }
    void CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMask(commandBuffer, deviceMask); }
    void CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMaskKHR(commandBuffer, deviceMask); }
    void CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) const { pDeviceDispatch->CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles); }
    void CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) const { pDeviceDispatch->CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable); }
    void CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) const { pDeviceDispatch->CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode); }
    void CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdSetEvent(commandBuffer, event, stageMask); }
    void CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2(commandBuffer, event, pDependencyInfo); }
    void CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo); }
    void CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) const { pDeviceDispatch->CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
    void CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) const { pDeviceDispatch->CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors); }
    void CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) const { pDeviceDispatch->CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize); }
    void CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps); }
    void CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps); }
    void CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFace(commandBuffer, frontFace); }
    void CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFaceEXT(commandBuffer, frontFace); }
    void CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) const { pDeviceDispatch->CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode); }
    void CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) const { pDeviceDispatch->CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable); }
    void CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) const { pDeviceDispatch->CmdSetLineWidth(commandBuffer, lineWidth); }
    void CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) const { pDeviceDispatch->CmdSetLogicOpEXT(commandBuffer, logicOp); }
    void CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) const { pDeviceDispatch->CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable); }
    void CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) const { pDeviceDispatch->CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints); }
    VkResult CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo); }
    VkResult CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) const { return pDeviceDispatch->CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo); }
    VkResult CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo); }
    void CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) const { pDeviceDispatch->CmdSetPolygonModeEXT(commandBuffer, polygonMode); }
    void CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopology(commandBuffer, primitiveTopology); }
    void CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology); }
    void CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) const { pDeviceDispatch->CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode); }
    void CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) const { pDeviceDispatch->CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples); }
    void CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) const { pDeviceDispatch->CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream); }
    void CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) const { pDeviceDispatch->CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize); }
    void CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) const { pDeviceDispatch->CmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo); }
    void CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) const { pDeviceDispatch->CmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo); }
    void CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) const { pDeviceDispatch->CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable); }
    void CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) const { pDeviceDispatch->CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo); }
    void CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) const { pDeviceDispatch->CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable); }
    void CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) const { pDeviceDispatch->CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask); }
    void CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors); }
    void CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors); }
    void CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors); }
    void CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) const { pDeviceDispatch->CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable); }
    void CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) const { pDeviceDispatch->CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask); }
    void CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) const { pDeviceDispatch->CmdSetStencilReference(commandBuffer, faceMask, reference); }
    void CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnable(commandBuffer, stencilTestEnable); }
    void CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable); }
    void CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) const { pDeviceDispatch->CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask); }
    void CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) const { pDeviceDispatch->CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin); }
    void CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) const { pDeviceDispatch->CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions); }
    void CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports); }
    void CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) const { pDeviceDispatch->CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes); }
    void CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) const { pDeviceDispatch->CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles); }
    void CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) const { pDeviceDispatch->CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable); }
    void CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) const { pDeviceDispatch->CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings); }
    void CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports); }
    void CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports); }
    void CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdSubpassShadingHUAWEI(commandBuffer); }
    void CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress); }
    void CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress); }
    void CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth); }
    void CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
    void CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) const { pDeviceDispatch->CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData); }
    void CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker); }
    void CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker); }
    void CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery); }
    void CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query); }
    void CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2(commandBuffer, stage, queryPool, query); }
    void CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query); }
    VkResult CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) const { return pDeviceDispatch->CompileDeferredNV(device, pipeline, shader); }
    VkResult ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) const { return pDeviceDispatch->ConvertCooperativeVectorMatrixNV(device, pInfo); }
    VkResult CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo); }
    VkResult CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) const { return pDeviceDispatch->CopyImageToImageEXT(device, pCopyImageToImageInfo); }
    VkResult CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) const { return pDeviceDispatch->CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo); }
    VkResult CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) const { return pDeviceDispatch->CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo); }
    VkResult CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMemoryToMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapToMemoryEXT(device, deferredOperation, pInfo); }
    VkResult CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure); }
    VkResult CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) const { return pDeviceDispatch->CreateBuffer(device, pCreateInfo, pAllocator, pBuffer); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) const { return pDeviceDispatch->CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection); }
#endif
    VkResult CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) const { return pDeviceDispatch->CreateBufferView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) const { return pDeviceDispatch->CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool); }
    VkResult CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) const { return pDeviceDispatch->CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) const { return pDeviceDispatch->CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule); }
#endif
    VkResult CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) const { return pDeviceDispatch->CreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return pDeviceDispatch->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return pDeviceDispatch->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }
    VkResult CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) const { return pDeviceDispatch->CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation); }
    VkResult CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) const { return pDeviceDispatch->CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool); }
    VkResult CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) const { return pDeviceDispatch->CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout); }
    VkResult CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const { return pDeviceDispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return pDeviceDispatch->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) const { return pDeviceDispatch->CreateEvent(device, pCreateInfo, pAllocator, pEvent); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#endif
    VkResult CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) const { return pDeviceDispatch->CreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue); }
    VkResult CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->CreateFence(device, pCreateInfo, pAllocator, pFence); }
    VkResult CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) const { return pDeviceDispatch->CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer); }
    VkResult CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) const { return pDeviceDispatch->CreateImage(device, pCreateInfo, pAllocator, pImage); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) const { return pDeviceDispatch->CreateImageView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) const { return pDeviceDispatch->CreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet); }
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return pDeviceDispatch->CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) const { return pDeviceDispatch->CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap); }
    VkResult CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) const { return pDeviceDispatch->CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) const { return pDeviceDispatch->CreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries); }
    VkResult CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) const { return pDeviceDispatch->CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache); }
    VkResult CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) const { return pDeviceDispatch->CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout); }
    VkResult CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) const { return pDeviceDispatch->CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool); }
    VkResult CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) const { return pDeviceDispatch->CreateSampler(device, pCreateInfo, pAllocator, pSampler); }
    VkResult CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion); }
    VkResult CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) const { return pDeviceDispatch->CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore); }
    VkResult CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) const { return pDeviceDispatch->CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule); }
    VkResult CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) const { return pDeviceDispatch->CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders); }
    VkResult CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) const { return pDeviceDispatch->CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains); }
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) const { return pDeviceDispatch->CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain); }
    VkResult CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) const { return pDeviceDispatch->CreateTensorARM(device, pCreateInfo, pAllocator, pTensor); }
    VkResult CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) const { return pDeviceDispatch->CreateTensorViewARM(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) const { return pDeviceDispatch->CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache); }
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) const { return pDeviceDispatch->CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession); }
    VkResult CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) const { return pDeviceDispatch->CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->DebugMarkerSetObjectNameEXT(device, pNameInfo); }
    VkResult DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->DebugMarkerSetObjectTagEXT(device, pTagInfo); }
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { pDeviceDispatch->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    VkResult DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->DeferredOperationJoinKHR(device, operation); }
    void DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator); }
    void DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator); }
    void DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBuffer(device, buffer, pAllocator); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    void DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferCollectionFUCHSIA(device, collection, pAllocator); }
#endif
    void DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferView(device, bufferView, pAllocator); }
    void DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCommandPool(device, commandPool, pAllocator); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaFunctionNV(device, function, pAllocator); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaModuleNV(device, module, pAllocator); }
#endif
    void DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDataGraphPipelineSessionARM(device, session, pAllocator); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDeferredOperationKHR(device, operation, pAllocator); }
    void DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorPool(device, descriptorPool, pAllocator); }
    void DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator); }
    void DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDevice(device, pAllocator); }
    void DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyEvent(device, event, pAllocator); }
    void DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyExternalComputeQueueNV(device, externalQueue, pAllocator); }
    void DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFence(device, fence, pAllocator); }
    void DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFramebuffer(device, framebuffer, pAllocator); }
    void DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImage(device, image, pAllocator); }
    void DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImageView(device, imageView, pAllocator); }
    void DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator); }
    void DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyInstance(instance, pAllocator); }
    void DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyMicromapEXT(device, micromap, pAllocator); }
    void DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyOpticalFlowSessionNV(device, session, pAllocator); }
    void DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipeline(device, pipeline, pAllocator); }
    void DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator); }
    void DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineCache(device, pipelineCache, pAllocator); }
    void DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineLayout(device, pipelineLayout, pAllocator); }
    void DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlot(device, privateDataSlot, pAllocator); }
    void DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator); }
    void DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyQueryPool(device, queryPool, pAllocator); }
    void DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyRenderPass(device, renderPass, pAllocator); }
    void DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySampler(device, sampler, pAllocator); }
    void DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator); }
    void DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator); }
    void DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySemaphore(device, semaphore, pAllocator); }
    void DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderEXT(device, shader, pAllocator); }
    void DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderModule(device, shaderModule, pAllocator); }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySurfaceKHR(instance, surface, pAllocator); }
    void DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySwapchainKHR(device, swapchain, pAllocator); }
    void DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorARM(device, tensor, pAllocator); }
    void DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorViewARM(device, tensorView, pAllocator); }
    void DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyValidationCacheEXT(device, validationCache, pAllocator); }
    void DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionKHR(device, videoSession, pAllocator); }
    void DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator); }
    VkResult DeviceWaitIdle(VkDevice device) const { return pDeviceDispatch->DeviceWaitIdle(device); }
    VkResult DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) const { return pDeviceDispatch->DisplayPowerControlEXT(device, display, pDisplayPowerInfo); }
    VkResult EndCommandBuffer(VkCommandBuffer commandBuffer) const { return pDeviceDispatch->EndCommandBuffer(commandBuffer); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return pDeviceDispatch->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return pDeviceDispatch->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    void ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) const { pDeviceDispatch->ExportMetalObjectsEXT(device, pMetalObjectsInfo); }
#endif
    VkResult FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    void FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers); }
    VkResult FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets); }
    void FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->FreeMemory(device, memory, pAllocator); }
    void GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo); }
    VkDeviceAddress GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) const { return pDeviceDispatch->GetAccelerationStructureDeviceAddressKHR(device, pInfo); }
    VkResult GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) const { return pDeviceDispatch->GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData); }
    void GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) const { pDeviceDispatch->GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) const { return pDeviceDispatch->GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) const { return pDeviceDispatch->GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties); }
#endif
    VkDeviceAddress GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddress(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressEXT(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressKHR(device, pInfo); }
    void GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements(device, buffer, pMemoryRequirements); }
    void GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    uint64_t GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddressKHR(device, pInfo); }
    VkResult GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    VkResult GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    VkResult GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    void GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) const { return pDeviceDispatch->GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData); }
#endif
    VkResult GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties); }
    VkResult GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties); }
    VkResult GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) const { return pDeviceDispatch->GetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount, pBindPointRequirements); }
    void GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    uint32_t GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationMaxConcurrencyKHR(device, operation); }
    VkResult GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationResultKHR(device, operation); }
    void GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) const { pDeviceDispatch->GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor); }
    void GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) const { pDeviceDispatch->GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData); }
    void GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) const { pDeviceDispatch->GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset); }
    void GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) const { pDeviceDispatch->GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping); }
    void GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) const { pDeviceDispatch->GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes); }
    void GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport); }
    void GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport); }
    void GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility); }
    void GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    VkResult GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) const { return pDeviceDispatch->GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo); }
    void GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    void GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    VkResult GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) const { return pDeviceDispatch->GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes); }
#endif
    VkResult GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes); }
    void GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout); }
    void GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) const { pDeviceDispatch->GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo); }
    void GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility); }
    PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char *pName) const { return pDeviceDispatch->GetDeviceProcAddr(device, pName); }
    void GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue); }
    void GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue2(device, pQueueInfo, pQueue); }
    VkResult GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) const { return pDeviceDispatch->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize); }
    void GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return pDeviceDispatch->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return pDeviceDispatch->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return pDeviceDispatch->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return pDeviceDispatch->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    VkResult GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties); }
    VkResult GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData); }
    VkResult GetEventStatus(VkDevice device, VkEvent event) const { return pDeviceDispatch->GetEventStatus(device, event); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) const { return pDeviceDispatch->GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) const { return pDeviceDispatch->GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo); }
#endif
    void GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) const { pDeviceDispatch->GetExternalComputeQueueDataNV(externalQueue, params, pData); }
    VkResult GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetFenceFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetFenceStatus(VkDevice device, VkFence fence) const { return pDeviceDispatch->GetFenceStatus(device, fence); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
    VkResult GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties); }
    void GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements); }
    void GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) const { return pDeviceDispatch->GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties); }
    void GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements(device, image, pMemoryRequirements); }
    void GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    VkResult GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    void GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout); }
    VkResult GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return pDeviceDispatch->GetInstanceProcAddr(instance, pName); }
    void GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) const { return pDeviceDispatch->GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer); }
#endif
    VkResult GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetMemoryFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) const { return pDeviceDispatch->GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties); }
    VkResult GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) const { return pDeviceDispatch->GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) const { return pDeviceDispatch->GetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) const { return pDeviceDispatch->GetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties); }
#endif
    VkResult GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) const { return pDeviceDispatch->GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleNV(device, memory, handleType, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) const { return pDeviceDispatch->GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) const { return pDeviceDispatch->GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties); }
#endif
    void GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) const { pDeviceDispatch->GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo); }
    void GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo); }
    VkResult GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) const { return pDeviceDispatch->GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings); }
    VkResult GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) const { return pDeviceDispatch->GetPerformanceParameterINTEL(device, parameter, pValue); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return pDeviceDispatch->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return pDeviceDispatch->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { pDeviceDispatch->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return pDeviceDispatch->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return pDeviceDispatch->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return pDeviceDispatch->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return pDeviceDispatch->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return pDeviceDispatch->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return pDeviceDispatch->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return pDeviceDispatch->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
    VkResult GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) const { return pDeviceDispatch->GetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData); }
    VkResult GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetPipelineCacheData(device, pipelineCache, pDataSize, pData); }
    VkResult GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) const { return pDeviceDispatch->GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations); }
    VkResult GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties); }
    VkResult GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) const { return pDeviceDispatch->GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics); }
    VkDeviceAddress GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) const { return pDeviceDispatch->GetPipelineIndirectDeviceAddressNV(device, pInfo); }
    void GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements); }
    VkResult GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) const { return pDeviceDispatch->GetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey); }
    VkResult GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) const { return pDeviceDispatch->GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties); }
    void GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData); }
    void GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData); }
    VkResult GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) const { return pDeviceDispatch->GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags); }
    void GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData); }
    void GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData); }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
    VkResult GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkDeviceSize GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) const { return pDeviceDispatch->GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader); }
    VkResult GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) const { return pDeviceDispatch->GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties); }
    void GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderAreaGranularity(device, renderPass, pGranularity); }
    void GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity); }
    VkResult GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) const { return pDeviceDispatch->GetScreenBufferPropertiesQNX(device, buffer, pProperties); }
#endif
    VkResult GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValue(device, semaphore, pValue); }
    VkResult GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValueKHR(device, semaphore, pValue); }
    VkResult GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetSemaphoreFdKHR(device, pGetFdInfo, pFd); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
    VkResult GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetShaderBinaryDataEXT(device, shader, pDataSize, pData); }
    VkResult GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) const { return pDeviceDispatch->GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo); }
    void GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier); }
    void GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier); }
    VkResult GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) const { return pDeviceDispatch->GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue); }
    VkResult GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) const { return pDeviceDispatch->GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages); }
    VkResult GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->GetSwapchainStatusKHR(device, swapchain); }
    void GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetValidationCacheDataEXT(device, validationCache, pDataSize, pData); }
    VkResult GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) const { return pDeviceDispatch->GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) const { return pDeviceDispatch->ImportFenceFdKHR(device, pImportFenceFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) const { return pDeviceDispatch->ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo); }
#endif
    VkResult ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) const { return pDeviceDispatch->ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) const { return pDeviceDispatch->ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) const { return pDeviceDispatch->ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo); }
#endif
    VkResult InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) const { return pDeviceDispatch->InitializePerformanceApiINTEL(device, pInitializeInfo); }
    VkResult InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    VkResult LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) const { return pDeviceDispatch->LatencySleepNV(device, swapchain, pSleepInfo); }
    VkResult MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) const { return pDeviceDispatch->MapMemory(device, memory, offset, size, flags, ppData); }
    VkResult MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) const { return pDeviceDispatch->MapMemory2KHR(device, pMemoryMapInfo, ppData); }
    VkResult MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) const { return pDeviceDispatch->MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches); }
    VkResult MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) const { return pDeviceDispatch->MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches); }
    void QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo); }
    VkResult QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) const { return pDeviceDispatch->QueueBindSparse(queue, bindInfoCount, pBindInfo, fence); }
    void QueueEndDebugUtilsLabelEXT(VkQueue queue) const { pDeviceDispatch->QueueEndDebugUtilsLabelEXT(queue); }
    void QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo); }
    void QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) const { pDeviceDispatch->QueueNotifyOutOfBandNV(queue, pQueueTypeInfo); }
    VkResult QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) const { return pDeviceDispatch->QueuePresentKHR(queue, pPresentInfo); }
    VkResult QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->QueueSetPerformanceConfigurationINTEL(queue, configuration); }
    VkResult QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2KHR(queue, submitCount, pSubmits, fence); }
    VkResult QueueWaitIdle(VkQueue queue) const { return pDeviceDispatch->QueueWaitIdle(queue); }
    VkResult RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence); }
    VkResult RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence); }
    VkResult ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) const { return pDeviceDispatch->ReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator); }
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->ReleaseDisplayEXT(physicalDevice, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->ReleaseFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->ReleasePerformanceConfigurationINTEL(device, configuration); }
    void ReleaseProfilingLockKHR(VkDevice device) const { pDeviceDispatch->ReleaseProfilingLockKHR(device); }
    VkResult ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesEXT(device, pReleaseInfo); }
    VkResult ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesKHR(device, pReleaseInfo); }
    VkResult ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) const { return pDeviceDispatch->ResetCommandBuffer(commandBuffer, flags); }
    VkResult ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) const { return pDeviceDispatch->ResetCommandPool(device, commandPool, flags); }
    VkResult ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) const { return pDeviceDispatch->ResetDescriptorPool(device, descriptorPool, flags); }
    VkResult ResetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->ResetEvent(device, event); }
    VkResult ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) const { return pDeviceDispatch->ResetFences(device, fenceCount, pFences); }
    void ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPool(device, queryPool, firstQuery, queryCount); }
    void ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo); }
#endif
    VkResult SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->SetDebugUtilsObjectNameEXT(device, pNameInfo); }
    VkResult SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->SetDebugUtilsObjectTagEXT(device, pTagInfo); }
    void SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) const { pDeviceDispatch->SetDeviceMemoryPriorityEXT(device, memory, priority); }
    VkResult SetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->SetEvent(device, event); }
    void SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) const { pDeviceDispatch->SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata); }
    void SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo); }
    VkResult SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) const { return pDeviceDispatch->SetLatencySleepModeNV(device, swapchain, pSleepModeInfo); }
    void SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) const { pDeviceDispatch->SetLocalDimmingAMD(device, swapChain, localDimmingEnable); }
    VkResult SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateData(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphore(device, pSignalInfo); }
    VkResult SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphoreKHR(device, pSignalInfo); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { pDeviceDispatch->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
    VkResult TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) const { return pDeviceDispatch->TransitionImageLayoutEXT(device, transitionCount, pTransitions); }
    void TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPool(device, commandPool, flags); }
    void TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPoolKHR(device, commandPool, flags); }
    void UninitializePerformanceApiINTEL(VkDevice device) const { pDeviceDispatch->UninitializePerformanceApiINTEL(device); }
    void UnmapMemory(VkDevice device, VkDeviceMemory memory) const { pDeviceDispatch->UnmapMemory(device, memory); }
    VkResult UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) const { return pDeviceDispatch->UnmapMemory2KHR(device, pMemoryUnmapInfo); }
    void UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) const { pDeviceDispatch->UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies); }
    void UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    void UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    VkResult UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) const { return pDeviceDispatch->UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo); }
    VkResult WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) const { return pDeviceDispatch->WaitForFences(device, fenceCount, pFences, waitAll, timeout); }
    VkResult WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) const { return pDeviceDispatch->WaitForPresent2KHR(device, swapchain, pPresentWait2Info); }
    VkResult WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) const { return pDeviceDispatch->WaitForPresentKHR(device, swapchain, presentId, timeout); }
    VkResult WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphores(device, pWaitInfo, timeout); }
    VkResult WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphoresKHR(device, pWaitInfo, timeout); }
    VkResult WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride); }
    VkResult WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride); }
  public:
    VkQueue Queue;
    const VkDeviceDispatch *pDeviceDispatch;
  private:
  };

  class VkCommandBufferDispatch {
  public:
    VkCommandBufferDispatch(VkCommandBuffer pCommandBuffer, const VkDeviceDispatch *pDeviceDispatch) {
      this->CommandBuffer = pCommandBuffer;
      this->pDeviceDispatch = pDeviceDispatch;
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return pDeviceDispatch->AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->AcquireFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex); }
    VkResult AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex); }
    VkResult AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) const { return pDeviceDispatch->AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration); }
    VkResult AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) const { return pDeviceDispatch->AcquireProfilingLockKHR(device, pInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return pDeviceDispatch->AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
    VkResult AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) const { return pDeviceDispatch->AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers); }
    VkResult AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets); }
    VkResult AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) const { return pDeviceDispatch->AllocateMemory(device, pAllocateInfo, pAllocator, pMemory); }
    void AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) const { pDeviceDispatch->AntiLagUpdateAMD(device, pData); }
    VkResult BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) const { return pDeviceDispatch->BeginCommandBuffer(commandBuffer, pBeginInfo); }
    VkResult BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) const { return pDeviceDispatch->BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindBufferMemory(device, buffer, memory, memoryOffset); }
    VkResult BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindImageMemory(device, image, memory, memoryOffset); }
    VkResult BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) const { return pDeviceDispatch->BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout); }
    VkResult BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindTensorMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) const { return pDeviceDispatch->BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos); }
    VkResult BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { return pDeviceDispatch->BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos); }
    VkResult BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { return pDeviceDispatch->BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos); }
    void CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) const { pDeviceDispatch->CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin); }
    void CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) const { pDeviceDispatch->CmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo); }
    void CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) const { pDeviceDispatch->CmdBeginQuery(commandBuffer, queryPool, query, flags); }
    void CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) const { pDeviceDispatch->CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index); }
    void CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) const { pDeviceDispatch->CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents); }
    void CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRendering(commandBuffer, pRenderingInfo); }
    void CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRenderingKHR(commandBuffer, pRenderingInfo); }
    void CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) const { pDeviceDispatch->CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set); }
    void CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) const { pDeviceDispatch->CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos); }
    void CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) const { pDeviceDispatch->CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); }
    void CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) const { pDeviceDispatch->CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo); }
    void CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType); }
    void CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType); }
    void CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout); }
    void CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) const { pDeviceDispatch->CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex); }
    void CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) const { pDeviceDispatch->CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders); }
    void CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout); }
    void CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) const { pDeviceDispatch->CmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo); }
    void CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) const { pDeviceDispatch->CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes); }
    void CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets); }
    void CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) const { pDeviceDispatch->CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter); }
    void CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2(commandBuffer, pBlitImageInfo); }
    void CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2KHR(commandBuffer, pBlitImageInfo); }
    void CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) const { pDeviceDispatch->CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset); }
    void CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) const { pDeviceDispatch->CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
    void CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { pDeviceDispatch->CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos); }
    void CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) const { pDeviceDispatch->CmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos); }
    void CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { pDeviceDispatch->CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos); }
    void CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) const { pDeviceDispatch->CmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo); }
    void CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) const { pDeviceDispatch->CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects); }
    void CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges); }
    void CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges); }
    void CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) const { pDeviceDispatch->CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo); }
    void CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) const { pDeviceDispatch->CmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos); }
    void CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) const { pDeviceDispatch->CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode); }
    void CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo); }
    void CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) const { pDeviceDispatch->CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions); }
    void CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2(commandBuffer, pCopyImageInfo); }
    void CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2KHR(commandBuffer, pCopyImageInfo); }
    void CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions); }
    void CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) const { pDeviceDispatch->CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride); }
    void CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) const { pDeviceDispatch->CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources); }
    void CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo); }
    void CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) const { pDeviceDispatch->CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags); }
    void CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) const { pDeviceDispatch->CmdCopyTensorARM(commandBuffer, pCopyTensorInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) const { pDeviceDispatch->CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo); }
#endif
    void CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo); }
    void CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdDebugMarkerEndEXT(commandBuffer); }
    void CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo); }
    void CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) const { pDeviceDispatch->CmdDecodeVideoKHR(commandBuffer, pDecodeInfo); }
    void CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) const { pDeviceDispatch->CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
    void CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) const { pDeviceDispatch->CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions); }
    void CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) const { pDeviceDispatch->CmdDispatchDataGraphARM(commandBuffer, session, pInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo); }
#endif
    void CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDispatchIndirect(commandBuffer, buffer, offset); }
    void CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) const { pDeviceDispatch->CmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo); }
    void CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const { pDeviceDispatch->CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance); }
    void CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset); }
    void CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const { pDeviceDispatch->CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
    void CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const { pDeviceDispatch->CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride); }
    void CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) const { pDeviceDispatch->CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask); }
    void CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) const { pDeviceDispatch->CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride); }
    void CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) const { pDeviceDispatch->CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset); }
    void CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) const { pDeviceDispatch->CmdEncodeVideoKHR(commandBuffer, pEncodeInfo); }
    void CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndConditionalRenderingEXT(commandBuffer); }
    void CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndDebugUtilsLabelEXT(commandBuffer); }
    void CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) const { pDeviceDispatch->CmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo); }
    void CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdEndQuery(commandBuffer, queryPool, query); }
    void CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) const { pDeviceDispatch->CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index); }
    void CmdEndRenderPass(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderPass(commandBuffer); }
    void CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2(commandBuffer, pSubpassEndInfo); }
    void CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo); }
    void CmdEndRendering(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRendering(commandBuffer); }
    void CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) const { pDeviceDispatch->CmdEndRendering2EXT(commandBuffer, pRenderingEndInfo); }
    void CmdEndRenderingKHR(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderingKHR(commandBuffer); }
    void CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) const { pDeviceDispatch->CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo); }
    void CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers); }
    void CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) const { pDeviceDispatch->CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) const { pDeviceDispatch->CmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize); }
#endif
    void CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) const { pDeviceDispatch->CmdNextSubpass(commandBuffer, contents); }
    void CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) const { pDeviceDispatch->CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo); }
    void CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2(commandBuffer, pDependencyInfo); }
    void CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo); }
    void CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer); }
    void CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo); }
    void CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) const { pDeviceDispatch->CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues); }
    void CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) const { pDeviceDispatch->CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo); }
    void CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) const { pDeviceDispatch->CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo); }
    void CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) const { pDeviceDispatch->CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
    void CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo); }
    void CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
    void CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdResetEvent(commandBuffer, event, stageMask); }
    void CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2(commandBuffer, event, stageMask); }
    void CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2KHR(commandBuffer, event, stageMask); }
    void CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount); }
    void CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) const { pDeviceDispatch->CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2(commandBuffer, pResolveImageInfo); }
    void CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2KHR(commandBuffer, pResolveImageInfo); }
    void CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) const { pDeviceDispatch->CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable); }
    void CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) const { pDeviceDispatch->CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable); }
    void CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) const { pDeviceDispatch->CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask); }
    void CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) const { pDeviceDispatch->CmdSetBlendConstants(commandBuffer, blendConstants); }
    void CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) const { pDeviceDispatch->CmdSetCheckpointNV(commandBuffer, pCheckpointMarker); }
    void CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) const { pDeviceDispatch->CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders); }
    void CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) const { pDeviceDispatch->CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced); }
    void CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) const { pDeviceDispatch->CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables); }
    void CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) const { pDeviceDispatch->CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations); }
    void CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) const { pDeviceDispatch->CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables); }
    void CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) const { pDeviceDispatch->CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks); }
    void CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) const { pDeviceDispatch->CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode); }
    void CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) const { pDeviceDispatch->CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode); }
    void CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) const { pDeviceDispatch->CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable); }
    void CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) const { pDeviceDispatch->CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable); }
    void CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) const { pDeviceDispatch->CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode); }
    void CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) const { pDeviceDispatch->CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable); }
    void CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) const { pDeviceDispatch->CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation); }
    void CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullMode(commandBuffer, cullMode); }
    void CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullModeEXT(commandBuffer, cullMode); }
    void CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const { pDeviceDispatch->CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
    void CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) const { pDeviceDispatch->CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo); }
    void CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) const { pDeviceDispatch->CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds); }
    void CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) const { pDeviceDispatch->CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable); }
    void CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) const { pDeviceDispatch->CmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange); }
    void CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) const { pDeviceDispatch->CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable); }
    void CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) const { pDeviceDispatch->CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne); }
    void CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOp(commandBuffer, depthCompareOp); }
    void CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp); }
    void CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnable(commandBuffer, depthTestEnable); }
    void CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable); }
    void CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable); }
    void CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable); }
    void CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) const { pDeviceDispatch->CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo); }
    void CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets); }
    void CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMask(commandBuffer, deviceMask); }
    void CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMaskKHR(commandBuffer, deviceMask); }
    void CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) const { pDeviceDispatch->CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles); }
    void CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) const { pDeviceDispatch->CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable); }
    void CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) const { pDeviceDispatch->CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode); }
    void CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdSetEvent(commandBuffer, event, stageMask); }
    void CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2(commandBuffer, event, pDependencyInfo); }
    void CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo); }
    void CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) const { pDeviceDispatch->CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
    void CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) const { pDeviceDispatch->CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors); }
    void CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) const { pDeviceDispatch->CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize); }
    void CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps); }
    void CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps); }
    void CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFace(commandBuffer, frontFace); }
    void CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFaceEXT(commandBuffer, frontFace); }
    void CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) const { pDeviceDispatch->CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode); }
    void CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) const { pDeviceDispatch->CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable); }
    void CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) const { pDeviceDispatch->CmdSetLineWidth(commandBuffer, lineWidth); }
    void CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) const { pDeviceDispatch->CmdSetLogicOpEXT(commandBuffer, logicOp); }
    void CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) const { pDeviceDispatch->CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable); }
    void CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) const { pDeviceDispatch->CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints); }
    VkResult CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo); }
    VkResult CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) const { return pDeviceDispatch->CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo); }
    VkResult CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo); }
    void CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) const { pDeviceDispatch->CmdSetPolygonModeEXT(commandBuffer, polygonMode); }
    void CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopology(commandBuffer, primitiveTopology); }
    void CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology); }
    void CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) const { pDeviceDispatch->CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode); }
    void CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) const { pDeviceDispatch->CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples); }
    void CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) const { pDeviceDispatch->CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream); }
    void CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) const { pDeviceDispatch->CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize); }
    void CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) const { pDeviceDispatch->CmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo); }
    void CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) const { pDeviceDispatch->CmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo); }
    void CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) const { pDeviceDispatch->CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable); }
    void CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) const { pDeviceDispatch->CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo); }
    void CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) const { pDeviceDispatch->CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable); }
    void CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) const { pDeviceDispatch->CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask); }
    void CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors); }
    void CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors); }
    void CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors); }
    void CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) const { pDeviceDispatch->CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable); }
    void CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) const { pDeviceDispatch->CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask); }
    void CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) const { pDeviceDispatch->CmdSetStencilReference(commandBuffer, faceMask, reference); }
    void CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnable(commandBuffer, stencilTestEnable); }
    void CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable); }
    void CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) const { pDeviceDispatch->CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask); }
    void CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) const { pDeviceDispatch->CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin); }
    void CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) const { pDeviceDispatch->CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions); }
    void CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports); }
    void CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) const { pDeviceDispatch->CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes); }
    void CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) const { pDeviceDispatch->CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles); }
    void CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) const { pDeviceDispatch->CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable); }
    void CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) const { pDeviceDispatch->CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings); }
    void CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports); }
    void CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports); }
    void CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdSubpassShadingHUAWEI(commandBuffer); }
    void CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress); }
    void CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress); }
    void CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth); }
    void CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
    void CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) const { pDeviceDispatch->CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData); }
    void CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker); }
    void CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker); }
    void CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery); }
    void CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query); }
    void CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2(commandBuffer, stage, queryPool, query); }
    void CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query); }
    VkResult CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) const { return pDeviceDispatch->CompileDeferredNV(device, pipeline, shader); }
    VkResult ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) const { return pDeviceDispatch->ConvertCooperativeVectorMatrixNV(device, pInfo); }
    VkResult CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo); }
    VkResult CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) const { return pDeviceDispatch->CopyImageToImageEXT(device, pCopyImageToImageInfo); }
    VkResult CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) const { return pDeviceDispatch->CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo); }
    VkResult CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) const { return pDeviceDispatch->CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo); }
    VkResult CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMemoryToMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapToMemoryEXT(device, deferredOperation, pInfo); }
    VkResult CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure); }
    VkResult CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) const { return pDeviceDispatch->CreateBuffer(device, pCreateInfo, pAllocator, pBuffer); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) const { return pDeviceDispatch->CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection); }
#endif
    VkResult CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) const { return pDeviceDispatch->CreateBufferView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) const { return pDeviceDispatch->CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool); }
    VkResult CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) const { return pDeviceDispatch->CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) const { return pDeviceDispatch->CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule); }
#endif
    VkResult CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) const { return pDeviceDispatch->CreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return pDeviceDispatch->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return pDeviceDispatch->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }
    VkResult CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) const { return pDeviceDispatch->CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation); }
    VkResult CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) const { return pDeviceDispatch->CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool); }
    VkResult CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) const { return pDeviceDispatch->CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout); }
    VkResult CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const { return pDeviceDispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return pDeviceDispatch->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) const { return pDeviceDispatch->CreateEvent(device, pCreateInfo, pAllocator, pEvent); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#endif
    VkResult CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) const { return pDeviceDispatch->CreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue); }
    VkResult CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->CreateFence(device, pCreateInfo, pAllocator, pFence); }
    VkResult CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) const { return pDeviceDispatch->CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer); }
    VkResult CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) const { return pDeviceDispatch->CreateImage(device, pCreateInfo, pAllocator, pImage); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) const { return pDeviceDispatch->CreateImageView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) const { return pDeviceDispatch->CreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet); }
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return pDeviceDispatch->CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) const { return pDeviceDispatch->CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap); }
    VkResult CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) const { return pDeviceDispatch->CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) const { return pDeviceDispatch->CreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries); }
    VkResult CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) const { return pDeviceDispatch->CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache); }
    VkResult CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) const { return pDeviceDispatch->CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout); }
    VkResult CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) const { return pDeviceDispatch->CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool); }
    VkResult CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) const { return pDeviceDispatch->CreateSampler(device, pCreateInfo, pAllocator, pSampler); }
    VkResult CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion); }
    VkResult CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) const { return pDeviceDispatch->CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore); }
    VkResult CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) const { return pDeviceDispatch->CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule); }
    VkResult CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) const { return pDeviceDispatch->CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders); }
    VkResult CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) const { return pDeviceDispatch->CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains); }
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) const { return pDeviceDispatch->CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain); }
    VkResult CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) const { return pDeviceDispatch->CreateTensorARM(device, pCreateInfo, pAllocator, pTensor); }
    VkResult CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) const { return pDeviceDispatch->CreateTensorViewARM(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) const { return pDeviceDispatch->CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache); }
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) const { return pDeviceDispatch->CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession); }
    VkResult CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) const { return pDeviceDispatch->CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->DebugMarkerSetObjectNameEXT(device, pNameInfo); }
    VkResult DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->DebugMarkerSetObjectTagEXT(device, pTagInfo); }
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { pDeviceDispatch->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    VkResult DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->DeferredOperationJoinKHR(device, operation); }
    void DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator); }
    void DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator); }
    void DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBuffer(device, buffer, pAllocator); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    void DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferCollectionFUCHSIA(device, collection, pAllocator); }
#endif
    void DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferView(device, bufferView, pAllocator); }
    void DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCommandPool(device, commandPool, pAllocator); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaFunctionNV(device, function, pAllocator); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaModuleNV(device, module, pAllocator); }
#endif
    void DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDataGraphPipelineSessionARM(device, session, pAllocator); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDeferredOperationKHR(device, operation, pAllocator); }
    void DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorPool(device, descriptorPool, pAllocator); }
    void DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator); }
    void DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDevice(device, pAllocator); }
    void DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyEvent(device, event, pAllocator); }
    void DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyExternalComputeQueueNV(device, externalQueue, pAllocator); }
    void DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFence(device, fence, pAllocator); }
    void DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFramebuffer(device, framebuffer, pAllocator); }
    void DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImage(device, image, pAllocator); }
    void DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImageView(device, imageView, pAllocator); }
    void DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator); }
    void DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyInstance(instance, pAllocator); }
    void DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyMicromapEXT(device, micromap, pAllocator); }
    void DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyOpticalFlowSessionNV(device, session, pAllocator); }
    void DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipeline(device, pipeline, pAllocator); }
    void DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator); }
    void DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineCache(device, pipelineCache, pAllocator); }
    void DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineLayout(device, pipelineLayout, pAllocator); }
    void DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlot(device, privateDataSlot, pAllocator); }
    void DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator); }
    void DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyQueryPool(device, queryPool, pAllocator); }
    void DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyRenderPass(device, renderPass, pAllocator); }
    void DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySampler(device, sampler, pAllocator); }
    void DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator); }
    void DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator); }
    void DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySemaphore(device, semaphore, pAllocator); }
    void DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderEXT(device, shader, pAllocator); }
    void DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderModule(device, shaderModule, pAllocator); }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySurfaceKHR(instance, surface, pAllocator); }
    void DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySwapchainKHR(device, swapchain, pAllocator); }
    void DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorARM(device, tensor, pAllocator); }
    void DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorViewARM(device, tensorView, pAllocator); }
    void DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyValidationCacheEXT(device, validationCache, pAllocator); }
    void DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionKHR(device, videoSession, pAllocator); }
    void DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator); }
    VkResult DeviceWaitIdle(VkDevice device) const { return pDeviceDispatch->DeviceWaitIdle(device); }
    VkResult DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) const { return pDeviceDispatch->DisplayPowerControlEXT(device, display, pDisplayPowerInfo); }
    VkResult EndCommandBuffer(VkCommandBuffer commandBuffer) const { return pDeviceDispatch->EndCommandBuffer(commandBuffer); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return pDeviceDispatch->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return pDeviceDispatch->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    void ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) const { pDeviceDispatch->ExportMetalObjectsEXT(device, pMetalObjectsInfo); }
#endif
    VkResult FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    void FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers); }
    VkResult FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets); }
    void FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->FreeMemory(device, memory, pAllocator); }
    void GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo); }
    VkDeviceAddress GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) const { return pDeviceDispatch->GetAccelerationStructureDeviceAddressKHR(device, pInfo); }
    VkResult GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) const { return pDeviceDispatch->GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData); }
    void GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) const { pDeviceDispatch->GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) const { return pDeviceDispatch->GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) const { return pDeviceDispatch->GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties); }
#endif
    VkDeviceAddress GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddress(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressEXT(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressKHR(device, pInfo); }
    void GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements(device, buffer, pMemoryRequirements); }
    void GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    uint64_t GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddressKHR(device, pInfo); }
    VkResult GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    VkResult GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    VkResult GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    void GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) const { return pDeviceDispatch->GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData); }
#endif
    VkResult GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties); }
    VkResult GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties); }
    VkResult GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) const { return pDeviceDispatch->GetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount, pBindPointRequirements); }
    void GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    uint32_t GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationMaxConcurrencyKHR(device, operation); }
    VkResult GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationResultKHR(device, operation); }
    void GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) const { pDeviceDispatch->GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor); }
    void GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) const { pDeviceDispatch->GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData); }
    void GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) const { pDeviceDispatch->GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset); }
    void GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) const { pDeviceDispatch->GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping); }
    void GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) const { pDeviceDispatch->GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes); }
    void GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport); }
    void GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport); }
    void GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility); }
    void GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    VkResult GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) const { return pDeviceDispatch->GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo); }
    void GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    void GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    VkResult GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) const { return pDeviceDispatch->GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes); }
#endif
    VkResult GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes); }
    void GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout); }
    void GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) const { pDeviceDispatch->GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo); }
    void GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility); }
    PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char *pName) const { return pDeviceDispatch->GetDeviceProcAddr(device, pName); }
    void GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue); }
    void GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue2(device, pQueueInfo, pQueue); }
    VkResult GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) const { return pDeviceDispatch->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize); }
    void GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return pDeviceDispatch->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return pDeviceDispatch->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return pDeviceDispatch->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return pDeviceDispatch->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    VkResult GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties); }
    VkResult GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData); }
    VkResult GetEventStatus(VkDevice device, VkEvent event) const { return pDeviceDispatch->GetEventStatus(device, event); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) const { return pDeviceDispatch->GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) const { return pDeviceDispatch->GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo); }
#endif
    void GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) const { pDeviceDispatch->GetExternalComputeQueueDataNV(externalQueue, params, pData); }
    VkResult GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetFenceFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetFenceStatus(VkDevice device, VkFence fence) const { return pDeviceDispatch->GetFenceStatus(device, fence); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
    VkResult GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties); }
    void GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements); }
    void GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) const { return pDeviceDispatch->GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties); }
    void GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements(device, image, pMemoryRequirements); }
    void GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    VkResult GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    void GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout); }
    VkResult GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return pDeviceDispatch->GetInstanceProcAddr(instance, pName); }
    void GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) const { return pDeviceDispatch->GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer); }
#endif
    VkResult GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetMemoryFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) const { return pDeviceDispatch->GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties); }
    VkResult GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) const { return pDeviceDispatch->GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) const { return pDeviceDispatch->GetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) const { return pDeviceDispatch->GetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties); }
#endif
    VkResult GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) const { return pDeviceDispatch->GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleNV(device, memory, handleType, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) const { return pDeviceDispatch->GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) const { return pDeviceDispatch->GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties); }
#endif
    void GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) const { pDeviceDispatch->GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo); }
    void GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo); }
    VkResult GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) const { return pDeviceDispatch->GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings); }
    VkResult GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) const { return pDeviceDispatch->GetPerformanceParameterINTEL(device, parameter, pValue); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return pDeviceDispatch->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return pDeviceDispatch->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { pDeviceDispatch->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return pDeviceDispatch->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return pDeviceDispatch->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return pDeviceDispatch->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return pDeviceDispatch->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return pDeviceDispatch->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return pDeviceDispatch->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return pDeviceDispatch->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
    VkResult GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) const { return pDeviceDispatch->GetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData); }
    VkResult GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetPipelineCacheData(device, pipelineCache, pDataSize, pData); }
    VkResult GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) const { return pDeviceDispatch->GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations); }
    VkResult GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties); }
    VkResult GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) const { return pDeviceDispatch->GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics); }
    VkDeviceAddress GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) const { return pDeviceDispatch->GetPipelineIndirectDeviceAddressNV(device, pInfo); }
    void GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements); }
    VkResult GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) const { return pDeviceDispatch->GetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey); }
    VkResult GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) const { return pDeviceDispatch->GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties); }
    void GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData); }
    void GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData); }
    VkResult GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) const { return pDeviceDispatch->GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags); }
    void GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData); }
    void GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData); }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
    VkResult GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkDeviceSize GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) const { return pDeviceDispatch->GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader); }
    VkResult GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) const { return pDeviceDispatch->GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties); }
    void GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderAreaGranularity(device, renderPass, pGranularity); }
    void GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity); }
    VkResult GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) const { return pDeviceDispatch->GetScreenBufferPropertiesQNX(device, buffer, pProperties); }
#endif
    VkResult GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValue(device, semaphore, pValue); }
    VkResult GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValueKHR(device, semaphore, pValue); }
    VkResult GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetSemaphoreFdKHR(device, pGetFdInfo, pFd); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
    VkResult GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetShaderBinaryDataEXT(device, shader, pDataSize, pData); }
    VkResult GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) const { return pDeviceDispatch->GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo); }
    void GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier); }
    void GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier); }
    VkResult GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) const { return pDeviceDispatch->GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue); }
    VkResult GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) const { return pDeviceDispatch->GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages); }
    VkResult GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->GetSwapchainStatusKHR(device, swapchain); }
    void GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetValidationCacheDataEXT(device, validationCache, pDataSize, pData); }
    VkResult GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) const { return pDeviceDispatch->GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) const { return pDeviceDispatch->ImportFenceFdKHR(device, pImportFenceFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) const { return pDeviceDispatch->ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo); }
#endif
    VkResult ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) const { return pDeviceDispatch->ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) const { return pDeviceDispatch->ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) const { return pDeviceDispatch->ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo); }
#endif
    VkResult InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) const { return pDeviceDispatch->InitializePerformanceApiINTEL(device, pInitializeInfo); }
    VkResult InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    VkResult LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) const { return pDeviceDispatch->LatencySleepNV(device, swapchain, pSleepInfo); }
    VkResult MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) const { return pDeviceDispatch->MapMemory(device, memory, offset, size, flags, ppData); }
    VkResult MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) const { return pDeviceDispatch->MapMemory2KHR(device, pMemoryMapInfo, ppData); }
    VkResult MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) const { return pDeviceDispatch->MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches); }
    VkResult MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) const { return pDeviceDispatch->MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches); }
    void QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo); }
    VkResult QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) const { return pDeviceDispatch->QueueBindSparse(queue, bindInfoCount, pBindInfo, fence); }
    void QueueEndDebugUtilsLabelEXT(VkQueue queue) const { pDeviceDispatch->QueueEndDebugUtilsLabelEXT(queue); }
    void QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo); }
    void QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) const { pDeviceDispatch->QueueNotifyOutOfBandNV(queue, pQueueTypeInfo); }
    VkResult QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) const { return pDeviceDispatch->QueuePresentKHR(queue, pPresentInfo); }
    VkResult QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->QueueSetPerformanceConfigurationINTEL(queue, configuration); }
    VkResult QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2KHR(queue, submitCount, pSubmits, fence); }
    VkResult QueueWaitIdle(VkQueue queue) const { return pDeviceDispatch->QueueWaitIdle(queue); }
    VkResult RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence); }
    VkResult RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence); }
    VkResult ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) const { return pDeviceDispatch->ReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator); }
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->ReleaseDisplayEXT(physicalDevice, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->ReleaseFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->ReleasePerformanceConfigurationINTEL(device, configuration); }
    void ReleaseProfilingLockKHR(VkDevice device) const { pDeviceDispatch->ReleaseProfilingLockKHR(device); }
    VkResult ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesEXT(device, pReleaseInfo); }
    VkResult ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesKHR(device, pReleaseInfo); }
    VkResult ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) const { return pDeviceDispatch->ResetCommandBuffer(commandBuffer, flags); }
    VkResult ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) const { return pDeviceDispatch->ResetCommandPool(device, commandPool, flags); }
    VkResult ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) const { return pDeviceDispatch->ResetDescriptorPool(device, descriptorPool, flags); }
    VkResult ResetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->ResetEvent(device, event); }
    VkResult ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) const { return pDeviceDispatch->ResetFences(device, fenceCount, pFences); }
    void ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPool(device, queryPool, firstQuery, queryCount); }
    void ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo); }
#endif
    VkResult SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->SetDebugUtilsObjectNameEXT(device, pNameInfo); }
    VkResult SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->SetDebugUtilsObjectTagEXT(device, pTagInfo); }
    void SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) const { pDeviceDispatch->SetDeviceMemoryPriorityEXT(device, memory, priority); }
    VkResult SetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->SetEvent(device, event); }
    void SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) const { pDeviceDispatch->SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata); }
    void SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo); }
    VkResult SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) const { return pDeviceDispatch->SetLatencySleepModeNV(device, swapchain, pSleepModeInfo); }
    void SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) const { pDeviceDispatch->SetLocalDimmingAMD(device, swapChain, localDimmingEnable); }
    VkResult SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateData(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphore(device, pSignalInfo); }
    VkResult SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphoreKHR(device, pSignalInfo); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { pDeviceDispatch->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
    VkResult TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) const { return pDeviceDispatch->TransitionImageLayoutEXT(device, transitionCount, pTransitions); }
    void TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPool(device, commandPool, flags); }
    void TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPoolKHR(device, commandPool, flags); }
    void UninitializePerformanceApiINTEL(VkDevice device) const { pDeviceDispatch->UninitializePerformanceApiINTEL(device); }
    void UnmapMemory(VkDevice device, VkDeviceMemory memory) const { pDeviceDispatch->UnmapMemory(device, memory); }
    VkResult UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) const { return pDeviceDispatch->UnmapMemory2KHR(device, pMemoryUnmapInfo); }
    void UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) const { pDeviceDispatch->UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies); }
    void UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    void UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    VkResult UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) const { return pDeviceDispatch->UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo); }
    VkResult WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) const { return pDeviceDispatch->WaitForFences(device, fenceCount, pFences, waitAll, timeout); }
    VkResult WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) const { return pDeviceDispatch->WaitForPresent2KHR(device, swapchain, pPresentWait2Info); }
    VkResult WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) const { return pDeviceDispatch->WaitForPresentKHR(device, swapchain, presentId, timeout); }
    VkResult WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphores(device, pWaitInfo, timeout); }
    VkResult WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphoresKHR(device, pWaitInfo, timeout); }
    VkResult WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride); }
    VkResult WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride); }
  public:
    VkCommandBuffer CommandBuffer;
    const VkDeviceDispatch *pDeviceDispatch;
  private:
  };

  class VkExternalComputeQueueNVDispatch {
  public:
    VkExternalComputeQueueNVDispatch(VkExternalComputeQueueNV pExternalComputeQueueNV, const VkDeviceDispatch *pDeviceDispatch) {
      this->ExternalComputeQueueNV = pExternalComputeQueueNV;
      this->pDeviceDispatch = pDeviceDispatch;
    }

    // Put your types you want to associate with any dispatchable object here. This is a std::any, so it's destructor will trigger when the dispatchable object is destroyed.
    mutable GenericUserData UserData;
    VkResult AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const { return pDeviceDispatch->AcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->AcquireFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex); }
    VkResult AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) const { return pDeviceDispatch->AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex); }
    VkResult AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) const { return pDeviceDispatch->AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration); }
    VkResult AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) const { return pDeviceDispatch->AcquireProfilingLockKHR(device, pInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->AcquireWinrtDisplayNV(physicalDevice, display); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const { return pDeviceDispatch->AcquireXlibDisplayEXT(physicalDevice, dpy, display); }
#endif
    VkResult AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) const { return pDeviceDispatch->AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers); }
    VkResult AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets); }
    VkResult AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) const { return pDeviceDispatch->AllocateMemory(device, pAllocateInfo, pAllocator, pMemory); }
    void AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) const { pDeviceDispatch->AntiLagUpdateAMD(device, pData); }
    VkResult BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) const { return pDeviceDispatch->BeginCommandBuffer(commandBuffer, pBeginInfo); }
    VkResult BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) const { return pDeviceDispatch->BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindBufferMemory(device, buffer, memory, memoryOffset); }
    VkResult BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindBufferMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) const { return pDeviceDispatch->BindImageMemory(device, image, memory, memoryOffset); }
    VkResult BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2(device, bindInfoCount, pBindInfos); }
    VkResult BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) const { return pDeviceDispatch->BindImageMemory2KHR(device, bindInfoCount, pBindInfos); }
    VkResult BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) const { return pDeviceDispatch->BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout); }
    VkResult BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) const { return pDeviceDispatch->BindTensorMemoryARM(device, bindInfoCount, pBindInfos); }
    VkResult BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) const { return pDeviceDispatch->BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos); }
    VkResult BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { return pDeviceDispatch->BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos); }
    VkResult BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { return pDeviceDispatch->BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos); }
    void CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) const { pDeviceDispatch->CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin); }
    void CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) const { pDeviceDispatch->CmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo); }
    void CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) const { pDeviceDispatch->CmdBeginQuery(commandBuffer, queryPool, query, flags); }
    void CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) const { pDeviceDispatch->CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index); }
    void CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) const { pDeviceDispatch->CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents); }
    void CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) const { pDeviceDispatch->CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo); }
    void CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRendering(commandBuffer, pRenderingInfo); }
    void CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const { pDeviceDispatch->CmdBeginRenderingKHR(commandBuffer, pRenderingInfo); }
    void CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) const { pDeviceDispatch->CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo); }
    void CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) const { pDeviceDispatch->CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set); }
    void CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) const { pDeviceDispatch->CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos); }
    void CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) const { pDeviceDispatch->CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); }
    void CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) const { pDeviceDispatch->CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo); }
    void CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType); }
    void CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) const { pDeviceDispatch->CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType); }
    void CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout); }
    void CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) const { pDeviceDispatch->CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex); }
    void CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) const { pDeviceDispatch->CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders); }
    void CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) const { pDeviceDispatch->CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout); }
    void CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) const { pDeviceDispatch->CmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo); }
    void CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) const { pDeviceDispatch->CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes); }
    void CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets); }
    void CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const { pDeviceDispatch->CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
    void CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) const { pDeviceDispatch->CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter); }
    void CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2(commandBuffer, pBlitImageInfo); }
    void CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const { pDeviceDispatch->CmdBlitImage2KHR(commandBuffer, pBlitImageInfo); }
    void CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) const { pDeviceDispatch->CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset); }
    void CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) const { pDeviceDispatch->CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
    void CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) const { pDeviceDispatch->CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos); }
    void CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) const { pDeviceDispatch->CmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos); }
    void CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) const { pDeviceDispatch->CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos); }
    void CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) const { pDeviceDispatch->CmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo); }
    void CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) const { pDeviceDispatch->CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects); }
    void CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges); }
    void CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) const { pDeviceDispatch->CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges); }
    void CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) const { pDeviceDispatch->CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo); }
    void CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) const { pDeviceDispatch->CmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos); }
    void CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) const { pDeviceDispatch->CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode); }
    void CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo); }
    void CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) const { pDeviceDispatch->CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions); }
    void CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const { pDeviceDispatch->CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo); }
    void CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const { pDeviceDispatch->CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo); }
    void CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2(commandBuffer, pCopyImageInfo); }
    void CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const { pDeviceDispatch->CmdCopyImage2KHR(commandBuffer, pCopyImageInfo); }
    void CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) const { pDeviceDispatch->CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions); }
    void CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const { pDeviceDispatch->CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo); }
    void CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) const { pDeviceDispatch->CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride); }
    void CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { pDeviceDispatch->CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo); }
    void CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) const { pDeviceDispatch->CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources); }
    void CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapEXT(commandBuffer, pInfo); }
    void CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { pDeviceDispatch->CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo); }
    void CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) const { pDeviceDispatch->CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags); }
    void CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) const { pDeviceDispatch->CmdCopyTensorARM(commandBuffer, pCopyTensorInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) const { pDeviceDispatch->CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo); }
#endif
    void CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo); }
    void CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdDebugMarkerEndEXT(commandBuffer); }
    void CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const { pDeviceDispatch->CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo); }
    void CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) const { pDeviceDispatch->CmdDecodeVideoKHR(commandBuffer, pDecodeInfo); }
    void CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) const { pDeviceDispatch->CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
    void CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) const { pDeviceDispatch->CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions); }
    void CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
    void CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) const { pDeviceDispatch->CmdDispatchDataGraphARM(commandBuffer, session, pInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) const { pDeviceDispatch->CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo); }
#endif
    void CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDispatchIndirect(commandBuffer, buffer, offset); }
    void CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) const { pDeviceDispatch->CmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo); }
    void CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const { pDeviceDispatch->CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance); }
    void CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const { pDeviceDispatch->CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset); }
    void CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const { pDeviceDispatch->CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
    void CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const { pDeviceDispatch->CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride); }
    void CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { pDeviceDispatch->CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ); }
    void CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
    void CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) const { pDeviceDispatch->CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride); }
    void CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) const { pDeviceDispatch->CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask); }
    void CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) const { pDeviceDispatch->CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride); }
    void CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) const { pDeviceDispatch->CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset); }
    void CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) const { pDeviceDispatch->CmdEncodeVideoKHR(commandBuffer, pEncodeInfo); }
    void CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndConditionalRenderingEXT(commandBuffer); }
    void CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndDebugUtilsLabelEXT(commandBuffer); }
    void CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) const { pDeviceDispatch->CmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo); }
    void CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdEndQuery(commandBuffer, queryPool, query); }
    void CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) const { pDeviceDispatch->CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index); }
    void CmdEndRenderPass(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderPass(commandBuffer); }
    void CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2(commandBuffer, pSubpassEndInfo); }
    void CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo); }
    void CmdEndRendering(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRendering(commandBuffer); }
    void CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) const { pDeviceDispatch->CmdEndRendering2EXT(commandBuffer, pRenderingEndInfo); }
    void CmdEndRenderingKHR(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdEndRenderingKHR(commandBuffer); }
    void CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) const { pDeviceDispatch->CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
    void CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) const { pDeviceDispatch->CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo); }
    void CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers); }
    void CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo); }
    void CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) const { pDeviceDispatch->CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) const { pDeviceDispatch->CmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize); }
#endif
    void CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo); }
    void CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) const { pDeviceDispatch->CmdNextSubpass(commandBuffer, contents); }
    void CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) const { pDeviceDispatch->CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo); }
    void CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) const { pDeviceDispatch->CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo); }
    void CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2(commandBuffer, pDependencyInfo); }
    void CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo); }
    void CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer); }
    void CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const { pDeviceDispatch->CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo); }
    void CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) const { pDeviceDispatch->CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues); }
    void CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) const { pDeviceDispatch->CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo); }
    void CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) const { pDeviceDispatch->CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo); }
    void CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) const { pDeviceDispatch->CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
    void CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo); }
    void CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) const { pDeviceDispatch->CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
    void CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdResetEvent(commandBuffer, event, stageMask); }
    void CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2(commandBuffer, event, stageMask); }
    void CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const { pDeviceDispatch->CmdResetEvent2KHR(commandBuffer, event, stageMask); }
    void CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount); }
    void CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) const { pDeviceDispatch->CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
    void CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2(commandBuffer, pResolveImageInfo); }
    void CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const { pDeviceDispatch->CmdResolveImage2KHR(commandBuffer, pResolveImageInfo); }
    void CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) const { pDeviceDispatch->CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable); }
    void CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) const { pDeviceDispatch->CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable); }
    void CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) const { pDeviceDispatch->CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask); }
    void CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) const { pDeviceDispatch->CmdSetBlendConstants(commandBuffer, blendConstants); }
    void CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) const { pDeviceDispatch->CmdSetCheckpointNV(commandBuffer, pCheckpointMarker); }
    void CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) const { pDeviceDispatch->CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders); }
    void CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) const { pDeviceDispatch->CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced); }
    void CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) const { pDeviceDispatch->CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables); }
    void CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) const { pDeviceDispatch->CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations); }
    void CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) const { pDeviceDispatch->CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables); }
    void CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) const { pDeviceDispatch->CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks); }
    void CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) const { pDeviceDispatch->CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode); }
    void CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) const { pDeviceDispatch->CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode); }
    void CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) const { pDeviceDispatch->CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable); }
    void CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) const { pDeviceDispatch->CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable); }
    void CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) const { pDeviceDispatch->CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode); }
    void CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) const { pDeviceDispatch->CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable); }
    void CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) const { pDeviceDispatch->CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation); }
    void CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullMode(commandBuffer, cullMode); }
    void CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const { pDeviceDispatch->CmdSetCullModeEXT(commandBuffer, cullMode); }
    void CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const { pDeviceDispatch->CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
    void CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) const { pDeviceDispatch->CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo); }
    void CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const { pDeviceDispatch->CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable); }
    void CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) const { pDeviceDispatch->CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds); }
    void CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const { pDeviceDispatch->CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable); }
    void CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) const { pDeviceDispatch->CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable); }
    void CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) const { pDeviceDispatch->CmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange); }
    void CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) const { pDeviceDispatch->CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable); }
    void CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) const { pDeviceDispatch->CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne); }
    void CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOp(commandBuffer, depthCompareOp); }
    void CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const { pDeviceDispatch->CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp); }
    void CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnable(commandBuffer, depthTestEnable); }
    void CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const { pDeviceDispatch->CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable); }
    void CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable); }
    void CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const { pDeviceDispatch->CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable); }
    void CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) const { pDeviceDispatch->CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo); }
    void CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) const { pDeviceDispatch->CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets); }
    void CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMask(commandBuffer, deviceMask); }
    void CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) const { pDeviceDispatch->CmdSetDeviceMaskKHR(commandBuffer, deviceMask); }
    void CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) const { pDeviceDispatch->CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles); }
    void CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) const { pDeviceDispatch->CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable); }
    void CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) const { pDeviceDispatch->CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode); }
    void CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const { pDeviceDispatch->CmdSetEvent(commandBuffer, event, stageMask); }
    void CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2(commandBuffer, event, pDependencyInfo); }
    void CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) const { pDeviceDispatch->CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo); }
    void CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) const { pDeviceDispatch->CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
    void CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) const { pDeviceDispatch->CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors); }
    void CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) const { pDeviceDispatch->CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize); }
    void CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps); }
    void CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const { pDeviceDispatch->CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps); }
    void CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFace(commandBuffer, frontFace); }
    void CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const { pDeviceDispatch->CmdSetFrontFaceEXT(commandBuffer, frontFace); }
    void CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) const { pDeviceDispatch->CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode); }
    void CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) const { pDeviceDispatch->CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable); }
    void CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { pDeviceDispatch->CmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern); }
    void CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) const { pDeviceDispatch->CmdSetLineWidth(commandBuffer, lineWidth); }
    void CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) const { pDeviceDispatch->CmdSetLogicOpEXT(commandBuffer, logicOp); }
    void CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) const { pDeviceDispatch->CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable); }
    void CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) const { pDeviceDispatch->CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints); }
    VkResult CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo); }
    VkResult CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) const { return pDeviceDispatch->CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo); }
    VkResult CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) const { return pDeviceDispatch->CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo); }
    void CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) const { pDeviceDispatch->CmdSetPolygonModeEXT(commandBuffer, polygonMode); }
    void CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const { pDeviceDispatch->CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable); }
    void CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopology(commandBuffer, primitiveTopology); }
    void CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const { pDeviceDispatch->CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology); }
    void CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) const { pDeviceDispatch->CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode); }
    void CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) const { pDeviceDispatch->CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples); }
    void CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) const { pDeviceDispatch->CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream); }
    void CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const { pDeviceDispatch->CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable); }
    void CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) const { pDeviceDispatch->CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize); }
    void CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) const { pDeviceDispatch->CmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo); }
    void CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) const { pDeviceDispatch->CmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo); }
    void CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) const { pDeviceDispatch->CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable); }
    void CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) const { pDeviceDispatch->CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo); }
    void CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) const { pDeviceDispatch->CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable); }
    void CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) const { pDeviceDispatch->CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask); }
    void CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors); }
    void CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors); }
    void CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) const { pDeviceDispatch->CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors); }
    void CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) const { pDeviceDispatch->CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable); }
    void CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) const { pDeviceDispatch->CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask); }
    void CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const { pDeviceDispatch->CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
    void CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) const { pDeviceDispatch->CmdSetStencilReference(commandBuffer, faceMask, reference); }
    void CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnable(commandBuffer, stencilTestEnable); }
    void CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const { pDeviceDispatch->CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable); }
    void CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) const { pDeviceDispatch->CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask); }
    void CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) const { pDeviceDispatch->CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin); }
    void CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) const { pDeviceDispatch->CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions); }
    void CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports); }
    void CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) const { pDeviceDispatch->CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes); }
    void CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) const { pDeviceDispatch->CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles); }
    void CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) const { pDeviceDispatch->CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable); }
    void CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) const { pDeviceDispatch->CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings); }
    void CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports); }
    void CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) const { pDeviceDispatch->CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports); }
    void CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) const { pDeviceDispatch->CmdSubpassShadingHUAWEI(commandBuffer); }
    void CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress); }
    void CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) const { pDeviceDispatch->CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress); }
    void CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth); }
    void CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) const { pDeviceDispatch->CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
    void CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) const { pDeviceDispatch->CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData); }
    void CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const { pDeviceDispatch->CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline); }
    void CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) const { pDeviceDispatch->CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
    void CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) const { pDeviceDispatch->CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos); }
    void CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
    void CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker); }
    void CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const { pDeviceDispatch->CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker); }
    void CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) const { pDeviceDispatch->CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery); }
    void CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query); }
    void CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2(commandBuffer, stage, queryPool, query); }
    void CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) const { pDeviceDispatch->CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query); }
    VkResult CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) const { return pDeviceDispatch->CompileDeferredNV(device, pipeline, shader); }
    VkResult ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) const { return pDeviceDispatch->ConvertCooperativeVectorMatrixNV(device, pInfo); }
    VkResult CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const { return pDeviceDispatch->CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo); }
    VkResult CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) const { return pDeviceDispatch->CopyImageToImageEXT(device, pCopyImageToImageInfo); }
    VkResult CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) const { return pDeviceDispatch->CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo); }
    VkResult CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const { return pDeviceDispatch->CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo); }
    VkResult CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) const { return pDeviceDispatch->CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo); }
    VkResult CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMemoryToMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapEXT(device, deferredOperation, pInfo); }
    VkResult CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) const { return pDeviceDispatch->CopyMicromapToMemoryEXT(device, deferredOperation, pInfo); }
    VkResult CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure); }
    VkResult CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) const { return pDeviceDispatch->CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) const { return pDeviceDispatch->CreateBuffer(device, pCreateInfo, pAllocator, pBuffer); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) const { return pDeviceDispatch->CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection); }
#endif
    VkResult CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) const { return pDeviceDispatch->CreateBufferView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) const { return pDeviceDispatch->CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool); }
    VkResult CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) const { return pDeviceDispatch->CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) const { return pDeviceDispatch->CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule); }
#endif
    VkResult CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) const { return pDeviceDispatch->CreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) const { return pDeviceDispatch->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback); }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) const { return pDeviceDispatch->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger); }
    VkResult CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) const { return pDeviceDispatch->CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation); }
    VkResult CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) const { return pDeviceDispatch->CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool); }
    VkResult CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) const { return pDeviceDispatch->CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout); }
    VkResult CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const { return pDeviceDispatch->CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate); }
    VkResult CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const { return pDeviceDispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkResult CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const { return pDeviceDispatch->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode); }
    VkResult CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
    VkResult CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) const { return pDeviceDispatch->CreateEvent(device, pCreateInfo, pAllocator, pEvent); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
#endif
    VkResult CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) const { return pDeviceDispatch->CreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue); }
    VkResult CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->CreateFence(device, pCreateInfo, pAllocator, pFence); }
    VkResult CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) const { return pDeviceDispatch->CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer); }
    VkResult CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#ifdef VK_USE_PLATFORM_IOS_MVK
    VkResult CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) const { return pDeviceDispatch->CreateImage(device, pCreateInfo, pAllocator, pImage); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) const { return pDeviceDispatch->CreateImageView(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) const { return pDeviceDispatch->CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout); }
    VkResult CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) const { return pDeviceDispatch->CreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet); }
    VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) const { return pDeviceDispatch->CreateInstance(pCreateInfo, pAllocator, pInstance); }
#ifdef VK_USE_PLATFORM_MACOS_MVK
    VkResult CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) const { return pDeviceDispatch->CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap); }
    VkResult CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) const { return pDeviceDispatch->CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession); }
    VkResult CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) const { return pDeviceDispatch->CreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries); }
    VkResult CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) const { return pDeviceDispatch->CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache); }
    VkResult CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) const { return pDeviceDispatch->CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout); }
    VkResult CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) const { return pDeviceDispatch->CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot); }
    VkResult CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) const { return pDeviceDispatch->CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool); }
    VkResult CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const { return pDeviceDispatch->CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
    VkResult CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const { return pDeviceDispatch->CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass); }
    VkResult CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) const { return pDeviceDispatch->CreateSampler(device, pCreateInfo, pAllocator, pSampler); }
    VkResult CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion); }
    VkResult CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) const { return pDeviceDispatch->CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) const { return pDeviceDispatch->CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore); }
    VkResult CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) const { return pDeviceDispatch->CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule); }
    VkResult CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) const { return pDeviceDispatch->CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders); }
    VkResult CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) const { return pDeviceDispatch->CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains); }
#ifdef VK_USE_PLATFORM_GGP
    VkResult CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_OHOS
    VkResult CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) const { return pDeviceDispatch->CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain); }
    VkResult CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) const { return pDeviceDispatch->CreateTensorARM(device, pCreateInfo, pAllocator, pTensor); }
    VkResult CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) const { return pDeviceDispatch->CreateTensorViewARM(device, pCreateInfo, pAllocator, pView); }
    VkResult CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) const { return pDeviceDispatch->CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache); }
#ifdef VK_USE_PLATFORM_VI_NN
    VkResult CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) const { return pDeviceDispatch->CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession); }
    VkResult CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) const { return pDeviceDispatch->CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkResult CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkResult CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkResult CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const { return pDeviceDispatch->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface); }
#endif
    VkResult DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->DebugMarkerSetObjectNameEXT(device, pNameInfo); }
    VkResult DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->DebugMarkerSetObjectTagEXT(device, pTagInfo); }
    void DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const { pDeviceDispatch->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
    VkResult DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->DeferredOperationJoinKHR(device, operation); }
    void DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator); }
    void DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator); }
    void DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBuffer(device, buffer, pAllocator); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    void DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferCollectionFUCHSIA(device, collection, pAllocator); }
#endif
    void DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyBufferView(device, bufferView, pAllocator); }
    void DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCommandPool(device, commandPool, pAllocator); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaFunctionNV(device, function, pAllocator); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    void DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyCudaModuleNV(device, module, pAllocator); }
#endif
    void DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDataGraphPipelineSessionARM(device, session, pAllocator); }
    void DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
    void DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDeferredOperationKHR(device, operation, pAllocator); }
    void DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorPool(device, descriptorPool, pAllocator); }
    void DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator); }
    void DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator); }
    void DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyDevice(device, pAllocator); }
    void DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyEvent(device, event, pAllocator); }
    void DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyExternalComputeQueueNV(device, externalQueue, pAllocator); }
    void DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFence(device, fence, pAllocator); }
    void DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyFramebuffer(device, framebuffer, pAllocator); }
    void DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImage(device, image, pAllocator); }
    void DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyImageView(device, imageView, pAllocator); }
    void DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator); }
    void DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator); }
    void DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyInstance(instance, pAllocator); }
    void DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyMicromapEXT(device, micromap, pAllocator); }
    void DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyOpticalFlowSessionNV(device, session, pAllocator); }
    void DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipeline(device, pipeline, pAllocator); }
    void DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator); }
    void DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineCache(device, pipelineCache, pAllocator); }
    void DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPipelineLayout(device, pipelineLayout, pAllocator); }
    void DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlot(device, privateDataSlot, pAllocator); }
    void DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator); }
    void DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyQueryPool(device, queryPool, pAllocator); }
    void DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyRenderPass(device, renderPass, pAllocator); }
    void DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySampler(device, sampler, pAllocator); }
    void DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator); }
    void DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator); }
    void DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySemaphore(device, semaphore, pAllocator); }
    void DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderEXT(device, shader, pAllocator); }
    void DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyShaderModule(device, shaderModule, pAllocator); }
    void DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySurfaceKHR(instance, surface, pAllocator); }
    void DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroySwapchainKHR(device, swapchain, pAllocator); }
    void DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorARM(device, tensor, pAllocator); }
    void DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyTensorViewARM(device, tensorView, pAllocator); }
    void DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyValidationCacheEXT(device, validationCache, pAllocator); }
    void DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionKHR(device, videoSession, pAllocator); }
    void DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator); }
    VkResult DeviceWaitIdle(VkDevice device) const { return pDeviceDispatch->DeviceWaitIdle(device); }
    VkResult DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) const { return pDeviceDispatch->DisplayPowerControlEXT(device, display, pDisplayPowerInfo); }
    VkResult EndCommandBuffer(VkCommandBuffer commandBuffer) const { return pDeviceDispatch->EndCommandBuffer(commandBuffer); }
    VkResult EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties); }
    VkResult EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) const { return pDeviceDispatch->EnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties); }
    VkResult EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const { return pDeviceDispatch->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
    VkResult EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const { return pDeviceDispatch->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
    VkResult EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) const { return pDeviceDispatch->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    void ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) const { pDeviceDispatch->ExportMetalObjectsEXT(device, pMetalObjectsInfo); }
#endif
    VkResult FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    void FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) const { pDeviceDispatch->FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers); }
    VkResult FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) const { return pDeviceDispatch->FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets); }
    void FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) const { pDeviceDispatch->FreeMemory(device, memory, pAllocator); }
    void GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo); }
    VkDeviceAddress GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) const { return pDeviceDispatch->GetAccelerationStructureDeviceAddressKHR(device, pInfo); }
    VkResult GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) const { return pDeviceDispatch->GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData); }
    void GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) const { pDeviceDispatch->GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) const { return pDeviceDispatch->GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) const { return pDeviceDispatch->GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties); }
#endif
    VkDeviceAddress GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddress(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressEXT(device, pInfo); }
    VkDeviceAddress GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferDeviceAddressKHR(device, pInfo); }
    void GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements(device, buffer, pMemoryRequirements); }
    void GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    uint64_t GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const { return pDeviceDispatch->GetBufferOpaqueCaptureAddressKHR(device, pInfo); }
    VkResult GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    VkResult GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    VkResult GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) const { return pDeviceDispatch->GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation); }
    void GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) const { return pDeviceDispatch->GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData); }
#endif
    VkResult GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties); }
    VkResult GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) const { return pDeviceDispatch->GetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties); }
    VkResult GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) const { return pDeviceDispatch->GetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount, pBindPointRequirements); }
    void GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    uint32_t GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationMaxConcurrencyKHR(device, operation); }
    VkResult GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) const { return pDeviceDispatch->GetDeferredOperationResultKHR(device, operation); }
    void GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) const { pDeviceDispatch->GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor); }
    void GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) const { pDeviceDispatch->GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData); }
    void GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) const { pDeviceDispatch->GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset); }
    void GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) const { pDeviceDispatch->GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping); }
    void GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) const { pDeviceDispatch->GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes); }
    void GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport); }
    void GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) const { pDeviceDispatch->GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport); }
    void GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility); }
    void GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    VkResult GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) const { return pDeviceDispatch->GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo); }
    void GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    void GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const { pDeviceDispatch->GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures); }
    VkResult GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) const { return pDeviceDispatch->GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes); }
#endif
    VkResult GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) const { return pDeviceDispatch->GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes); }
    void GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout); }
    void GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) const { pDeviceDispatch->GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddress(device, pInfo); }
    uint64_t GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const { return pDeviceDispatch->GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo); }
    void GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) const { pDeviceDispatch->GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility); }
    PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char *pName) const { return pDeviceDispatch->GetDeviceProcAddr(device, pName); }
    void GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue); }
    void GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) const { pDeviceDispatch->GetDeviceQueue2(device, pQueueInfo, pQueue); }
    VkResult GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) const { return pDeviceDispatch->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize); }
    void GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) const { return pDeviceDispatch->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) const { return pDeviceDispatch->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties); }
    VkResult GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities); }
    VkResult GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities); }
    VkResult GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const { return pDeviceDispatch->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays); }
    VkResult GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) const { return pDeviceDispatch->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display); }
    VkResult GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties); }
    VkResult GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData); }
    VkResult GetEventStatus(VkDevice device, VkEvent event) const { return pDeviceDispatch->GetEventStatus(device, event); }
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) const { return pDeviceDispatch->GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex); }
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VkResult GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) const { return pDeviceDispatch->GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo); }
#endif
    void GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) const { pDeviceDispatch->GetExternalComputeQueueDataNV(externalQueue, params, pData); }
    VkResult GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetFenceFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetFenceStatus(VkDevice device, VkFence fence) const { return pDeviceDispatch->GetFenceStatus(device, fence); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
    VkResult GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) const { return pDeviceDispatch->GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties); }
    void GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements); }
    void GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements); }
    VkResult GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) const { return pDeviceDispatch->GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties); }
    void GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements(device, image, pMemoryRequirements); }
    void GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements); }
    void GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements); }
    VkResult GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    void GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const { pDeviceDispatch->GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
    void GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout); }
    void GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) const { pDeviceDispatch->GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout); }
    VkResult GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
    PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName) const { return pDeviceDispatch->GetInstanceProcAddr(instance, pName); }
    void GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo); }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    VkResult GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) const { return pDeviceDispatch->GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer); }
#endif
    VkResult GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetMemoryFdKHR(device, pGetFdInfo, pFd); }
    VkResult GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) const { return pDeviceDispatch->GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties); }
    VkResult GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) const { return pDeviceDispatch->GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties); }
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) const { return pDeviceDispatch->GetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    VkResult GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) const { return pDeviceDispatch->GetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties); }
#endif
    VkResult GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) const { return pDeviceDispatch->GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) const { return pDeviceDispatch->GetMemoryWin32HandleNV(device, memory, handleType, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) const { return pDeviceDispatch->GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) const { return pDeviceDispatch->GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties); }
#endif
    void GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) const { pDeviceDispatch->GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo); }
    void GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const { pDeviceDispatch->GetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo); }
    VkResult GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) const { return pDeviceDispatch->GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings); }
    VkResult GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) const { return pDeviceDispatch->GetPerformanceParameterINTEL(device, parameter, pValue); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) const { return pDeviceDispatch->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains); }
    VkResult GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties); }
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    VkBool32 GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) const { return pDeviceDispatch->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb); }
#endif
    VkResult GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) const { return pDeviceDispatch->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties); }
    void GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties); }
    void GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    void GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties); }
    VkResult GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties); }
    void GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties); }
    void GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) const { pDeviceDispatch->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties); }
    void GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) const { pDeviceDispatch->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures); }
    void GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties); }
    void GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) const { pDeviceDispatch->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties); }
    VkResult GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const { return pDeviceDispatch->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates); }
    VkResult GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    VkResult GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties); }
    void GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const { pDeviceDispatch->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties); }
    void GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) const { pDeviceDispatch->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties); }
    VkResult GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties); }
    VkResult GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) const { return pDeviceDispatch->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects); }
    void GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2(physicalDevice, pProperties); }
    void GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties); }
    void GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties); }
    VkResult GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const { return pDeviceDispatch->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties); }
    void GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses); }
    void GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
    void GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) const { pDeviceDispatch->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkBool32 GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) const { return pDeviceDispatch->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window); }
#endif
    void GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    void GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const { pDeviceDispatch->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties); }
    VkResult GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) const { return pDeviceDispatch->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities); }
    VkResult GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats); }
    VkResult GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes); }
#endif
    VkResult GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) const { return pDeviceDispatch->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes); }
    VkResult GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) const { return pDeviceDispatch->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported); }
    VkResult GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) const { return pDeviceDispatch->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties); }
    VkResult GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) const { return pDeviceDispatch->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities); }
    VkResult GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties); }
    VkResult GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const { return pDeviceDispatch->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    VkBool32 GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) const { return pDeviceDispatch->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display); }
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkBool32 GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) const { return pDeviceDispatch->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    VkBool32 GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) const { return pDeviceDispatch->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id); }
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    VkBool32 GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) const { return pDeviceDispatch->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID); }
#endif
    VkResult GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) const { return pDeviceDispatch->GetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData); }
    VkResult GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetPipelineCacheData(device, pipelineCache, pDataSize, pData); }
    VkResult GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) const { return pDeviceDispatch->GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations); }
    VkResult GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) const { return pDeviceDispatch->GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties); }
    VkResult GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) const { return pDeviceDispatch->GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics); }
    VkDeviceAddress GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) const { return pDeviceDispatch->GetPipelineIndirectDeviceAddressNV(device, pInfo); }
    void GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements); }
    VkResult GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) const { return pDeviceDispatch->GetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey); }
    VkResult GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) const { return pDeviceDispatch->GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties); }
    void GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData); }
    void GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) const { pDeviceDispatch->GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData); }
    VkResult GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) const { return pDeviceDispatch->GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags); }
    void GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData); }
    void GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) const { pDeviceDispatch->GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData); }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    VkResult GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay); }
#endif
    VkResult GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkResult GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) const { return pDeviceDispatch->GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData); }
    VkDeviceSize GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) const { return pDeviceDispatch->GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader); }
    VkResult GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) const { return pDeviceDispatch->GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties); }
    void GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderAreaGranularity(device, renderPass, pGranularity); }
    void GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) const { pDeviceDispatch->GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity); }
    VkResult GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) const { return pDeviceDispatch->GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData); }
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    VkResult GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) const { return pDeviceDispatch->GetScreenBufferPropertiesQNX(device, buffer, pProperties); }
#endif
    VkResult GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValue(device, semaphore, pValue); }
    VkResult GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const { return pDeviceDispatch->GetSemaphoreCounterValueKHR(device, semaphore, pValue); }
    VkResult GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) const { return pDeviceDispatch->GetSemaphoreFdKHR(device, pGetFdInfo, pFd); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) const { return pDeviceDispatch->GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) const { return pDeviceDispatch->GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle); }
#endif
    VkResult GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetShaderBinaryDataEXT(device, shader, pDataSize, pData); }
    VkResult GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) const { return pDeviceDispatch->GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo); }
    void GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier); }
    void GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) const { pDeviceDispatch->GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier); }
    VkResult GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) const { return pDeviceDispatch->GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue); }
    VkResult GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) const { return pDeviceDispatch->GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages); }
    VkResult GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->GetSwapchainStatusKHR(device, swapchain); }
    void GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) const { pDeviceDispatch->GetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements); }
    VkResult GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) const { return pDeviceDispatch->GetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData); }
    VkResult GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) const { return pDeviceDispatch->GetValidationCacheDataEXT(device, validationCache, pDataSize, pData); }
    VkResult GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) const { return pDeviceDispatch->GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) const { return pDeviceDispatch->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay); }
#endif
    VkResult ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) const { return pDeviceDispatch->ImportFenceFdKHR(device, pImportFenceFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) const { return pDeviceDispatch->ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo); }
#endif
    VkResult ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) const { return pDeviceDispatch->ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) const { return pDeviceDispatch->ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) const { return pDeviceDispatch->ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo); }
#endif
    VkResult InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) const { return pDeviceDispatch->InitializePerformanceApiINTEL(device, pInitializeInfo); }
    VkResult InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) const { return pDeviceDispatch->InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
    VkResult LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) const { return pDeviceDispatch->LatencySleepNV(device, swapchain, pSleepInfo); }
    VkResult MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) const { return pDeviceDispatch->MapMemory(device, memory, offset, size, flags, ppData); }
    VkResult MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) const { return pDeviceDispatch->MapMemory2KHR(device, pMemoryMapInfo, ppData); }
    VkResult MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) const { return pDeviceDispatch->MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches); }
    VkResult MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) const { return pDeviceDispatch->MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches); }
    void QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo); }
    VkResult QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) const { return pDeviceDispatch->QueueBindSparse(queue, bindInfoCount, pBindInfo, fence); }
    void QueueEndDebugUtilsLabelEXT(VkQueue queue) const { pDeviceDispatch->QueueEndDebugUtilsLabelEXT(queue); }
    void QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const { pDeviceDispatch->QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo); }
    void QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) const { pDeviceDispatch->QueueNotifyOutOfBandNV(queue, pQueueTypeInfo); }
    VkResult QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) const { return pDeviceDispatch->QueuePresentKHR(queue, pPresentInfo); }
    VkResult QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->QueueSetPerformanceConfigurationINTEL(queue, configuration); }
    VkResult QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2(queue, submitCount, pSubmits, fence); }
    VkResult QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) const { return pDeviceDispatch->QueueSubmit2KHR(queue, submitCount, pSubmits, fence); }
    VkResult QueueWaitIdle(VkQueue queue) const { return pDeviceDispatch->QueueWaitIdle(queue); }
    VkResult RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence); }
    VkResult RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) const { return pDeviceDispatch->RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence); }
    VkResult ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) const { return pDeviceDispatch->ReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator); }
    VkResult ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const { return pDeviceDispatch->ReleaseDisplayEXT(physicalDevice, display); }
#ifdef VK_USE_PLATFORM_WIN32_KHR
    VkResult ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const { return pDeviceDispatch->ReleaseFullScreenExclusiveModeEXT(device, swapchain); }
#endif
    VkResult ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) const { return pDeviceDispatch->ReleasePerformanceConfigurationINTEL(device, configuration); }
    void ReleaseProfilingLockKHR(VkDevice device) const { pDeviceDispatch->ReleaseProfilingLockKHR(device); }
    VkResult ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesEXT(device, pReleaseInfo); }
    VkResult ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const { return pDeviceDispatch->ReleaseSwapchainImagesKHR(device, pReleaseInfo); }
    VkResult ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) const { return pDeviceDispatch->ResetCommandBuffer(commandBuffer, flags); }
    VkResult ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) const { return pDeviceDispatch->ResetCommandPool(device, commandPool, flags); }
    VkResult ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) const { return pDeviceDispatch->ResetDescriptorPool(device, descriptorPool, flags); }
    VkResult ResetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->ResetEvent(device, event); }
    VkResult ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) const { return pDeviceDispatch->ResetFences(device, fenceCount, pFences); }
    void ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPool(device, queryPool, firstQuery, queryCount); }
    void ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { pDeviceDispatch->ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount); }
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo); }
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    VkResult SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) const { return pDeviceDispatch->SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo); }
#endif
    VkResult SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) const { return pDeviceDispatch->SetDebugUtilsObjectNameEXT(device, pNameInfo); }
    VkResult SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) const { return pDeviceDispatch->SetDebugUtilsObjectTagEXT(device, pTagInfo); }
    void SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) const { pDeviceDispatch->SetDeviceMemoryPriorityEXT(device, memory, priority); }
    VkResult SetEvent(VkDevice device, VkEvent event) const { return pDeviceDispatch->SetEvent(device, event); }
    void SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) const { pDeviceDispatch->SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata); }
    void SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) const { pDeviceDispatch->SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo); }
    VkResult SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) const { return pDeviceDispatch->SetLatencySleepModeNV(device, swapchain, pSleepModeInfo); }
    void SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) const { pDeviceDispatch->SetLocalDimmingAMD(device, swapChain, localDimmingEnable); }
    VkResult SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateData(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) const { return pDeviceDispatch->SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data); }
    VkResult SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphore(device, pSignalInfo); }
    VkResult SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const { return pDeviceDispatch->SignalSemaphoreKHR(device, pSignalInfo); }
    void SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const { pDeviceDispatch->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData); }
    VkResult TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) const { return pDeviceDispatch->TransitionImageLayoutEXT(device, transitionCount, pTransitions); }
    void TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPool(device, commandPool, flags); }
    void TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const { pDeviceDispatch->TrimCommandPoolKHR(device, commandPool, flags); }
    void UninitializePerformanceApiINTEL(VkDevice device) const { pDeviceDispatch->UninitializePerformanceApiINTEL(device); }
    void UnmapMemory(VkDevice device, VkDeviceMemory memory) const { pDeviceDispatch->UnmapMemory(device, memory); }
    VkResult UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) const { return pDeviceDispatch->UnmapMemory2KHR(device, pMemoryUnmapInfo); }
    void UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) const { pDeviceDispatch->UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData); }
    void UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) const { pDeviceDispatch->UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies); }
    void UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    void UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) const { pDeviceDispatch->UpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
    VkResult UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) const { return pDeviceDispatch->UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo); }
    VkResult WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) const { return pDeviceDispatch->WaitForFences(device, fenceCount, pFences, waitAll, timeout); }
    VkResult WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) const { return pDeviceDispatch->WaitForPresent2KHR(device, swapchain, pPresentWait2Info); }
    VkResult WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) const { return pDeviceDispatch->WaitForPresentKHR(device, swapchain, presentId, timeout); }
    VkResult WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphores(device, pWaitInfo, timeout); }
    VkResult WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const { return pDeviceDispatch->WaitSemaphoresKHR(device, pWaitInfo, timeout); }
    VkResult WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride); }
    VkResult WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const { return pDeviceDispatch->WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride); }
  public:
    VkExternalComputeQueueNV ExternalComputeQueueNV;
    const VkDeviceDispatch *pDeviceDispatch;
  private:
  };

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::AcquireDrmDisplayEXT(*dispatch, physicalDevice, drmFd, display);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::AcquireWinrtDisplayNV(*dispatch, physicalDevice, display);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::AcquireXlibDisplayEXT(*dispatch, physicalDevice, dpy, display);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateAndroidSurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDebugReportCallbackEXT(*dispatch, instance, pCreateInfo, pAllocator, pCallback);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDebugUtilsMessengerEXT(*dispatch, instance, pCreateInfo, pAllocator, pMessenger);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::CreateDevice(*dispatch, physicalDevice, pCreateInfo, pAllocator, pDevice);
    return ret;
  }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDirectFBSurfaceEXT(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::CreateDisplayModeKHR(*dispatch, physicalDevice, display, pCreateInfo, pAllocator, pMode);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDisplayPlaneSurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateHeadlessSurfaceEXT(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#ifdef VK_USE_PLATFORM_IOS_MVK
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateIOSSurfaceMVK(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateImagePipeSurfaceFUCHSIA(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) {
    VkResult ret = InstanceOverrides::CreateInstance(implicit_wrap_CreateInstance, pCreateInfo, pAllocator, pInstance);
    return ret;
  }

#ifdef VK_USE_PLATFORM_MACOS_MVK
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateMacOSSurfaceMVK(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateMetalSurfaceEXT(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateScreenSurfaceQNX(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_GGP
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateStreamDescriptorSurfaceGGP(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_OHOS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateSurfaceOHOS(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_VI_NN
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateViSurfaceNN(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateWaylandSurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateWin32SurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateXcbSurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::CreateXlibSurfaceKHR(*dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::DebugReportMessageEXT(*dispatch, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::DestroyDebugReportCallbackEXT(*dispatch, instance, callback, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::DestroyDebugUtilsMessengerEXT(*dispatch, instance, messenger, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::DestroyInstance(*dispatch, instance, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::DestroySurfaceKHR(*dispatch, instance, surface, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::EnumerateDeviceExtensionProperties(*dispatch, physicalDevice, pLayerName, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::EnumerateDeviceLayerProperties(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDeviceGroups(*dispatch, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDeviceGroupsKHR(*dispatch, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(*dispatch, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDevices(*dispatch, instance, pPhysicalDeviceCount, pPhysicalDevices);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayModeProperties2KHR(*dispatch, physicalDevice, display, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayModePropertiesKHR(*dispatch, physicalDevice, display, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayPlaneCapabilities2KHR(*dispatch, physicalDevice, pDisplayPlaneInfo, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayPlaneCapabilitiesKHR(*dispatch, physicalDevice, mode, planeIndex, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayPlaneSupportedDisplaysKHR(*dispatch, physicalDevice, planeIndex, pDisplayCount, pDisplays);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDrmDisplayEXT(*dispatch, physicalDevice, drmFd, connectorId, display);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction wrap_GetInstanceProcAddr(VkInstance instance, const char *pName) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    PFN_vkVoidFunction ret = InstanceOverrides::GetInstanceProcAddr(*dispatch, instance, pName);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsEXT(*dispatch, physicalDevice, pTimeDomainCount, pTimeDomains);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsKHR(*dispatch, physicalDevice, pTimeDomainCount, pTimeDomains);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesKHR(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesNV(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceCooperativeVectorPropertiesNV(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceDirectFBPresentationSupportEXT(*dispatch, physicalDevice, queueFamilyIndex, dfb);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayPlaneProperties2KHR(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayPlanePropertiesKHR(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayProperties2KHR(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayPropertiesKHR(*dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalBufferProperties(*dispatch, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalBufferPropertiesKHR(*dispatch, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalFenceProperties(*dispatch, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalFencePropertiesKHR(*dispatch, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceExternalImageFormatPropertiesNV(*dispatch, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalSemaphoreProperties(*dispatch, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalSemaphorePropertiesKHR(*dispatch, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalTensorPropertiesARM(*dispatch, physicalDevice, pExternalTensorInfo, pExternalTensorProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFeatures(*dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFeatures2(*dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFeatures2KHR(*dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFormatProperties(*dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFormatProperties2(*dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFormatProperties2KHR(*dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceFragmentShadingRatesKHR(*dispatch, physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceImageFormatProperties(*dispatch, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceImageFormatProperties2(*dispatch, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceImageFormatProperties2KHR(*dispatch, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMemoryProperties(*dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMemoryProperties2(*dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMemoryProperties2KHR(*dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMultisamplePropertiesEXT(*dispatch, physicalDevice, samples, pMultisampleProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceOpticalFlowImageFormatsNV(*dispatch, physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDevicePresentRectanglesKHR(*dispatch, physicalDevice, surface, pRectCount, pRects);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceProperties(*dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceProperties2(*dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceProperties2KHR(*dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(*dispatch, physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(*dispatch, physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(*dispatch, physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties(*dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2(*dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2KHR(*dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceScreenPresentationSupportQNX(*dispatch, physicalDevice, queueFamilyIndex, window);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties(*dispatch, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2(*dispatch, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2KHR(*dispatch, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(*dispatch, physicalDevice, pCombinationCount, pCombinations);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2EXT(*dispatch, physicalDevice, surface, pSurfaceCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2KHR(*dispatch, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceCapabilitiesKHR(*dispatch, physicalDevice, surface, pSurfaceCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceFormats2KHR(*dispatch, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceFormatsKHR(*dispatch, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfacePresentModes2EXT(*dispatch, physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfacePresentModesKHR(*dispatch, physicalDevice, surface, pPresentModeCount, pPresentModes);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceSupportKHR(*dispatch, physicalDevice, queueFamilyIndex, surface, pSupported);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceToolProperties(*dispatch, physicalDevice, pToolCount, pToolProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceToolPropertiesEXT(*dispatch, physicalDevice, pToolCount, pToolProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceVideoCapabilitiesKHR(*dispatch, physicalDevice, pVideoProfile, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(*dispatch, physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceVideoFormatPropertiesKHR(*dispatch, physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceWaylandPresentationSupportKHR(*dispatch, physicalDevice, queueFamilyIndex, display);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceWin32PresentationSupportKHR(*dispatch, physicalDevice, queueFamilyIndex);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceXcbPresentationSupportKHR(*dispatch, physicalDevice, queueFamilyIndex, connection, visual_id);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceXlibPresentationSupportKHR(*dispatch, physicalDevice, queueFamilyIndex, dpy, visualID);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetRandROutputDisplayEXT(*dispatch, physicalDevice, dpy, rrOutput, pDisplay);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetWinrtDisplayNV(*dispatch, physicalDevice, deviceRelativeId, pDisplay);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = LookupDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::ReleaseDisplayEXT(*dispatch, physicalDevice, display);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    InstanceOverrides::SubmitDebugUtilsMessageEXT(*dispatch, instance, messageSeverity, messageTypes, pCallbackData);
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AcquireFullScreenExclusiveModeEXT(*dispatch, device, swapchain);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AcquireNextImage2KHR(*dispatch, device, pAcquireInfo, pImageIndex);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AcquireNextImageKHR(*dispatch, device, swapchain, timeout, semaphore, fence, pImageIndex);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AcquirePerformanceConfigurationINTEL(*dispatch, device, pAcquireInfo, pConfiguration);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AcquireProfilingLockKHR(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AllocateCommandBuffers(*dispatch, device, pAllocateInfo, pCommandBuffers);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AllocateDescriptorSets(*dispatch, device, pAllocateInfo, pDescriptorSets);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::AllocateMemory(*dispatch, device, pAllocateInfo, pAllocator, pMemory);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::AntiLagUpdateAMD(*dispatch, device, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::BeginCommandBuffer(*dispatch, commandBuffer, pBeginInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindAccelerationStructureMemoryNV(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory(*dispatch, device, buffer, memory, memoryOffset);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory2(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory2KHR(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindDataGraphPipelineSessionMemoryARM(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory(*dispatch, device, image, memory, memoryOffset);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory2(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory2KHR(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindOpticalFlowSessionImageNV(*dispatch, device, session, bindingPoint, view, layout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindTensorMemoryARM(*dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BindVideoSessionMemoryKHR(*dispatch, device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BuildAccelerationStructuresKHR(*dispatch, device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::BuildMicromapsEXT(*dispatch, device, deferredOperation, infoCount, pInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginConditionalRenderingEXT(*dispatch, commandBuffer, pConditionalRenderingBegin);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginDebugUtilsLabelEXT(*dispatch, commandBuffer, pLabelInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginPerTileExecutionQCOM(*dispatch, commandBuffer, pPerTileBeginInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginQuery(*dispatch, commandBuffer, queryPool, query, flags);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginQueryIndexedEXT(*dispatch, commandBuffer, queryPool, query, flags, index);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass(*dispatch, commandBuffer, pRenderPassBegin, contents);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass2(*dispatch, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass2KHR(*dispatch, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRendering(*dispatch, commandBuffer, pRenderingInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderingKHR(*dispatch, commandBuffer, pRenderingInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginTransformFeedbackEXT(*dispatch, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBeginVideoCodingKHR(*dispatch, commandBuffer, pBeginInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT(*dispatch, commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT(*dispatch, commandBuffer, pipelineBindPoint, layout, set);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBuffersEXT(*dispatch, commandBuffer, bufferCount, pBindingInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorSets(*dispatch, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorSets2KHR(*dispatch, commandBuffer, pBindDescriptorSetsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindIndexBuffer(*dispatch, commandBuffer, buffer, offset, indexType);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindIndexBuffer2KHR(*dispatch, commandBuffer, buffer, offset, size, indexType);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindInvocationMaskHUAWEI(*dispatch, commandBuffer, imageView, imageLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindPipeline(*dispatch, commandBuffer, pipelineBindPoint, pipeline);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindPipelineShaderGroupNV(*dispatch, commandBuffer, pipelineBindPoint, pipeline, groupIndex);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindShadersEXT(*dispatch, commandBuffer, stageCount, pStages, pShaders);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindShadingRateImageNV(*dispatch, commandBuffer, imageView, imageLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindTileMemoryQCOM(*dispatch, commandBuffer, pTileMemoryBindInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindTransformFeedbackBuffersEXT(*dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers(*dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers2(*dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers2EXT(*dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage(*dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage2(*dispatch, commandBuffer, pBlitImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage2KHR(*dispatch, commandBuffer, pBlitImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructureNV(*dispatch, commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR(*dispatch, commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructuresKHR(*dispatch, commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV(*dispatch, commandBuffer, pCommandInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildMicromapsEXT(*dispatch, commandBuffer, infoCount, pInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV(*dispatch, commandBuffer, pBuildInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdClearAttachments(*dispatch, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdClearColorImage(*dispatch, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdClearDepthStencilImage(*dispatch, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdControlVideoCodingKHR(*dispatch, commandBuffer, pCodingControlInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdConvertCooperativeVectorMatrixNV(*dispatch, commandBuffer, infoCount, pInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureKHR(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureNV(*dispatch, commandBuffer, dst, src, mode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer(*dispatch, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer2(*dispatch, commandBuffer, pCopyBufferInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer2KHR(*dispatch, commandBuffer, pCopyBufferInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage(*dispatch, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage2(*dispatch, commandBuffer, pCopyBufferToImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage2KHR(*dispatch, commandBuffer, pCopyBufferToImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage(*dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage2(*dispatch, commandBuffer, pCopyImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage2KHR(*dispatch, commandBuffer, pCopyImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer(*dispatch, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer2(*dispatch, commandBuffer, pCopyImageToBufferInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer2KHR(*dispatch, commandBuffer, pCopyImageToBufferInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryIndirectNV(*dispatch, commandBuffer, copyBufferAddress, copyCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToImageIndirectNV(*dispatch, commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToMicromapEXT(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMicromapEXT(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMicromapToMemoryEXT(*dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyQueryPoolResults(*dispatch, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCopyTensorARM(*dispatch, commandBuffer, pCopyTensorInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdCudaLaunchKernelNV(*dispatch, commandBuffer, pLaunchInfo);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerBeginEXT(*dispatch, commandBuffer, pMarkerInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerEndEXT(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerInsertEXT(*dispatch, commandBuffer, pMarkerInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDecodeVideoKHR(*dispatch, commandBuffer, pDecodeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDecompressMemoryIndirectCountNV(*dispatch, commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDecompressMemoryNV(*dispatch, commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatch(*dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchBase(*dispatch, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchBaseKHR(*dispatch, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchDataGraphARM(*dispatch, commandBuffer, session, pInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphAMDX(*dispatch, commandBuffer, scratch, scratchSize, pCountInfo);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphIndirectAMDX(*dispatch, commandBuffer, scratch, scratchSize, pCountInfo);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphIndirectCountAMDX(*dispatch, commandBuffer, scratch, scratchSize, countInfo);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchIndirect(*dispatch, commandBuffer, buffer, offset);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchTileQCOM(*dispatch, commandBuffer, pDispatchTileInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDraw(*dispatch, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawClusterHUAWEI(*dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawClusterIndirectHUAWEI(*dispatch, commandBuffer, buffer, offset);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexed(*dispatch, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirect(*dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCount(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCountAMD(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCountKHR(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirect(*dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectByteCountEXT(*dispatch, commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCount(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCountAMD(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCountKHR(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksEXT(*dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectCountNV(*dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectEXT(*dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectNV(*dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksNV(*dispatch, commandBuffer, taskCount, firstTask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMultiEXT(*dispatch, commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMultiIndexedEXT(*dispatch, commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEncodeVideoKHR(*dispatch, commandBuffer, pEncodeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndConditionalRenderingEXT(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndDebugUtilsLabelEXT(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndPerTileExecutionQCOM(*dispatch, commandBuffer, pPerTileEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndQuery(*dispatch, commandBuffer, queryPool, query);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndQueryIndexedEXT(*dispatch, commandBuffer, queryPool, query, index);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass2(*dispatch, commandBuffer, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass2KHR(*dispatch, commandBuffer, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRendering(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRendering(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRendering2EXT(*dispatch, commandBuffer, pRenderingEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderingKHR(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndTransformFeedbackEXT(*dispatch, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdEndVideoCodingKHR(*dispatch, commandBuffer, pEndCodingInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteCommands(*dispatch, commandBuffer, commandBufferCount, pCommandBuffers);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteGeneratedCommandsEXT(*dispatch, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteGeneratedCommandsNV(*dispatch, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdFillBuffer(*dispatch, commandBuffer, dstBuffer, dstOffset, size, data);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX(*dispatch, commandBuffer, executionGraph, scratch, scratchSize);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdInsertDebugUtilsLabelEXT(*dispatch, commandBuffer, pLabelInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass(*dispatch, commandBuffer, contents);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass2(*dispatch, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass2KHR(*dispatch, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdOpticalFlowExecuteNV(*dispatch, commandBuffer, session, pExecuteInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier(*dispatch, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier2(*dispatch, commandBuffer, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier2KHR(*dispatch, commandBuffer, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPreprocessGeneratedCommandsEXT(*dispatch, commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPreprocessGeneratedCommandsNV(*dispatch, commandBuffer, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushConstants(*dispatch, commandBuffer, layout, stageFlags, offset, size, pValues);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushConstants2KHR(*dispatch, commandBuffer, pPushConstantsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSet2KHR(*dispatch, commandBuffer, pPushDescriptorSetInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetKHR(*dispatch, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR(*dispatch, commandBuffer, pPushDescriptorSetWithTemplateInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR(*dispatch, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent(*dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent2(*dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent2KHR(*dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResetQueryPool(*dispatch, commandBuffer, queryPool, firstQuery, queryCount);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage(*dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage2(*dispatch, commandBuffer, pResolveImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage2KHR(*dispatch, commandBuffer, pResolveImageInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetAlphaToCoverageEnableEXT(*dispatch, commandBuffer, alphaToCoverageEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetAlphaToOneEnableEXT(*dispatch, commandBuffer, alphaToOneEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT(*dispatch, commandBuffer, aspectMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetBlendConstants(*dispatch, commandBuffer, blendConstants);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCheckpointNV(*dispatch, commandBuffer, pCheckpointMarker);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoarseSampleOrderNV(*dispatch, commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendAdvancedEXT(*dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendEnableEXT(*dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendEquationEXT(*dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorWriteEnableEXT(*dispatch, commandBuffer, attachmentCount, pColorWriteEnables);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorWriteMaskEXT(*dispatch, commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetConservativeRasterizationModeEXT(*dispatch, commandBuffer, conservativeRasterizationMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationModeNV(*dispatch, commandBuffer, coverageModulationMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationTableEnableNV(*dispatch, commandBuffer, coverageModulationTableEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationTableNV(*dispatch, commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageReductionModeNV(*dispatch, commandBuffer, coverageReductionMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageToColorEnableNV(*dispatch, commandBuffer, coverageToColorEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageToColorLocationNV(*dispatch, commandBuffer, coverageToColorLocation);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCullMode(*dispatch, commandBuffer, cullMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetCullModeEXT(*dispatch, commandBuffer, cullMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBias(*dispatch, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBias2EXT(*dispatch, commandBuffer, pDepthBiasInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBiasEnable(*dispatch, commandBuffer, depthBiasEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBiasEnableEXT(*dispatch, commandBuffer, depthBiasEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBounds(*dispatch, commandBuffer, minDepthBounds, maxDepthBounds);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBoundsTestEnable(*dispatch, commandBuffer, depthBoundsTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBoundsTestEnableEXT(*dispatch, commandBuffer, depthBoundsTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClampEnableEXT(*dispatch, commandBuffer, depthClampEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClampRangeEXT(*dispatch, commandBuffer, depthClampMode, pDepthClampRange);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClipEnableEXT(*dispatch, commandBuffer, depthClipEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT(*dispatch, commandBuffer, negativeOneToOne);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthCompareOp(*dispatch, commandBuffer, depthCompareOp);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthCompareOpEXT(*dispatch, commandBuffer, depthCompareOp);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthTestEnable(*dispatch, commandBuffer, depthTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthTestEnableEXT(*dispatch, commandBuffer, depthTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthWriteEnable(*dispatch, commandBuffer, depthWriteEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthWriteEnableEXT(*dispatch, commandBuffer, depthWriteEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT(*dispatch, commandBuffer, pSetDescriptorBufferOffsetsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT(*dispatch, commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDeviceMask(*dispatch, commandBuffer, deviceMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDeviceMaskKHR(*dispatch, commandBuffer, deviceMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleEXT(*dispatch, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleEnableEXT(*dispatch, commandBuffer, discardRectangleEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleModeEXT(*dispatch, commandBuffer, discardRectangleMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent(*dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent2(*dispatch, commandBuffer, event, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent2KHR(*dispatch, commandBuffer, event, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetExclusiveScissorEnableNV(*dispatch, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetExclusiveScissorNV(*dispatch, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT(*dispatch, commandBuffer, extraPrimitiveOverestimationSize);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetFragmentShadingRateEnumNV(*dispatch, commandBuffer, shadingRate, combinerOps);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetFragmentShadingRateKHR(*dispatch, commandBuffer, pFragmentSize, combinerOps);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetFrontFace(*dispatch, commandBuffer, frontFace);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetFrontFaceEXT(*dispatch, commandBuffer, frontFace);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineRasterizationModeEXT(*dispatch, commandBuffer, lineRasterizationMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleEXT(*dispatch, commandBuffer, lineStippleFactor, lineStipplePattern);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleEnableEXT(*dispatch, commandBuffer, stippledLineEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleKHR(*dispatch, commandBuffer, lineStippleFactor, lineStipplePattern);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineWidth(*dispatch, commandBuffer, lineWidth);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLogicOpEXT(*dispatch, commandBuffer, logicOp);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetLogicOpEnableEXT(*dispatch, commandBuffer, logicOpEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPatchControlPointsEXT(*dispatch, commandBuffer, patchControlPoints);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceMarkerINTEL(*dispatch, commandBuffer, pMarkerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceOverrideINTEL(*dispatch, commandBuffer, pOverrideInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL(*dispatch, commandBuffer, pMarkerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPolygonModeEXT(*dispatch, commandBuffer, polygonMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveRestartEnable(*dispatch, commandBuffer, primitiveRestartEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveRestartEnableEXT(*dispatch, commandBuffer, primitiveRestartEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveTopology(*dispatch, commandBuffer, primitiveTopology);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveTopologyEXT(*dispatch, commandBuffer, primitiveTopology);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetProvokingVertexModeEXT(*dispatch, commandBuffer, provokingVertexMode);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizationSamplesEXT(*dispatch, commandBuffer, rasterizationSamples);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizationStreamEXT(*dispatch, commandBuffer, rasterizationStream);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizerDiscardEnable(*dispatch, commandBuffer, rasterizerDiscardEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizerDiscardEnableEXT(*dispatch, commandBuffer, rasterizerDiscardEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR(*dispatch, commandBuffer, pipelineStackSize);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR(*dispatch, commandBuffer, pLocationInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR(*dispatch, commandBuffer, pInputAttachmentIndexInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV(*dispatch, commandBuffer, representativeFragmentTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleLocationsEXT(*dispatch, commandBuffer, pSampleLocationsInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleLocationsEnableEXT(*dispatch, commandBuffer, sampleLocationsEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleMaskEXT(*dispatch, commandBuffer, samples, pSampleMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissor(*dispatch, commandBuffer, firstScissor, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissorWithCount(*dispatch, commandBuffer, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissorWithCountEXT(*dispatch, commandBuffer, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetShadingRateImageEnableNV(*dispatch, commandBuffer, shadingRateImageEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilCompareMask(*dispatch, commandBuffer, faceMask, compareMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilOp(*dispatch, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilOpEXT(*dispatch, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilReference(*dispatch, commandBuffer, faceMask, reference);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilTestEnable(*dispatch, commandBuffer, stencilTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilTestEnableEXT(*dispatch, commandBuffer, stencilTestEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilWriteMask(*dispatch, commandBuffer, faceMask, writeMask);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetTessellationDomainOriginEXT(*dispatch, commandBuffer, domainOrigin);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetVertexInputEXT(*dispatch, commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewport(*dispatch, commandBuffer, firstViewport, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportShadingRatePaletteNV(*dispatch, commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportSwizzleNV(*dispatch, commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWScalingEnableNV(*dispatch, commandBuffer, viewportWScalingEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWScalingNV(*dispatch, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWithCount(*dispatch, commandBuffer, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWithCountEXT(*dispatch, commandBuffer, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdSubpassShadingHUAWEI(*dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysIndirect2KHR(*dispatch, commandBuffer, indirectDeviceAddress);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysIndirectKHR(*dispatch, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysKHR(*dispatch, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysNV(*dispatch, commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdUpdateBuffer(*dispatch, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdUpdatePipelineIndirectBufferNV(*dispatch, commandBuffer, pipelineBindPoint, pipeline);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents(*dispatch, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents2(*dispatch, commandBuffer, eventCount, pEvents, pDependencyInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents2KHR(*dispatch, commandBuffer, eventCount, pEvents, pDependencyInfos);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR(*dispatch, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV(*dispatch, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteBufferMarker2AMD(*dispatch, commandBuffer, stage, dstBuffer, dstOffset, marker);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteBufferMarkerAMD(*dispatch, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteMicromapsPropertiesEXT(*dispatch, commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp(*dispatch, commandBuffer, pipelineStage, queryPool, query);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp2(*dispatch, commandBuffer, stage, queryPool, query);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp2KHR(*dispatch, commandBuffer, stage, queryPool, query);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CompileDeferredNV(*dispatch, device, pipeline, shader);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ConvertCooperativeVectorMatrixNV(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyAccelerationStructureKHR(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyAccelerationStructureToMemoryKHR(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyImageToImageEXT(*dispatch, device, pCopyImageToImageInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyImageToMemoryEXT(*dispatch, device, pCopyImageToMemoryInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToAccelerationStructureKHR(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToImageEXT(*dispatch, device, pCopyMemoryToImageInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToMicromapEXT(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyMicromapEXT(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CopyMicromapToMemoryEXT(*dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateAccelerationStructureKHR(*dispatch, device, pCreateInfo, pAllocator, pAccelerationStructure);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateAccelerationStructureNV(*dispatch, device, pCreateInfo, pAllocator, pAccelerationStructure);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateBuffer(*dispatch, device, pCreateInfo, pAllocator, pBuffer);
    return ret;
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateBufferCollectionFUCHSIA(*dispatch, device, pCreateInfo, pAllocator, pCollection);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateBufferView(*dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateCommandPool(*dispatch, device, pCreateInfo, pAllocator, pCommandPool);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateComputePipelines(*dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateCudaFunctionNV(*dispatch, device, pCreateInfo, pAllocator, pFunction);
    return ret;
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateCudaModuleNV(*dispatch, device, pCreateInfo, pAllocator, pModule);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDataGraphPipelineSessionARM(*dispatch, device, pCreateInfo, pAllocator, pSession);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDataGraphPipelinesARM(*dispatch, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDeferredOperationKHR(*dispatch, device, pAllocator, pDeferredOperation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorPool(*dispatch, device, pCreateInfo, pAllocator, pDescriptorPool);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorSetLayout(*dispatch, device, pCreateInfo, pAllocator, pSetLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorUpdateTemplate(*dispatch, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorUpdateTemplateKHR(*dispatch, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateEvent(*dispatch, device, pCreateInfo, pAllocator, pEvent);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateExecutionGraphPipelinesAMDX(*dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateExternalComputeQueueNV(*dispatch, device, pCreateInfo, pAllocator, pExternalQueue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateFence(*dispatch, device, pCreateInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateFramebuffer(*dispatch, device, pCreateInfo, pAllocator, pFramebuffer);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateGraphicsPipelines(*dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateImage(*dispatch, device, pCreateInfo, pAllocator, pImage);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateImageView(*dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectCommandsLayoutEXT(*dispatch, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectCommandsLayoutNV(*dispatch, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectExecutionSetEXT(*dispatch, device, pCreateInfo, pAllocator, pIndirectExecutionSet);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateMicromapEXT(*dispatch, device, pCreateInfo, pAllocator, pMicromap);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateOpticalFlowSessionNV(*dispatch, device, pCreateInfo, pAllocator, pSession);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineBinariesKHR(*dispatch, device, pCreateInfo, pAllocator, pBinaries);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineCache(*dispatch, device, pCreateInfo, pAllocator, pPipelineCache);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineLayout(*dispatch, device, pCreateInfo, pAllocator, pPipelineLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreatePrivateDataSlot(*dispatch, device, pCreateInfo, pAllocator, pPrivateDataSlot);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreatePrivateDataSlotEXT(*dispatch, device, pCreateInfo, pAllocator, pPrivateDataSlot);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateQueryPool(*dispatch, device, pCreateInfo, pAllocator, pQueryPool);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateRayTracingPipelinesKHR(*dispatch, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateRayTracingPipelinesNV(*dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass(*dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass2(*dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass2KHR(*dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSampler(*dispatch, device, pCreateInfo, pAllocator, pSampler);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSamplerYcbcrConversion(*dispatch, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSamplerYcbcrConversionKHR(*dispatch, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSemaphore(*dispatch, device, pCreateInfo, pAllocator, pSemaphore);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateShaderModule(*dispatch, device, pCreateInfo, pAllocator, pShaderModule);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateShadersEXT(*dispatch, device, createInfoCount, pCreateInfos, pAllocator, pShaders);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSharedSwapchainsKHR(*dispatch, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateSwapchainKHR(*dispatch, device, pCreateInfo, pAllocator, pSwapchain);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateTensorARM(*dispatch, device, pCreateInfo, pAllocator, pTensor);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateTensorViewARM(*dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateValidationCacheEXT(*dispatch, device, pCreateInfo, pAllocator, pValidationCache);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateVideoSessionKHR(*dispatch, device, pCreateInfo, pAllocator, pVideoSession);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::CreateVideoSessionParametersKHR(*dispatch, device, pCreateInfo, pAllocator, pVideoSessionParameters);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::DebugMarkerSetObjectNameEXT(*dispatch, device, pNameInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::DebugMarkerSetObjectTagEXT(*dispatch, device, pTagInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::DeferredOperationJoinKHR(*dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyAccelerationStructureKHR(*dispatch, device, accelerationStructure, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyAccelerationStructureNV(*dispatch, device, accelerationStructure, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyBuffer(*dispatch, device, buffer, pAllocator);
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyBufferCollectionFUCHSIA(*dispatch, device, collection, pAllocator);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyBufferView(*dispatch, device, bufferView, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyCommandPool(*dispatch, device, commandPool, pAllocator);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyCudaFunctionNV(*dispatch, device, function, pAllocator);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyCudaModuleNV(*dispatch, device, module, pAllocator);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDataGraphPipelineSessionARM(*dispatch, device, session, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDeferredOperationKHR(*dispatch, device, operation, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDescriptorPool(*dispatch, device, descriptorPool, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDescriptorSetLayout(*dispatch, device, descriptorSetLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDescriptorUpdateTemplate(*dispatch, device, descriptorUpdateTemplate, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDescriptorUpdateTemplateKHR(*dispatch, device, descriptorUpdateTemplate, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyDevice(*dispatch, device, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyEvent(*dispatch, device, event, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyExternalComputeQueueNV(*dispatch, device, externalQueue, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyFence(*dispatch, device, fence, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyFramebuffer(*dispatch, device, framebuffer, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyImage(*dispatch, device, image, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyImageView(*dispatch, device, imageView, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyIndirectCommandsLayoutEXT(*dispatch, device, indirectCommandsLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyIndirectCommandsLayoutNV(*dispatch, device, indirectCommandsLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyIndirectExecutionSetEXT(*dispatch, device, indirectExecutionSet, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyMicromapEXT(*dispatch, device, micromap, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyOpticalFlowSessionNV(*dispatch, device, session, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPipeline(*dispatch, device, pipeline, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPipelineBinaryKHR(*dispatch, device, pipelineBinary, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPipelineCache(*dispatch, device, pipelineCache, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPipelineLayout(*dispatch, device, pipelineLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPrivateDataSlot(*dispatch, device, privateDataSlot, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyPrivateDataSlotEXT(*dispatch, device, privateDataSlot, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyQueryPool(*dispatch, device, queryPool, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyRenderPass(*dispatch, device, renderPass, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroySampler(*dispatch, device, sampler, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroySamplerYcbcrConversion(*dispatch, device, ycbcrConversion, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroySamplerYcbcrConversionKHR(*dispatch, device, ycbcrConversion, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroySemaphore(*dispatch, device, semaphore, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyShaderEXT(*dispatch, device, shader, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyShaderModule(*dispatch, device, shaderModule, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroySwapchainKHR(*dispatch, device, swapchain, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyTensorARM(*dispatch, device, tensor, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyTensorViewARM(*dispatch, device, tensorView, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyValidationCacheEXT(*dispatch, device, validationCache, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyVideoSessionKHR(*dispatch, device, videoSession, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::DestroyVideoSessionParametersKHR(*dispatch, device, videoSessionParameters, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_DeviceWaitIdle(VkDevice device) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::DeviceWaitIdle(*dispatch, device);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::DisplayPowerControlEXT(*dispatch, device, display, pDisplayPowerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_EndCommandBuffer(VkCommandBuffer commandBuffer) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::EndCommandBuffer(*dispatch, commandBuffer);
    return ret;
  }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::ExportMetalObjectsEXT(*dispatch, device, pMetalObjectsInfo);
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::FlushMappedMemoryRanges(*dispatch, device, memoryRangeCount, pMemoryRanges);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::FreeCommandBuffers(*dispatch, device, commandPool, commandBufferCount, pCommandBuffers);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::FreeDescriptorSets(*dispatch, device, descriptorPool, descriptorSetCount, pDescriptorSets);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::FreeMemory(*dispatch, device, memory, pAllocator);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetAccelerationStructureBuildSizesKHR(*dispatch, device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetAccelerationStructureDeviceAddressKHR(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetAccelerationStructureHandleNV(*dispatch, device, accelerationStructure, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetAccelerationStructureMemoryRequirementsNV(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(*dispatch, device, pInfo, pData);
    return ret;
  }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetAndroidHardwareBufferPropertiesANDROID(*dispatch, device, buffer, pProperties);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetBufferCollectionPropertiesFUCHSIA(*dispatch, device, collection, pProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddress(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddressEXT(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddressKHR(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements(*dispatch, device, buffer, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements2(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements2KHR(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    uint64_t ret = DeviceOverrides::GetBufferOpaqueCaptureAddress(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    uint64_t ret = DeviceOverrides::GetBufferOpaqueCaptureAddressKHR(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetBufferOpaqueCaptureDescriptorDataEXT(*dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetCalibratedTimestampsEXT(*dispatch, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetCalibratedTimestampsKHR(*dispatch, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetClusterAccelerationStructureBuildSizesNV(*dispatch, device, pInfo, pSizeInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetCudaModuleCacheNV(*dispatch, device, module, pCacheSize, pCacheData);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelineAvailablePropertiesARM(*dispatch, device, pPipelineInfo, pPropertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelinePropertiesARM(*dispatch, device, pPipelineInfo, propertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelineSessionBindPointRequirementsARM(*dispatch, device, pInfo, pBindPointRequirementCount, pBindPointRequirements);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDataGraphPipelineSessionMemoryRequirementsARM(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static uint32_t wrap_GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    uint32_t ret = DeviceOverrides::GetDeferredOperationMaxConcurrencyKHR(*dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeferredOperationResultKHR(*dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorEXT(*dispatch, device, pDescriptorInfo, dataSize, pDescriptor);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetHostMappingVALVE(*dispatch, device, descriptorSet, ppData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutBindingOffsetEXT(*dispatch, device, layout, binding, pOffset);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutHostMappingInfoVALVE(*dispatch, device, pBindingReference, pHostMapping);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSizeEXT(*dispatch, device, layout, pLayoutSizeInBytes);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSupport(*dispatch, device, pCreateInfo, pSupport);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSupportKHR(*dispatch, device, pCreateInfo, pSupport);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceAccelerationStructureCompatibilityKHR(*dispatch, device, pVersionInfo, pCompatibility);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceBufferMemoryRequirements(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceBufferMemoryRequirementsKHR(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceFaultInfoEXT(*dispatch, device, pFaultCounts, pFaultInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceGroupPeerMemoryFeatures(*dispatch, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceGroupPeerMemoryFeaturesKHR(*dispatch, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupPresentCapabilitiesKHR(*dispatch, device, pDeviceGroupPresentCapabilities);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupSurfacePresentModes2EXT(*dispatch, device, pSurfaceInfo, pModes);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupSurfacePresentModesKHR(*dispatch, device, surface, pModes);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceImageMemoryRequirements(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceImageMemoryRequirementsKHR(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceImageSparseMemoryRequirements(*dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceImageSparseMemoryRequirementsKHR(*dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceImageSubresourceLayoutKHR(*dispatch, device, pInfo, pLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceMemoryCommitment(*dispatch, device, memory, pCommittedMemoryInBytes);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    uint64_t ret = DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddress(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    uint64_t ret = DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddressKHR(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceMicromapCompatibilityEXT(*dispatch, device, pVersionInfo, pCompatibility);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceQueue(*dispatch, device, queueFamilyIndex, queueIndex, pQueue);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceQueue2(*dispatch, device, pQueueInfo, pQueue);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(*dispatch, device, renderpass, pMaxWorkgroupSize);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetDeviceTensorMemoryRequirementsARM(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetDynamicRenderingTilePropertiesQCOM(*dispatch, device, pRenderingInfo, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetEncodedVideoSessionParametersKHR(*dispatch, device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetEventStatus(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetEventStatus(*dispatch, device, event);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetExecutionGraphPipelineNodeIndexAMDX(*dispatch, device, executionGraph, pNodeInfo, pNodeIndex);
    return ret;
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetExecutionGraphPipelineScratchSizeAMDX(*dispatch, device, executionGraph, pSizeInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) {
    const VkExternalComputeQueueNVDispatch* dispatch = LookupDispatch(externalQueue);
    DeviceOverrides::GetExternalComputeQueueDataNV(*dispatch, externalQueue, params, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceFdKHR(*dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceStatus(VkDevice device, VkFence fence) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceStatus(*dispatch, device, fence);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceWin32HandleKHR(*dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetFramebufferTilePropertiesQCOM(*dispatch, device, framebuffer, pPropertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetGeneratedCommandsMemoryRequirementsEXT(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetGeneratedCommandsMemoryRequirementsNV(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetImageDrmFormatModifierPropertiesEXT(*dispatch, device, image, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements(*dispatch, device, image, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements2(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements2KHR(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetImageOpaqueCaptureDescriptorDataEXT(*dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements(*dispatch, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements2(*dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements2KHR(*dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout(*dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout2EXT(*dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout2KHR(*dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetImageViewOpaqueCaptureDescriptorDataEXT(*dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetLatencyTimingsNV(*dispatch, device, swapchain, pLatencyMarkerInfo);
  }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryAndroidHardwareBufferANDROID(*dispatch, device, pInfo, pBuffer);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryFdKHR(*dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryFdPropertiesKHR(*dispatch, device, handleType, fd, pMemoryFdProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryHostPointerPropertiesEXT(*dispatch, device, handleType, pHostPointer, pMemoryHostPointerProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryMetalHandleEXT(*dispatch, device, pGetMetalHandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryMetalHandlePropertiesEXT(*dispatch, device, handleType, pHandle, pMemoryMetalHandleProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryRemoteAddressNV(*dispatch, device, pMemoryGetRemoteAddressInfo, pAddress);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandleKHR(*dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandleNV(*dispatch, device, memory, handleType, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandlePropertiesKHR(*dispatch, device, handleType, handle, pMemoryWin32HandleProperties);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryZirconHandleFUCHSIA(*dispatch, device, pGetZirconHandleInfo, pZirconHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryZirconHandlePropertiesFUCHSIA(*dispatch, device, handleType, zirconHandle, pMemoryZirconHandleProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetMicromapBuildSizesEXT(*dispatch, device, buildType, pBuildInfo, pSizeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetPartitionedAccelerationStructuresBuildSizesNV(*dispatch, device, pInfo, pSizeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPastPresentationTimingGOOGLE(*dispatch, device, swapchain, pPresentationTimingCount, pPresentationTimings);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPerformanceParameterINTEL(*dispatch, device, parameter, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineBinaryDataKHR(*dispatch, device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineCacheData(*dispatch, device, pipelineCache, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutableInternalRepresentationsKHR(*dispatch, device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutablePropertiesKHR(*dispatch, device, pPipelineInfo, pExecutableCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutableStatisticsKHR(*dispatch, device, pExecutableInfo, pStatisticCount, pStatistics);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetPipelineIndirectDeviceAddressNV(*dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetPipelineIndirectMemoryRequirementsNV(*dispatch, device, pCreateInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineKeyKHR(*dispatch, device, pPipelineCreateInfo, pPipelineKey);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelinePropertiesEXT(*dispatch, device, pPipelineInfo, pPipelineProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetPrivateData(*dispatch, device, objectType, objectHandle, privateDataSlot, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetPrivateDataEXT(*dispatch, device, objectType, objectHandle, privateDataSlot, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetQueryPoolResults(*dispatch, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::GetQueueCheckpointData2NV(*dispatch, queue, pCheckpointDataCount, pCheckpointData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::GetQueueCheckpointDataNV(*dispatch, queue, pCheckpointDataCount, pCheckpointData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingCaptureReplayShaderGroupHandlesKHR(*dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingShaderGroupHandlesKHR(*dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingShaderGroupHandlesNV(*dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkDeviceSize wrap_GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkDeviceSize ret = DeviceOverrides::GetRayTracingShaderGroupStackSizeKHR(*dispatch, device, pipeline, group, groupShader);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetRefreshCycleDurationGOOGLE(*dispatch, device, swapchain, pDisplayTimingProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetRenderAreaGranularity(*dispatch, device, renderPass, pGranularity);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetRenderingAreaGranularityKHR(*dispatch, device, pRenderingAreaInfo, pGranularity);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSamplerOpaqueCaptureDescriptorDataEXT(*dispatch, device, pInfo, pData);
    return ret;
  }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetScreenBufferPropertiesQNX(*dispatch, device, buffer, pProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreCounterValue(*dispatch, device, semaphore, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreCounterValueKHR(*dispatch, device, semaphore, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreFdKHR(*dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreWin32HandleKHR(*dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreZirconHandleFUCHSIA(*dispatch, device, pGetZirconHandleInfo, pZirconHandle);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetShaderBinaryDataEXT(*dispatch, device, shader, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetShaderInfoAMD(*dispatch, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetShaderModuleCreateInfoIdentifierEXT(*dispatch, device, pCreateInfo, pIdentifier);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetShaderModuleIdentifierEXT(*dispatch, device, shaderModule, pIdentifier);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainCounterEXT(*dispatch, device, swapchain, counter, pCounterValue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainImagesKHR(*dispatch, device, swapchain, pSwapchainImageCount, pSwapchainImages);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainStatusKHR(*dispatch, device, swapchain);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::GetTensorMemoryRequirementsARM(*dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetTensorOpaqueCaptureDescriptorDataARM(*dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetTensorViewOpaqueCaptureDescriptorDataARM(*dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetValidationCacheDataEXT(*dispatch, device, validationCache, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::GetVideoSessionMemoryRequirementsKHR(*dispatch, device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ImportFenceFdKHR(*dispatch, device, pImportFenceFdInfo);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ImportFenceWin32HandleKHR(*dispatch, device, pImportFenceWin32HandleInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreFdKHR(*dispatch, device, pImportSemaphoreFdInfo);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreWin32HandleKHR(*dispatch, device, pImportSemaphoreWin32HandleInfo);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreZirconHandleFUCHSIA(*dispatch, device, pImportSemaphoreZirconHandleInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::InitializePerformanceApiINTEL(*dispatch, device, pInitializeInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::InvalidateMappedMemoryRanges(*dispatch, device, memoryRangeCount, pMemoryRanges);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::LatencySleepNV(*dispatch, device, swapchain, pSleepInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::MapMemory(*dispatch, device, memory, offset, size, flags, ppData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::MapMemory2KHR(*dispatch, device, pMemoryMapInfo, ppData);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::MergePipelineCaches(*dispatch, device, dstCache, srcCacheCount, pSrcCaches);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::MergeValidationCachesEXT(*dispatch, device, dstCache, srcCacheCount, pSrcCaches);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::QueueBeginDebugUtilsLabelEXT(*dispatch, queue, pLabelInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueBindSparse(*dispatch, queue, bindInfoCount, pBindInfo, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_QueueEndDebugUtilsLabelEXT(VkQueue queue) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::QueueEndDebugUtilsLabelEXT(*dispatch, queue);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::QueueInsertDebugUtilsLabelEXT(*dispatch, queue, pLabelInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    DeviceOverrides::QueueNotifyOutOfBandNV(*dispatch, queue, pQueueTypeInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueuePresentKHR(*dispatch, queue, pPresentInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSetPerformanceConfigurationINTEL(*dispatch, queue, configuration);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit(*dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit2(*dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit2KHR(*dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueWaitIdle(VkQueue queue) {
    const VkQueueDispatch* dispatch = LookupDispatch(queue);
    VkResult ret = DeviceOverrides::QueueWaitIdle(*dispatch, queue);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::RegisterDeviceEventEXT(*dispatch, device, pDeviceEventInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::RegisterDisplayEventEXT(*dispatch, device, display, pDisplayEventInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseCapturedPipelineDataKHR(*dispatch, device, pInfo, pAllocator);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseFullScreenExclusiveModeEXT(*dispatch, device, swapchain);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ReleasePerformanceConfigurationINTEL(*dispatch, device, configuration);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_ReleaseProfilingLockKHR(VkDevice device) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::ReleaseProfilingLockKHR(*dispatch, device);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseSwapchainImagesEXT(*dispatch, device, pReleaseInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseSwapchainImagesKHR(*dispatch, device, pReleaseInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
    const VkCommandBufferDispatch* dispatch = LookupDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::ResetCommandBuffer(*dispatch, commandBuffer, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ResetCommandPool(*dispatch, device, commandPool, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ResetDescriptorPool(*dispatch, device, descriptorPool, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetEvent(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ResetEvent(*dispatch, device, event);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::ResetFences(*dispatch, device, fenceCount, pFences);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::ResetQueryPool(*dispatch, device, queryPool, firstQuery, queryCount);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::ResetQueryPoolEXT(*dispatch, device, queryPool, firstQuery, queryCount);
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetBufferCollectionBufferConstraintsFUCHSIA(*dispatch, device, collection, pBufferConstraintsInfo);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetBufferCollectionImageConstraintsFUCHSIA(*dispatch, device, collection, pImageConstraintsInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetDebugUtilsObjectNameEXT(*dispatch, device, pNameInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetDebugUtilsObjectTagEXT(*dispatch, device, pTagInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::SetDeviceMemoryPriorityEXT(*dispatch, device, memory, priority);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetEvent(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetEvent(*dispatch, device, event);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::SetHdrMetadataEXT(*dispatch, device, swapchainCount, pSwapchains, pMetadata);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::SetLatencyMarkerNV(*dispatch, device, swapchain, pLatencyMarkerInfo);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetLatencySleepModeNV(*dispatch, device, swapchain, pSleepModeInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::SetLocalDimmingAMD(*dispatch, device, swapChain, localDimmingEnable);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetPrivateData(*dispatch, device, objectType, objectHandle, privateDataSlot, data);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SetPrivateDataEXT(*dispatch, device, objectType, objectHandle, privateDataSlot, data);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SignalSemaphore(*dispatch, device, pSignalInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::SignalSemaphoreKHR(*dispatch, device, pSignalInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::TransitionImageLayoutEXT(*dispatch, device, transitionCount, pTransitions);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::TrimCommandPool(*dispatch, device, commandPool, flags);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::TrimCommandPoolKHR(*dispatch, device, commandPool, flags);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UninitializePerformanceApiINTEL(VkDevice device) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UninitializePerformanceApiINTEL(*dispatch, device);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UnmapMemory(VkDevice device, VkDeviceMemory memory) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UnmapMemory(*dispatch, device, memory);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::UnmapMemory2KHR(*dispatch, device, pMemoryUnmapInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UpdateDescriptorSetWithTemplate(*dispatch, device, descriptorSet, descriptorUpdateTemplate, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UpdateDescriptorSetWithTemplateKHR(*dispatch, device, descriptorSet, descriptorUpdateTemplate, pData);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UpdateDescriptorSets(*dispatch, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UpdateIndirectExecutionSetPipelineEXT(*dispatch, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static void wrap_UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    DeviceOverrides::UpdateIndirectExecutionSetShaderEXT(*dispatch, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::UpdateVideoSessionParametersKHR(*dispatch, device, videoSessionParameters, pUpdateInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WaitForFences(*dispatch, device, fenceCount, pFences, waitAll, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WaitForPresent2KHR(*dispatch, device, swapchain, pPresentWait2Info);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WaitForPresentKHR(*dispatch, device, swapchain, presentId, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WaitSemaphores(*dispatch, device, pWaitInfo, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WaitSemaphoresKHR(*dispatch, device, pWaitInfo, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WriteAccelerationStructuresPropertiesKHR(*dispatch, device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static VkResult wrap_WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
    VkResult ret = DeviceOverrides::WriteMicromapsPropertiesEXT(*dispatch, device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
    return ret;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char* name) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    constexpr bool HasAcquireDrmDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireDrmDisplayEXT; };
    if constexpr (HasAcquireDrmDisplayEXT) {
      if (!std::strcmp("vkAcquireDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireDrmDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasAcquireWinrtDisplayNV = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireWinrtDisplayNV; };
    if constexpr (HasAcquireWinrtDisplayNV) {
      if (!std::strcmp("vkAcquireWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_AcquireWinrtDisplayNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasAcquireXlibDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireXlibDisplayEXT; };
    if constexpr (HasAcquireXlibDisplayEXT) {
      if (!std::strcmp("vkAcquireXlibDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireXlibDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasCreateAndroidSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateAndroidSurfaceKHR; };
    if constexpr (HasCreateAndroidSurfaceKHR) {
      if (!std::strcmp("vkCreateAndroidSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateAndroidSurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDebugReportCallbackEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDebugReportCallbackEXT; };
    if constexpr (HasCreateDebugReportCallbackEXT) {
      if (!std::strcmp("vkCreateDebugReportCallbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDebugReportCallbackEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDebugUtilsMessengerEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDebugUtilsMessengerEXT; };
    if constexpr (HasCreateDebugUtilsMessengerEXT) {
      if (!std::strcmp("vkCreateDebugUtilsMessengerEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDebugUtilsMessengerEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDevice = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDevice; };
    if constexpr (HasCreateDevice) {
      if (!std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) &wrap_CreateDevice<InstanceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) +[](VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) -> VkResult { const auto* dispatch = LookupDispatch(physicalDevice); return dispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); };
    }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    constexpr bool HasCreateDirectFBSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDirectFBSurfaceEXT; };
    if constexpr (HasCreateDirectFBSurfaceEXT) {
      if (!std::strcmp("vkCreateDirectFBSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDirectFBSurfaceEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDisplayModeKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDisplayModeKHR; };
    if constexpr (HasCreateDisplayModeKHR) {
      if (!std::strcmp("vkCreateDisplayModeKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDisplayModeKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDisplayPlaneSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDisplayPlaneSurfaceKHR; };
    if constexpr (HasCreateDisplayPlaneSurfaceKHR) {
      if (!std::strcmp("vkCreateDisplayPlaneSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDisplayPlaneSurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateHeadlessSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateHeadlessSurfaceEXT; };
    if constexpr (HasCreateHeadlessSurfaceEXT) {
      if (!std::strcmp("vkCreateHeadlessSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateHeadlessSurfaceEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_IOS_MVK
    constexpr bool HasCreateIOSSurfaceMVK = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateIOSSurfaceMVK; };
    if constexpr (HasCreateIOSSurfaceMVK) {
      if (!std::strcmp("vkCreateIOSSurfaceMVK", name))
        return (PFN_vkVoidFunction) &wrap_CreateIOSSurfaceMVK<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasCreateImagePipeSurfaceFUCHSIA = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateImagePipeSurfaceFUCHSIA; };
    if constexpr (HasCreateImagePipeSurfaceFUCHSIA) {
      if (!std::strcmp("vkCreateImagePipeSurfaceFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_CreateImagePipeSurfaceFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateInstance = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateInstance; };
    if constexpr (HasCreateInstance) {
      if (!std::strcmp("vkCreateInstance", name))
        return (PFN_vkVoidFunction) &wrap_CreateInstance<InstanceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::strcmp("vkCreateInstance", name))
        return (PFN_vkVoidFunction) &implicit_wrap_CreateInstance;
    }

#ifdef VK_USE_PLATFORM_MACOS_MVK
    constexpr bool HasCreateMacOSSurfaceMVK = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateMacOSSurfaceMVK; };
    if constexpr (HasCreateMacOSSurfaceMVK) {
      if (!std::strcmp("vkCreateMacOSSurfaceMVK", name))
        return (PFN_vkVoidFunction) &wrap_CreateMacOSSurfaceMVK<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasCreateMetalSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateMetalSurfaceEXT; };
    if constexpr (HasCreateMetalSurfaceEXT) {
      if (!std::strcmp("vkCreateMetalSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateMetalSurfaceEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasCreateScreenSurfaceQNX = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateScreenSurfaceQNX; };
    if constexpr (HasCreateScreenSurfaceQNX) {
      if (!std::strcmp("vkCreateScreenSurfaceQNX", name))
        return (PFN_vkVoidFunction) &wrap_CreateScreenSurfaceQNX<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_GGP
    constexpr bool HasCreateStreamDescriptorSurfaceGGP = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateStreamDescriptorSurfaceGGP; };
    if constexpr (HasCreateStreamDescriptorSurfaceGGP) {
      if (!std::strcmp("vkCreateStreamDescriptorSurfaceGGP", name))
        return (PFN_vkVoidFunction) &wrap_CreateStreamDescriptorSurfaceGGP<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_OHOS
    constexpr bool HasCreateSurfaceOHOS = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateSurfaceOHOS; };
    if constexpr (HasCreateSurfaceOHOS) {
      if (!std::strcmp("vkCreateSurfaceOHOS", name))
        return (PFN_vkVoidFunction) &wrap_CreateSurfaceOHOS<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_VI_NN
    constexpr bool HasCreateViSurfaceNN = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateViSurfaceNN; };
    if constexpr (HasCreateViSurfaceNN) {
      if (!std::strcmp("vkCreateViSurfaceNN", name))
        return (PFN_vkVoidFunction) &wrap_CreateViSurfaceNN<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    constexpr bool HasCreateWaylandSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateWaylandSurfaceKHR; };
    if constexpr (HasCreateWaylandSurfaceKHR) {
      if (!std::strcmp("vkCreateWaylandSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateWaylandSurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasCreateWin32SurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateWin32SurfaceKHR; };
    if constexpr (HasCreateWin32SurfaceKHR) {
      if (!std::strcmp("vkCreateWin32SurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateWin32SurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
    constexpr bool HasCreateXcbSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateXcbSurfaceKHR; };
    if constexpr (HasCreateXcbSurfaceKHR) {
      if (!std::strcmp("vkCreateXcbSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateXcbSurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
    constexpr bool HasCreateXlibSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateXlibSurfaceKHR; };
    if constexpr (HasCreateXlibSurfaceKHR) {
      if (!std::strcmp("vkCreateXlibSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateXlibSurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDebugReportMessageEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DebugReportMessageEXT; };
    if constexpr (HasDebugReportMessageEXT) {
      if (!std::strcmp("vkDebugReportMessageEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugReportMessageEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDebugReportCallbackEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyDebugReportCallbackEXT; };
    if constexpr (HasDestroyDebugReportCallbackEXT) {
      if (!std::strcmp("vkDestroyDebugReportCallbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDebugReportCallbackEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDebugUtilsMessengerEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyDebugUtilsMessengerEXT; };
    if constexpr (HasDestroyDebugUtilsMessengerEXT) {
      if (!std::strcmp("vkDestroyDebugUtilsMessengerEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDebugUtilsMessengerEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyInstance = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyInstance; };
    if constexpr (HasDestroyInstance) {
      if (!std::strcmp("vkDestroyInstance", name))
        return (PFN_vkVoidFunction) &wrap_DestroyInstance<InstanceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::strcmp("vkDestroyInstance", name))
        return (PFN_vkVoidFunction) +[](VkInstance instance, const VkAllocationCallbacks *pAllocator) -> void { const auto* dispatch = LookupDispatch(instance); dispatch->DestroyInstance(instance, pAllocator); };
    }

    constexpr bool HasDestroySurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroySurfaceKHR; };
    if constexpr (HasDestroySurfaceKHR) {
      if (!std::strcmp("vkDestroySurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySurfaceKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceExtensionProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceExtensionProperties; };
    if constexpr (HasEnumerateDeviceExtensionProperties) {
      if (!std::strcmp("vkEnumerateDeviceExtensionProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceExtensionProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceLayerProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceLayerProperties; };
    if constexpr (HasEnumerateDeviceLayerProperties) {
      if (!std::strcmp("vkEnumerateDeviceLayerProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceLayerProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceGroups = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceGroups; };
    if constexpr (HasEnumeratePhysicalDeviceGroups) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceGroups", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceGroups<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceGroupsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceGroupsKHR; };
    if constexpr (HasEnumeratePhysicalDeviceGroupsKHR) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceGroupsKHR", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceGroupsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR; };
    if constexpr (HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDevices = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDevices; };
    if constexpr (HasEnumeratePhysicalDevices) {
      if (!std::strcmp("vkEnumeratePhysicalDevices", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDevices<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModeProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayModeProperties2KHR; };
    if constexpr (HasGetDisplayModeProperties2KHR) {
      if (!std::strcmp("vkGetDisplayModeProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModeProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayModePropertiesKHR; };
    if constexpr (HasGetDisplayModePropertiesKHR) {
      if (!std::strcmp("vkGetDisplayModePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilities2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneCapabilities2KHR; };
    if constexpr (HasGetDisplayPlaneCapabilities2KHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilities2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneCapabilitiesKHR; };
    if constexpr (HasGetDisplayPlaneCapabilitiesKHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneSupportedDisplaysKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneSupportedDisplaysKHR; };
    if constexpr (HasGetDisplayPlaneSupportedDisplaysKHR) {
      if (!std::strcmp("vkGetDisplayPlaneSupportedDisplaysKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneSupportedDisplaysKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDrmDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDrmDisplayEXT; };
    if constexpr (HasGetDrmDisplayEXT) {
      if (!std::strcmp("vkGetDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDrmDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

    if (!std::strcmp("vkGetInstanceProcAddr", name))
      return (PFN_vkVoidFunction) &GetInstanceProcAddr<InstanceOverrides, DeviceOverrides>;

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsEXT; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsKHR; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeVectorPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeVectorPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeVectorPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeVectorPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeVectorPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    constexpr bool HasGetPhysicalDeviceDirectFBPresentationSupportEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDirectFBPresentationSupportEXT; };
    if constexpr (HasGetPhysicalDeviceDirectFBPresentationSupportEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceDirectFBPresentationSupportEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDirectFBPresentationSupportEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceDisplayPlaneProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPlaneProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlaneProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlaneProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayPlanePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPlanePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlanePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlanePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalBufferProperties; };
    if constexpr (HasGetPhysicalDeviceExternalBufferProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalBufferPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalBufferPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFenceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalFenceProperties; };
    if constexpr (HasGetPhysicalDeviceExternalFenceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFenceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFenceProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFencePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalFencePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalFencePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFencePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFencePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalImageFormatPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalImageFormatPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceExternalImageFormatPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalImageFormatPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphoreProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalSemaphoreProperties; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphoreProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphoreProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphoreProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphorePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalSemaphorePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphorePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphorePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalTensorPropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalTensorPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceExternalTensorPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalTensorPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalTensorPropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures; };
    if constexpr (HasGetPhysicalDeviceFeatures) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures2; };
    if constexpr (HasGetPhysicalDeviceFeatures2) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures2KHR; };
    if constexpr (HasGetPhysicalDeviceFeatures2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties; };
    if constexpr (HasGetPhysicalDeviceFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFragmentShadingRatesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFragmentShadingRatesKHR; };
    if constexpr (HasGetPhysicalDeviceFragmentShadingRatesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFragmentShadingRatesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFragmentShadingRatesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties2; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMultisamplePropertiesEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMultisamplePropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceMultisamplePropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceMultisamplePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMultisamplePropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceOpticalFlowImageFormatsNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceOpticalFlowImageFormatsNV; };
    if constexpr (HasGetPhysicalDeviceOpticalFlowImageFormatsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceOpticalFlowImageFormatsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDevicePresentRectanglesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDevicePresentRectanglesKHR; };
    if constexpr (HasGetPhysicalDevicePresentRectanglesKHR) {
      if (!std::strcmp("vkGetPhysicalDevicePresentRectanglesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDevicePresentRectanglesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties; };
    if constexpr (HasGetPhysicalDeviceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties2; };
    if constexpr (HasGetPhysicalDeviceProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasGetPhysicalDeviceScreenPresentationSupportQNX = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceScreenPresentationSupportQNX; };
    if constexpr (HasGetPhysicalDeviceScreenPresentationSupportQNX) {
      if (!std::strcmp("vkGetPhysicalDeviceScreenPresentationSupportQNX", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceScreenPresentationSupportQNX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV; };
    if constexpr (HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2EXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormats2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormats2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormats2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormats2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormats2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormatsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormatsKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormatsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormatsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormatsKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceSurfacePresentModes2EXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfacePresentModes2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModes2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModes2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModes2EXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceSurfacePresentModesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfacePresentModesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceSupportKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceSupportKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceToolProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceToolProperties; };
    if constexpr (HasGetPhysicalDeviceToolProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceToolProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceToolPropertiesEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceToolPropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceToolPropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceToolPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoFormatPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoFormatPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoFormatPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoFormatPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoFormatPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    constexpr bool HasGetPhysicalDeviceWaylandPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWaylandPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWaylandPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWaylandPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWaylandPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceWin32PresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWin32PresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWin32PresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWin32PresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWin32PresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
    constexpr bool HasGetPhysicalDeviceXcbPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXcbPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXcbPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXcbPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXcbPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
    constexpr bool HasGetPhysicalDeviceXlibPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXlibPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXlibPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXlibPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXlibPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasGetRandROutputDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetRandROutputDisplayEXT; };
    if constexpr (HasGetRandROutputDisplayEXT) {
      if (!std::strcmp("vkGetRandROutputDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetRandROutputDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetWinrtDisplayNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetWinrtDisplayNV; };
    if constexpr (HasGetWinrtDisplayNV) {
      if (!std::strcmp("vkGetWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_GetWinrtDisplayNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasReleaseDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::ReleaseDisplayEXT; };
    if constexpr (HasReleaseDisplayEXT) {
      if (!std::strcmp("vkReleaseDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSubmitDebugUtilsMessageEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::SubmitDebugUtilsMessageEXT; };
    if constexpr (HasSubmitDebugUtilsMessageEXT) {
      if (!std::strcmp("vkSubmitDebugUtilsMessageEXT", name))
        return (PFN_vkVoidFunction) &wrap_SubmitDebugUtilsMessageEXT<InstanceOverrides, DeviceOverrides>;
    }

    if (!std::strcmp("vk_layerGetPhysicalDeviceProcAddr", name))
      return (PFN_vkVoidFunction) &GetPhysicalDeviceProcAddr<InstanceOverrides, DeviceOverrides>;

    if (dispatch)
      return dispatch->GetInstanceProcAddr(instance, name);
    else
      return NULL;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetPhysicalDeviceProcAddr(VkInstance instance, const char* name) {
    const VkInstanceDispatch* dispatch = LookupDispatch(instance);
    constexpr bool HasAcquireDrmDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireDrmDisplayEXT; };
    if constexpr (HasAcquireDrmDisplayEXT) {
      if (!std::strcmp("vkAcquireDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireDrmDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasAcquireWinrtDisplayNV = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireWinrtDisplayNV; };
    if constexpr (HasAcquireWinrtDisplayNV) {
      if (!std::strcmp("vkAcquireWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_AcquireWinrtDisplayNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasAcquireXlibDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::AcquireXlibDisplayEXT; };
    if constexpr (HasAcquireXlibDisplayEXT) {
      if (!std::strcmp("vkAcquireXlibDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireXlibDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDevice = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDevice; };
    if constexpr (HasCreateDevice) {
      if (!std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) &wrap_CreateDevice<InstanceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) +[](VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) -> VkResult { const auto* dispatch = LookupDispatch(physicalDevice); return dispatch->CreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice); };
    }

    constexpr bool HasCreateDisplayModeKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDisplayModeKHR; };
    if constexpr (HasCreateDisplayModeKHR) {
      if (!std::strcmp("vkCreateDisplayModeKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDisplayModeKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceExtensionProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceExtensionProperties; };
    if constexpr (HasEnumerateDeviceExtensionProperties) {
      if (!std::strcmp("vkEnumerateDeviceExtensionProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceExtensionProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceLayerProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceLayerProperties; };
    if constexpr (HasEnumerateDeviceLayerProperties) {
      if (!std::strcmp("vkEnumerateDeviceLayerProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceLayerProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR; };
    if constexpr (HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModeProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayModeProperties2KHR; };
    if constexpr (HasGetDisplayModeProperties2KHR) {
      if (!std::strcmp("vkGetDisplayModeProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModeProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayModePropertiesKHR; };
    if constexpr (HasGetDisplayModePropertiesKHR) {
      if (!std::strcmp("vkGetDisplayModePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilities2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneCapabilities2KHR; };
    if constexpr (HasGetDisplayPlaneCapabilities2KHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilities2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneCapabilitiesKHR; };
    if constexpr (HasGetDisplayPlaneCapabilitiesKHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneSupportedDisplaysKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneSupportedDisplaysKHR; };
    if constexpr (HasGetDisplayPlaneSupportedDisplaysKHR) {
      if (!std::strcmp("vkGetDisplayPlaneSupportedDisplaysKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneSupportedDisplaysKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDrmDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDrmDisplayEXT; };
    if constexpr (HasGetDrmDisplayEXT) {
      if (!std::strcmp("vkGetDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDrmDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsEXT; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsKHR; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeVectorPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceCooperativeVectorPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeVectorPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeVectorPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeVectorPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    constexpr bool HasGetPhysicalDeviceDirectFBPresentationSupportEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDirectFBPresentationSupportEXT; };
    if constexpr (HasGetPhysicalDeviceDirectFBPresentationSupportEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceDirectFBPresentationSupportEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDirectFBPresentationSupportEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceDisplayPlaneProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPlaneProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlaneProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlaneProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayPlanePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPlanePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlanePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlanePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalBufferProperties; };
    if constexpr (HasGetPhysicalDeviceExternalBufferProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalBufferPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalBufferPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFenceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalFenceProperties; };
    if constexpr (HasGetPhysicalDeviceExternalFenceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFenceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFenceProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFencePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalFencePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalFencePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFencePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFencePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalImageFormatPropertiesNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalImageFormatPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceExternalImageFormatPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalImageFormatPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphoreProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalSemaphoreProperties; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphoreProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphoreProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphoreProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphorePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalSemaphorePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphorePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphorePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalTensorPropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalTensorPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceExternalTensorPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalTensorPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalTensorPropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures; };
    if constexpr (HasGetPhysicalDeviceFeatures) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures2; };
    if constexpr (HasGetPhysicalDeviceFeatures2) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures2KHR; };
    if constexpr (HasGetPhysicalDeviceFeatures2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties; };
    if constexpr (HasGetPhysicalDeviceFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFragmentShadingRatesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFragmentShadingRatesKHR; };
    if constexpr (HasGetPhysicalDeviceFragmentShadingRatesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFragmentShadingRatesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFragmentShadingRatesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties2; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMultisamplePropertiesEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMultisamplePropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceMultisamplePropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceMultisamplePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMultisamplePropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceOpticalFlowImageFormatsNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceOpticalFlowImageFormatsNV; };
    if constexpr (HasGetPhysicalDeviceOpticalFlowImageFormatsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceOpticalFlowImageFormatsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDevicePresentRectanglesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDevicePresentRectanglesKHR; };
    if constexpr (HasGetPhysicalDevicePresentRectanglesKHR) {
      if (!std::strcmp("vkGetPhysicalDevicePresentRectanglesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDevicePresentRectanglesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties; };
    if constexpr (HasGetPhysicalDeviceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties2; };
    if constexpr (HasGetPhysicalDeviceProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasGetPhysicalDeviceScreenPresentationSupportQNX = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceScreenPresentationSupportQNX; };
    if constexpr (HasGetPhysicalDeviceScreenPresentationSupportQNX) {
      if (!std::strcmp("vkGetPhysicalDeviceScreenPresentationSupportQNX", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceScreenPresentationSupportQNX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV; };
    if constexpr (HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2EXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormats2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormats2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormats2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormats2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormats2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormatsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormatsKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormatsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormatsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormatsKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceSurfacePresentModes2EXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfacePresentModes2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModes2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModes2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModes2EXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceSurfacePresentModesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfacePresentModesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceSupportKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceSupportKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceToolProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceToolProperties; };
    if constexpr (HasGetPhysicalDeviceToolProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceToolProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolProperties<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceToolPropertiesEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceToolPropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceToolPropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceToolPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoFormatPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceVideoFormatPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoFormatPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoFormatPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoFormatPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    constexpr bool HasGetPhysicalDeviceWaylandPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWaylandPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWaylandPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWaylandPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWaylandPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceWin32PresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWin32PresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWin32PresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWin32PresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWin32PresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
    constexpr bool HasGetPhysicalDeviceXcbPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXcbPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXcbPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXcbPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXcbPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
    constexpr bool HasGetPhysicalDeviceXlibPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXlibPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXlibPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXlibPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXlibPresentationSupportKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasGetRandROutputDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::GetRandROutputDisplayEXT; };
    if constexpr (HasGetRandROutputDisplayEXT) {
      if (!std::strcmp("vkGetRandROutputDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetRandROutputDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetWinrtDisplayNV = requires(const InstanceOverrides& t) { &InstanceOverrides::GetWinrtDisplayNV; };
    if constexpr (HasGetWinrtDisplayNV) {
      if (!std::strcmp("vkGetWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_GetWinrtDisplayNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasReleaseDisplayEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::ReleaseDisplayEXT; };
    if constexpr (HasReleaseDisplayEXT) {
      if (!std::strcmp("vkReleaseDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseDisplayEXT<InstanceOverrides, DeviceOverrides>;
    }

    if (dispatch)
      return dispatch->GetPhysicalDeviceProcAddr(instance, name);
    else
      return NULL;
  }

  template <typename InstanceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char* name) {
    const VkDeviceDispatch* dispatch = LookupDispatch(device);
#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasAcquireFullScreenExclusiveModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireFullScreenExclusiveModeEXT; };
    if constexpr (HasAcquireFullScreenExclusiveModeEXT) {
      if (!std::strcmp("vkAcquireFullScreenExclusiveModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireFullScreenExclusiveModeEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasAcquireNextImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireNextImage2KHR; };
    if constexpr (HasAcquireNextImage2KHR) {
      if (!std::strcmp("vkAcquireNextImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireNextImage2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquireNextImageKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireNextImageKHR; };
    if constexpr (HasAcquireNextImageKHR) {
      if (!std::strcmp("vkAcquireNextImageKHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireNextImageKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquirePerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquirePerformanceConfigurationINTEL; };
    if constexpr (HasAcquirePerformanceConfigurationINTEL) {
      if (!std::strcmp("vkAcquirePerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_AcquirePerformanceConfigurationINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquireProfilingLockKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireProfilingLockKHR; };
    if constexpr (HasAcquireProfilingLockKHR) {
      if (!std::strcmp("vkAcquireProfilingLockKHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireProfilingLockKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAllocateCommandBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateCommandBuffers; };
    if constexpr (HasAllocateCommandBuffers) {
      if (!std::strcmp("vkAllocateCommandBuffers", name))
        return (PFN_vkVoidFunction) &wrap_AllocateCommandBuffers<InstanceOverrides, DeviceOverrides>;
    }
    else {
      constexpr bool HasAnyCmdBufferOverrides = false
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::BeginCommandBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginConditionalRenderingEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginPerTileExecutionQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQuery; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQueryIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRendering; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginTransformFeedbackEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBuffersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindInvocationMaskHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipeline; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipelineShaderGroupNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadingRateImageNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTileMemoryQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTransformFeedbackBuffersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructureNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildMicromapsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearAttachments; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearColorImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearDepthStencilImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdControlVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdConvertCooperativeVectorMatrixNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToImageIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToMicromapEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapToMemoryEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyQueryPoolResults; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyTensorARM; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCudaLaunchKernelNV; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerBeginEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerEndEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerInsertEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecodeVideoKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryIndirectCountNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatch; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBase; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBaseKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchDataGraphARM; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphAMDX; } )
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectAMDX; } )
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectCountAMDX; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchTileQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDraw; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterIndirectHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexed; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectByteCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEncodeVideoKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndConditionalRenderingEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndPerTileExecutionQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQuery; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQueryIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndTransformFeedbackEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteCommands; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdFillBuffer; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInsertDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdOpticalFlowExecuteNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSet2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetQueryPool; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToCoverageEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToOneEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetBlendConstants; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCheckpointNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoarseSampleOrderNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendAdvancedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEquationEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteMaskEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetConservativeRasterizationModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationModeNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageReductionModeNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorLocationNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullMode; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBounds; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampRangeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMaskKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateEnumNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFace; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFaceEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineRasterizationModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineWidth; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPatchControlPointsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceMarkerINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceOverrideINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPolygonModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopology; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopologyEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetProvokingVertexModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationSamplesEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationStreamEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleMaskEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissor; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetShadingRateImageEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilCompareMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilReference; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilWriteMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetTessellationDomainOriginEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetVertexInputEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewport; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportShadingRatePaletteNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportSwizzleNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSubpassShadingHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirect2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirectKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdateBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdatePipelineIndirectBufferNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarker2AMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarkerAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteMicromapsPropertiesEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::EndCommandBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandBuffer; } )
        ;
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && HasAnyCmdBufferOverrides && !std::strcmp("vkAllocateCommandBuffers", name))
        return (PFN_vkVoidFunction) +[](VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) -> VkResult { const auto* dispatch = LookupDispatch(device); return dispatch->AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers); };
    }

    constexpr bool HasAllocateDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateDescriptorSets; };
    if constexpr (HasAllocateDescriptorSets) {
      if (!std::strcmp("vkAllocateDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_AllocateDescriptorSets<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAllocateMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateMemory; };
    if constexpr (HasAllocateMemory) {
      if (!std::strcmp("vkAllocateMemory", name))
        return (PFN_vkVoidFunction) &wrap_AllocateMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAntiLagUpdateAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::AntiLagUpdateAMD; };
    if constexpr (HasAntiLagUpdateAMD) {
      if (!std::strcmp("vkAntiLagUpdateAMD", name))
        return (PFN_vkVoidFunction) &wrap_AntiLagUpdateAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBeginCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::BeginCommandBuffer; };
    if constexpr (HasBeginCommandBuffer) {
      if (!std::strcmp("vkBeginCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_BeginCommandBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindAccelerationStructureMemoryNV = requires(const DeviceOverrides& t) { &DeviceOverrides::BindAccelerationStructureMemoryNV; };
    if constexpr (HasBindAccelerationStructureMemoryNV) {
      if (!std::strcmp("vkBindAccelerationStructureMemoryNV", name))
        return (PFN_vkVoidFunction) &wrap_BindAccelerationStructureMemoryNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory; };
    if constexpr (HasBindBufferMemory) {
      if (!std::strcmp("vkBindBufferMemory", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory2 = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory2; };
    if constexpr (HasBindBufferMemory2) {
      if (!std::strcmp("vkBindBufferMemory2", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory2KHR; };
    if constexpr (HasBindBufferMemory2KHR) {
      if (!std::strcmp("vkBindBufferMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindDataGraphPipelineSessionMemoryARM = requires(const DeviceOverrides& t) { &DeviceOverrides::BindDataGraphPipelineSessionMemoryARM; };
    if constexpr (HasBindDataGraphPipelineSessionMemoryARM) {
      if (!std::strcmp("vkBindDataGraphPipelineSessionMemoryARM", name))
        return (PFN_vkVoidFunction) &wrap_BindDataGraphPipelineSessionMemoryARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory; };
    if constexpr (HasBindImageMemory) {
      if (!std::strcmp("vkBindImageMemory", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory2 = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory2; };
    if constexpr (HasBindImageMemory2) {
      if (!std::strcmp("vkBindImageMemory2", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory2KHR; };
    if constexpr (HasBindImageMemory2KHR) {
      if (!std::strcmp("vkBindImageMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindOpticalFlowSessionImageNV = requires(const DeviceOverrides& t) { &DeviceOverrides::BindOpticalFlowSessionImageNV; };
    if constexpr (HasBindOpticalFlowSessionImageNV) {
      if (!std::strcmp("vkBindOpticalFlowSessionImageNV", name))
        return (PFN_vkVoidFunction) &wrap_BindOpticalFlowSessionImageNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindTensorMemoryARM = requires(const DeviceOverrides& t) { &DeviceOverrides::BindTensorMemoryARM; };
    if constexpr (HasBindTensorMemoryARM) {
      if (!std::strcmp("vkBindTensorMemoryARM", name))
        return (PFN_vkVoidFunction) &wrap_BindTensorMemoryARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindVideoSessionMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindVideoSessionMemoryKHR; };
    if constexpr (HasBindVideoSessionMemoryKHR) {
      if (!std::strcmp("vkBindVideoSessionMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_BindVideoSessionMemoryKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBuildAccelerationStructuresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BuildAccelerationStructuresKHR; };
    if constexpr (HasBuildAccelerationStructuresKHR) {
      if (!std::strcmp("vkBuildAccelerationStructuresKHR", name))
        return (PFN_vkVoidFunction) &wrap_BuildAccelerationStructuresKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBuildMicromapsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::BuildMicromapsEXT; };
    if constexpr (HasBuildMicromapsEXT) {
      if (!std::strcmp("vkBuildMicromapsEXT", name))
        return (PFN_vkVoidFunction) &wrap_BuildMicromapsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginConditionalRenderingEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginConditionalRenderingEXT; };
    if constexpr (HasCmdBeginConditionalRenderingEXT) {
      if (!std::strcmp("vkCmdBeginConditionalRenderingEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginConditionalRenderingEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginDebugUtilsLabelEXT; };
    if constexpr (HasCmdBeginDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdBeginDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginPerTileExecutionQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginPerTileExecutionQCOM; };
    if constexpr (HasCmdBeginPerTileExecutionQCOM) {
      if (!std::strcmp("vkCmdBeginPerTileExecutionQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginPerTileExecutionQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginQuery = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQuery; };
    if constexpr (HasCmdBeginQuery) {
      if (!std::strcmp("vkCmdBeginQuery", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginQuery<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginQueryIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQueryIndexedEXT; };
    if constexpr (HasCmdBeginQueryIndexedEXT) {
      if (!std::strcmp("vkCmdBeginQueryIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginQueryIndexedEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass; };
    if constexpr (HasCmdBeginRenderPass) {
      if (!std::strcmp("vkCmdBeginRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2; };
    if constexpr (HasCmdBeginRenderPass2) {
      if (!std::strcmp("vkCmdBeginRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2KHR; };
    if constexpr (HasCmdBeginRenderPass2KHR) {
      if (!std::strcmp("vkCmdBeginRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRendering = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRendering; };
    if constexpr (HasCmdBeginRendering) {
      if (!std::strcmp("vkCmdBeginRendering", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRendering<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderingKHR; };
    if constexpr (HasCmdBeginRenderingKHR) {
      if (!std::strcmp("vkCmdBeginRenderingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderingKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginTransformFeedbackEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginTransformFeedbackEXT; };
    if constexpr (HasCmdBeginTransformFeedbackEXT) {
      if (!std::strcmp("vkCmdBeginTransformFeedbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginTransformFeedbackEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginVideoCodingKHR; };
    if constexpr (HasCmdBeginVideoCodingKHR) {
      if (!std::strcmp("vkCmdBeginVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginVideoCodingKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBufferEmbeddedSamplers2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT; };
    if constexpr (HasCmdBindDescriptorBufferEmbeddedSamplers2EXT) {
      if (!std::strcmp("vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBufferEmbeddedSamplers2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBufferEmbeddedSamplersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT; };
    if constexpr (HasCmdBindDescriptorBufferEmbeddedSamplersEXT) {
      if (!std::strcmp("vkCmdBindDescriptorBufferEmbeddedSamplersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBufferEmbeddedSamplersEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBuffersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBuffersEXT; };
    if constexpr (HasCmdBindDescriptorBuffersEXT) {
      if (!std::strcmp("vkCmdBindDescriptorBuffersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBuffersEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets; };
    if constexpr (HasCmdBindDescriptorSets) {
      if (!std::strcmp("vkCmdBindDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorSets<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorSets2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets2KHR; };
    if constexpr (HasCmdBindDescriptorSets2KHR) {
      if (!std::strcmp("vkCmdBindDescriptorSets2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorSets2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindIndexBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer; };
    if constexpr (HasCmdBindIndexBuffer) {
      if (!std::strcmp("vkCmdBindIndexBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindIndexBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindIndexBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer2KHR; };
    if constexpr (HasCmdBindIndexBuffer2KHR) {
      if (!std::strcmp("vkCmdBindIndexBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindIndexBuffer2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindInvocationMaskHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindInvocationMaskHUAWEI; };
    if constexpr (HasCmdBindInvocationMaskHUAWEI) {
      if (!std::strcmp("vkCmdBindInvocationMaskHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindInvocationMaskHUAWEI<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindPipeline = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipeline; };
    if constexpr (HasCmdBindPipeline) {
      if (!std::strcmp("vkCmdBindPipeline", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindPipeline<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindPipelineShaderGroupNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipelineShaderGroupNV; };
    if constexpr (HasCmdBindPipelineShaderGroupNV) {
      if (!std::strcmp("vkCmdBindPipelineShaderGroupNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindPipelineShaderGroupNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindShadersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadersEXT; };
    if constexpr (HasCmdBindShadersEXT) {
      if (!std::strcmp("vkCmdBindShadersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindShadersEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindShadingRateImageNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadingRateImageNV; };
    if constexpr (HasCmdBindShadingRateImageNV) {
      if (!std::strcmp("vkCmdBindShadingRateImageNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindShadingRateImageNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindTileMemoryQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTileMemoryQCOM; };
    if constexpr (HasCmdBindTileMemoryQCOM) {
      if (!std::strcmp("vkCmdBindTileMemoryQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindTileMemoryQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindTransformFeedbackBuffersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTransformFeedbackBuffersEXT; };
    if constexpr (HasCmdBindTransformFeedbackBuffersEXT) {
      if (!std::strcmp("vkCmdBindTransformFeedbackBuffersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindTransformFeedbackBuffersEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers; };
    if constexpr (HasCmdBindVertexBuffers) {
      if (!std::strcmp("vkCmdBindVertexBuffers", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2; };
    if constexpr (HasCmdBindVertexBuffers2) {
      if (!std::strcmp("vkCmdBindVertexBuffers2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2EXT; };
    if constexpr (HasCmdBindVertexBuffers2EXT) {
      if (!std::strcmp("vkCmdBindVertexBuffers2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage; };
    if constexpr (HasCmdBlitImage) {
      if (!std::strcmp("vkCmdBlitImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2; };
    if constexpr (HasCmdBlitImage2) {
      if (!std::strcmp("vkCmdBlitImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2KHR; };
    if constexpr (HasCmdBlitImage2KHR) {
      if (!std::strcmp("vkCmdBlitImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructureNV; };
    if constexpr (HasCmdBuildAccelerationStructureNV) {
      if (!std::strcmp("vkCmdBuildAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructureNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructuresIndirectKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR; };
    if constexpr (HasCmdBuildAccelerationStructuresIndirectKHR) {
      if (!std::strcmp("vkCmdBuildAccelerationStructuresIndirectKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructuresIndirectKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructuresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresKHR; };
    if constexpr (HasCmdBuildAccelerationStructuresKHR) {
      if (!std::strcmp("vkCmdBuildAccelerationStructuresKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructuresKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildClusterAccelerationStructureIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV; };
    if constexpr (HasCmdBuildClusterAccelerationStructureIndirectNV) {
      if (!std::strcmp("vkCmdBuildClusterAccelerationStructureIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildClusterAccelerationStructureIndirectNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildMicromapsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildMicromapsEXT; };
    if constexpr (HasCmdBuildMicromapsEXT) {
      if (!std::strcmp("vkCmdBuildMicromapsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildMicromapsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildPartitionedAccelerationStructuresNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV; };
    if constexpr (HasCmdBuildPartitionedAccelerationStructuresNV) {
      if (!std::strcmp("vkCmdBuildPartitionedAccelerationStructuresNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildPartitionedAccelerationStructuresNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearAttachments = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearAttachments; };
    if constexpr (HasCmdClearAttachments) {
      if (!std::strcmp("vkCmdClearAttachments", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearAttachments<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearColorImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearColorImage; };
    if constexpr (HasCmdClearColorImage) {
      if (!std::strcmp("vkCmdClearColorImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearColorImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearDepthStencilImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearDepthStencilImage; };
    if constexpr (HasCmdClearDepthStencilImage) {
      if (!std::strcmp("vkCmdClearDepthStencilImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearDepthStencilImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdControlVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdControlVideoCodingKHR; };
    if constexpr (HasCmdControlVideoCodingKHR) {
      if (!std::strcmp("vkCmdControlVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdControlVideoCodingKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdConvertCooperativeVectorMatrixNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdConvertCooperativeVectorMatrixNV; };
    if constexpr (HasCmdConvertCooperativeVectorMatrixNV) {
      if (!std::strcmp("vkCmdConvertCooperativeVectorMatrixNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdConvertCooperativeVectorMatrixNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureKHR; };
    if constexpr (HasCmdCopyAccelerationStructureKHR) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureNV; };
    if constexpr (HasCmdCopyAccelerationStructureNV) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureToMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR; };
    if constexpr (HasCmdCopyAccelerationStructureToMemoryKHR) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureToMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureToMemoryKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer; };
    if constexpr (HasCmdCopyBuffer) {
      if (!std::strcmp("vkCmdCopyBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2; };
    if constexpr (HasCmdCopyBuffer2) {
      if (!std::strcmp("vkCmdCopyBuffer2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2KHR; };
    if constexpr (HasCmdCopyBuffer2KHR) {
      if (!std::strcmp("vkCmdCopyBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage; };
    if constexpr (HasCmdCopyBufferToImage) {
      if (!std::strcmp("vkCmdCopyBufferToImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2; };
    if constexpr (HasCmdCopyBufferToImage2) {
      if (!std::strcmp("vkCmdCopyBufferToImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2KHR; };
    if constexpr (HasCmdCopyBufferToImage2KHR) {
      if (!std::strcmp("vkCmdCopyBufferToImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage; };
    if constexpr (HasCmdCopyImage) {
      if (!std::strcmp("vkCmdCopyImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2; };
    if constexpr (HasCmdCopyImage2) {
      if (!std::strcmp("vkCmdCopyImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2KHR; };
    if constexpr (HasCmdCopyImage2KHR) {
      if (!std::strcmp("vkCmdCopyImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer; };
    if constexpr (HasCmdCopyImageToBuffer) {
      if (!std::strcmp("vkCmdCopyImageToBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2; };
    if constexpr (HasCmdCopyImageToBuffer2) {
      if (!std::strcmp("vkCmdCopyImageToBuffer2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2KHR; };
    if constexpr (HasCmdCopyImageToBuffer2KHR) {
      if (!std::strcmp("vkCmdCopyImageToBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryIndirectNV; };
    if constexpr (HasCmdCopyMemoryIndirectNV) {
      if (!std::strcmp("vkCmdCopyMemoryIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryIndirectNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR; };
    if constexpr (HasCmdCopyMemoryToAccelerationStructureKHR) {
      if (!std::strcmp("vkCmdCopyMemoryToAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToImageIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToImageIndirectNV; };
    if constexpr (HasCmdCopyMemoryToImageIndirectNV) {
      if (!std::strcmp("vkCmdCopyMemoryToImageIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToImageIndirectNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToMicromapEXT; };
    if constexpr (HasCmdCopyMemoryToMicromapEXT) {
      if (!std::strcmp("vkCmdCopyMemoryToMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapEXT; };
    if constexpr (HasCmdCopyMicromapEXT) {
      if (!std::strcmp("vkCmdCopyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMicromapToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapToMemoryEXT; };
    if constexpr (HasCmdCopyMicromapToMemoryEXT) {
      if (!std::strcmp("vkCmdCopyMicromapToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMicromapToMemoryEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyQueryPoolResults = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyQueryPoolResults; };
    if constexpr (HasCmdCopyQueryPoolResults) {
      if (!std::strcmp("vkCmdCopyQueryPoolResults", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyQueryPoolResults<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyTensorARM; };
    if constexpr (HasCmdCopyTensorARM) {
      if (!std::strcmp("vkCmdCopyTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyTensorARM<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdCudaLaunchKernelNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCudaLaunchKernelNV; };
    if constexpr (HasCmdCudaLaunchKernelNV) {
      if (!std::strcmp("vkCmdCudaLaunchKernelNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCudaLaunchKernelNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdDebugMarkerBeginEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerBeginEXT; };
    if constexpr (HasCmdDebugMarkerBeginEXT) {
      if (!std::strcmp("vkCmdDebugMarkerBeginEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerBeginEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDebugMarkerEndEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerEndEXT; };
    if constexpr (HasCmdDebugMarkerEndEXT) {
      if (!std::strcmp("vkCmdDebugMarkerEndEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerEndEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDebugMarkerInsertEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerInsertEXT; };
    if constexpr (HasCmdDebugMarkerInsertEXT) {
      if (!std::strcmp("vkCmdDebugMarkerInsertEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerInsertEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecodeVideoKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecodeVideoKHR; };
    if constexpr (HasCmdDecodeVideoKHR) {
      if (!std::strcmp("vkCmdDecodeVideoKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecodeVideoKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecompressMemoryIndirectCountNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryIndirectCountNV; };
    if constexpr (HasCmdDecompressMemoryIndirectCountNV) {
      if (!std::strcmp("vkCmdDecompressMemoryIndirectCountNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecompressMemoryIndirectCountNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecompressMemoryNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryNV; };
    if constexpr (HasCmdDecompressMemoryNV) {
      if (!std::strcmp("vkCmdDecompressMemoryNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecompressMemoryNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatch = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatch; };
    if constexpr (HasCmdDispatch) {
      if (!std::strcmp("vkCmdDispatch", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatch<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchBase = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBase; };
    if constexpr (HasCmdDispatchBase) {
      if (!std::strcmp("vkCmdDispatchBase", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchBase<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchBaseKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBaseKHR; };
    if constexpr (HasCmdDispatchBaseKHR) {
      if (!std::strcmp("vkCmdDispatchBaseKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchBaseKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchDataGraphARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchDataGraphARM; };
    if constexpr (HasCmdDispatchDataGraphARM) {
      if (!std::strcmp("vkCmdDispatchDataGraphARM", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchDataGraphARM<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphAMDX; };
    if constexpr (HasCmdDispatchGraphAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphIndirectAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectAMDX; };
    if constexpr (HasCmdDispatchGraphIndirectAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphIndirectAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphIndirectAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphIndirectCountAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectCountAMDX; };
    if constexpr (HasCmdDispatchGraphIndirectCountAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphIndirectCountAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphIndirectCountAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdDispatchIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchIndirect; };
    if constexpr (HasCmdDispatchIndirect) {
      if (!std::strcmp("vkCmdDispatchIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchIndirect<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchTileQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchTileQCOM; };
    if constexpr (HasCmdDispatchTileQCOM) {
      if (!std::strcmp("vkCmdDispatchTileQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchTileQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDraw = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDraw; };
    if constexpr (HasCmdDraw) {
      if (!std::strcmp("vkCmdDraw", name))
        return (PFN_vkVoidFunction) &wrap_CmdDraw<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawClusterHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterHUAWEI; };
    if constexpr (HasCmdDrawClusterHUAWEI) {
      if (!std::strcmp("vkCmdDrawClusterHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawClusterHUAWEI<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawClusterIndirectHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterIndirectHUAWEI; };
    if constexpr (HasCmdDrawClusterIndirectHUAWEI) {
      if (!std::strcmp("vkCmdDrawClusterIndirectHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawClusterIndirectHUAWEI<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexed = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexed; };
    if constexpr (HasCmdDrawIndexed) {
      if (!std::strcmp("vkCmdDrawIndexed", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexed<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirect; };
    if constexpr (HasCmdDrawIndexedIndirect) {
      if (!std::strcmp("vkCmdDrawIndexedIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirect<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCount; };
    if constexpr (HasCmdDrawIndexedIndirectCount) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCount<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCountAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountAMD; };
    if constexpr (HasCmdDrawIndexedIndirectCountAMD) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCountAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCountAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCountKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountKHR; };
    if constexpr (HasCmdDrawIndexedIndirectCountKHR) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCountKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCountKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirect; };
    if constexpr (HasCmdDrawIndirect) {
      if (!std::strcmp("vkCmdDrawIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirect<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectByteCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectByteCountEXT; };
    if constexpr (HasCmdDrawIndirectByteCountEXT) {
      if (!std::strcmp("vkCmdDrawIndirectByteCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectByteCountEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCount; };
    if constexpr (HasCmdDrawIndirectCount) {
      if (!std::strcmp("vkCmdDrawIndirectCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCount<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCountAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountAMD; };
    if constexpr (HasCmdDrawIndirectCountAMD) {
      if (!std::strcmp("vkCmdDrawIndirectCountAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCountAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCountKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountKHR; };
    if constexpr (HasCmdDrawIndirectCountKHR) {
      if (!std::strcmp("vkCmdDrawIndirectCountKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCountKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksEXT; };
    if constexpr (HasCmdDrawMeshTasksEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT; };
    if constexpr (HasCmdDrawMeshTasksIndirectCountEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectCountEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectCountNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountNV; };
    if constexpr (HasCmdDrawMeshTasksIndirectCountNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectCountNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectCountNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectEXT; };
    if constexpr (HasCmdDrawMeshTasksIndirectEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectNV; };
    if constexpr (HasCmdDrawMeshTasksIndirectNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksNV; };
    if constexpr (HasCmdDrawMeshTasksNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMultiEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiEXT; };
    if constexpr (HasCmdDrawMultiEXT) {
      if (!std::strcmp("vkCmdDrawMultiEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMultiEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMultiIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiIndexedEXT; };
    if constexpr (HasCmdDrawMultiIndexedEXT) {
      if (!std::strcmp("vkCmdDrawMultiIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMultiIndexedEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEncodeVideoKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEncodeVideoKHR; };
    if constexpr (HasCmdEncodeVideoKHR) {
      if (!std::strcmp("vkCmdEncodeVideoKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEncodeVideoKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndConditionalRenderingEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndConditionalRenderingEXT; };
    if constexpr (HasCmdEndConditionalRenderingEXT) {
      if (!std::strcmp("vkCmdEndConditionalRenderingEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndConditionalRenderingEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndDebugUtilsLabelEXT; };
    if constexpr (HasCmdEndDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdEndDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndPerTileExecutionQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndPerTileExecutionQCOM; };
    if constexpr (HasCmdEndPerTileExecutionQCOM) {
      if (!std::strcmp("vkCmdEndPerTileExecutionQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndPerTileExecutionQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndQuery = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQuery; };
    if constexpr (HasCmdEndQuery) {
      if (!std::strcmp("vkCmdEndQuery", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndQuery<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndQueryIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQueryIndexedEXT; };
    if constexpr (HasCmdEndQueryIndexedEXT) {
      if (!std::strcmp("vkCmdEndQueryIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndQueryIndexedEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass; };
    if constexpr (HasCmdEndRenderPass) {
      if (!std::strcmp("vkCmdEndRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2; };
    if constexpr (HasCmdEndRenderPass2) {
      if (!std::strcmp("vkCmdEndRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2KHR; };
    if constexpr (HasCmdEndRenderPass2KHR) {
      if (!std::strcmp("vkCmdEndRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRendering = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering; };
    if constexpr (HasCmdEndRendering) {
      if (!std::strcmp("vkCmdEndRendering", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRendering<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRendering2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering2EXT; };
    if constexpr (HasCmdEndRendering2EXT) {
      if (!std::strcmp("vkCmdEndRendering2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRendering2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderingKHR; };
    if constexpr (HasCmdEndRenderingKHR) {
      if (!std::strcmp("vkCmdEndRenderingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderingKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndTransformFeedbackEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndTransformFeedbackEXT; };
    if constexpr (HasCmdEndTransformFeedbackEXT) {
      if (!std::strcmp("vkCmdEndTransformFeedbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndTransformFeedbackEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndVideoCodingKHR; };
    if constexpr (HasCmdEndVideoCodingKHR) {
      if (!std::strcmp("vkCmdEndVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndVideoCodingKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteCommands = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteCommands; };
    if constexpr (HasCmdExecuteCommands) {
      if (!std::strcmp("vkCmdExecuteCommands", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteCommands<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteGeneratedCommandsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsEXT; };
    if constexpr (HasCmdExecuteGeneratedCommandsEXT) {
      if (!std::strcmp("vkCmdExecuteGeneratedCommandsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteGeneratedCommandsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteGeneratedCommandsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsNV; };
    if constexpr (HasCmdExecuteGeneratedCommandsNV) {
      if (!std::strcmp("vkCmdExecuteGeneratedCommandsNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteGeneratedCommandsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdFillBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdFillBuffer; };
    if constexpr (HasCmdFillBuffer) {
      if (!std::strcmp("vkCmdFillBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdFillBuffer<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdInitializeGraphScratchMemoryAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX; };
    if constexpr (HasCmdInitializeGraphScratchMemoryAMDX) {
      if (!std::strcmp("vkCmdInitializeGraphScratchMemoryAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdInitializeGraphScratchMemoryAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdInsertDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInsertDebugUtilsLabelEXT; };
    if constexpr (HasCmdInsertDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdInsertDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdInsertDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass; };
    if constexpr (HasCmdNextSubpass) {
      if (!std::strcmp("vkCmdNextSubpass", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2; };
    if constexpr (HasCmdNextSubpass2) {
      if (!std::strcmp("vkCmdNextSubpass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2KHR; };
    if constexpr (HasCmdNextSubpass2KHR) {
      if (!std::strcmp("vkCmdNextSubpass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdOpticalFlowExecuteNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdOpticalFlowExecuteNV; };
    if constexpr (HasCmdOpticalFlowExecuteNV) {
      if (!std::strcmp("vkCmdOpticalFlowExecuteNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdOpticalFlowExecuteNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier; };
    if constexpr (HasCmdPipelineBarrier) {
      if (!std::strcmp("vkCmdPipelineBarrier", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2; };
    if constexpr (HasCmdPipelineBarrier2) {
      if (!std::strcmp("vkCmdPipelineBarrier2", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2KHR; };
    if constexpr (HasCmdPipelineBarrier2KHR) {
      if (!std::strcmp("vkCmdPipelineBarrier2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPreprocessGeneratedCommandsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsEXT; };
    if constexpr (HasCmdPreprocessGeneratedCommandsEXT) {
      if (!std::strcmp("vkCmdPreprocessGeneratedCommandsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdPreprocessGeneratedCommandsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPreprocessGeneratedCommandsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsNV; };
    if constexpr (HasCmdPreprocessGeneratedCommandsNV) {
      if (!std::strcmp("vkCmdPreprocessGeneratedCommandsNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdPreprocessGeneratedCommandsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushConstants = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants; };
    if constexpr (HasCmdPushConstants) {
      if (!std::strcmp("vkCmdPushConstants", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushConstants<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushConstants2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants2KHR; };
    if constexpr (HasCmdPushConstants2KHR) {
      if (!std::strcmp("vkCmdPushConstants2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushConstants2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSet2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSet2KHR; };
    if constexpr (HasCmdPushDescriptorSet2KHR) {
      if (!std::strcmp("vkCmdPushDescriptorSet2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSet2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetKHR; };
    if constexpr (HasCmdPushDescriptorSetKHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetWithTemplate2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR; };
    if constexpr (HasCmdPushDescriptorSetWithTemplate2KHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetWithTemplate2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetWithTemplate2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetWithTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR; };
    if constexpr (HasCmdPushDescriptorSetWithTemplateKHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetWithTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetWithTemplateKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent; };
    if constexpr (HasCmdResetEvent) {
      if (!std::strcmp("vkCmdResetEvent", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2; };
    if constexpr (HasCmdResetEvent2) {
      if (!std::strcmp("vkCmdResetEvent2", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2KHR; };
    if constexpr (HasCmdResetEvent2KHR) {
      if (!std::strcmp("vkCmdResetEvent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetQueryPool; };
    if constexpr (HasCmdResetQueryPool) {
      if (!std::strcmp("vkCmdResetQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetQueryPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage; };
    if constexpr (HasCmdResolveImage) {
      if (!std::strcmp("vkCmdResolveImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2; };
    if constexpr (HasCmdResolveImage2) {
      if (!std::strcmp("vkCmdResolveImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2KHR; };
    if constexpr (HasCmdResolveImage2KHR) {
      if (!std::strcmp("vkCmdResolveImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAlphaToCoverageEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToCoverageEnableEXT; };
    if constexpr (HasCmdSetAlphaToCoverageEnableEXT) {
      if (!std::strcmp("vkCmdSetAlphaToCoverageEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAlphaToCoverageEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAlphaToOneEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToOneEnableEXT; };
    if constexpr (HasCmdSetAlphaToOneEnableEXT) {
      if (!std::strcmp("vkCmdSetAlphaToOneEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAlphaToOneEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAttachmentFeedbackLoopEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT; };
    if constexpr (HasCmdSetAttachmentFeedbackLoopEnableEXT) {
      if (!std::strcmp("vkCmdSetAttachmentFeedbackLoopEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAttachmentFeedbackLoopEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetBlendConstants = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetBlendConstants; };
    if constexpr (HasCmdSetBlendConstants) {
      if (!std::strcmp("vkCmdSetBlendConstants", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetBlendConstants<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCheckpointNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCheckpointNV; };
    if constexpr (HasCmdSetCheckpointNV) {
      if (!std::strcmp("vkCmdSetCheckpointNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCheckpointNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoarseSampleOrderNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoarseSampleOrderNV; };
    if constexpr (HasCmdSetCoarseSampleOrderNV) {
      if (!std::strcmp("vkCmdSetCoarseSampleOrderNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoarseSampleOrderNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendAdvancedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendAdvancedEXT; };
    if constexpr (HasCmdSetColorBlendAdvancedEXT) {
      if (!std::strcmp("vkCmdSetColorBlendAdvancedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendAdvancedEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEnableEXT; };
    if constexpr (HasCmdSetColorBlendEnableEXT) {
      if (!std::strcmp("vkCmdSetColorBlendEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendEquationEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEquationEXT; };
    if constexpr (HasCmdSetColorBlendEquationEXT) {
      if (!std::strcmp("vkCmdSetColorBlendEquationEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendEquationEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorWriteEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteEnableEXT; };
    if constexpr (HasCmdSetColorWriteEnableEXT) {
      if (!std::strcmp("vkCmdSetColorWriteEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorWriteEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorWriteMaskEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteMaskEXT; };
    if constexpr (HasCmdSetColorWriteMaskEXT) {
      if (!std::strcmp("vkCmdSetColorWriteMaskEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorWriteMaskEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetConservativeRasterizationModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetConservativeRasterizationModeEXT; };
    if constexpr (HasCmdSetConservativeRasterizationModeEXT) {
      if (!std::strcmp("vkCmdSetConservativeRasterizationModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetConservativeRasterizationModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationModeNV; };
    if constexpr (HasCmdSetCoverageModulationModeNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationModeNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationModeNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationTableEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableEnableNV; };
    if constexpr (HasCmdSetCoverageModulationTableEnableNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationTableEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationTableEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationTableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableNV; };
    if constexpr (HasCmdSetCoverageModulationTableNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationTableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationTableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageReductionModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageReductionModeNV; };
    if constexpr (HasCmdSetCoverageReductionModeNV) {
      if (!std::strcmp("vkCmdSetCoverageReductionModeNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageReductionModeNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageToColorEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorEnableNV; };
    if constexpr (HasCmdSetCoverageToColorEnableNV) {
      if (!std::strcmp("vkCmdSetCoverageToColorEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageToColorEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageToColorLocationNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorLocationNV; };
    if constexpr (HasCmdSetCoverageToColorLocationNV) {
      if (!std::strcmp("vkCmdSetCoverageToColorLocationNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageToColorLocationNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCullMode = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullMode; };
    if constexpr (HasCmdSetCullMode) {
      if (!std::strcmp("vkCmdSetCullMode", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCullMode<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCullModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullModeEXT; };
    if constexpr (HasCmdSetCullModeEXT) {
      if (!std::strcmp("vkCmdSetCullModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCullModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBias = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias; };
    if constexpr (HasCmdSetDepthBias) {
      if (!std::strcmp("vkCmdSetDepthBias", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBias<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBias2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias2EXT; };
    if constexpr (HasCmdSetDepthBias2EXT) {
      if (!std::strcmp("vkCmdSetDepthBias2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBias2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBiasEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnable; };
    if constexpr (HasCmdSetDepthBiasEnable) {
      if (!std::strcmp("vkCmdSetDepthBiasEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBiasEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBiasEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnableEXT; };
    if constexpr (HasCmdSetDepthBiasEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthBiasEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBiasEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBounds = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBounds; };
    if constexpr (HasCmdSetDepthBounds) {
      if (!std::strcmp("vkCmdSetDepthBounds", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBounds<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBoundsTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnable; };
    if constexpr (HasCmdSetDepthBoundsTestEnable) {
      if (!std::strcmp("vkCmdSetDepthBoundsTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBoundsTestEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBoundsTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnableEXT; };
    if constexpr (HasCmdSetDepthBoundsTestEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthBoundsTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBoundsTestEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClampEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampEnableEXT; };
    if constexpr (HasCmdSetDepthClampEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthClampEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClampEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClampRangeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampRangeEXT; };
    if constexpr (HasCmdSetDepthClampRangeEXT) {
      if (!std::strcmp("vkCmdSetDepthClampRangeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClampRangeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClipEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipEnableEXT; };
    if constexpr (HasCmdSetDepthClipEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthClipEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClipEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClipNegativeOneToOneEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT; };
    if constexpr (HasCmdSetDepthClipNegativeOneToOneEXT) {
      if (!std::strcmp("vkCmdSetDepthClipNegativeOneToOneEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClipNegativeOneToOneEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthCompareOp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOp; };
    if constexpr (HasCmdSetDepthCompareOp) {
      if (!std::strcmp("vkCmdSetDepthCompareOp", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthCompareOp<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthCompareOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOpEXT; };
    if constexpr (HasCmdSetDepthCompareOpEXT) {
      if (!std::strcmp("vkCmdSetDepthCompareOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthCompareOpEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnable; };
    if constexpr (HasCmdSetDepthTestEnable) {
      if (!std::strcmp("vkCmdSetDepthTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthTestEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnableEXT; };
    if constexpr (HasCmdSetDepthTestEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthTestEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthWriteEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnable; };
    if constexpr (HasCmdSetDepthWriteEnable) {
      if (!std::strcmp("vkCmdSetDepthWriteEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthWriteEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthWriteEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnableEXT; };
    if constexpr (HasCmdSetDepthWriteEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthWriteEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthWriteEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDescriptorBufferOffsets2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT; };
    if constexpr (HasCmdSetDescriptorBufferOffsets2EXT) {
      if (!std::strcmp("vkCmdSetDescriptorBufferOffsets2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDescriptorBufferOffsets2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDescriptorBufferOffsetsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT; };
    if constexpr (HasCmdSetDescriptorBufferOffsetsEXT) {
      if (!std::strcmp("vkCmdSetDescriptorBufferOffsetsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDescriptorBufferOffsetsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDeviceMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMask; };
    if constexpr (HasCmdSetDeviceMask) {
      if (!std::strcmp("vkCmdSetDeviceMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDeviceMask<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDeviceMaskKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMaskKHR; };
    if constexpr (HasCmdSetDeviceMaskKHR) {
      if (!std::strcmp("vkCmdSetDeviceMaskKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDeviceMaskKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEXT; };
    if constexpr (HasCmdSetDiscardRectangleEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEnableEXT; };
    if constexpr (HasCmdSetDiscardRectangleEnableEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleModeEXT; };
    if constexpr (HasCmdSetDiscardRectangleModeEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent; };
    if constexpr (HasCmdSetEvent) {
      if (!std::strcmp("vkCmdSetEvent", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2; };
    if constexpr (HasCmdSetEvent2) {
      if (!std::strcmp("vkCmdSetEvent2", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2KHR; };
    if constexpr (HasCmdSetEvent2KHR) {
      if (!std::strcmp("vkCmdSetEvent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExclusiveScissorEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorEnableNV; };
    if constexpr (HasCmdSetExclusiveScissorEnableNV) {
      if (!std::strcmp("vkCmdSetExclusiveScissorEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExclusiveScissorEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExclusiveScissorNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorNV; };
    if constexpr (HasCmdSetExclusiveScissorNV) {
      if (!std::strcmp("vkCmdSetExclusiveScissorNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExclusiveScissorNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExtraPrimitiveOverestimationSizeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT; };
    if constexpr (HasCmdSetExtraPrimitiveOverestimationSizeEXT) {
      if (!std::strcmp("vkCmdSetExtraPrimitiveOverestimationSizeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExtraPrimitiveOverestimationSizeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFragmentShadingRateEnumNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateEnumNV; };
    if constexpr (HasCmdSetFragmentShadingRateEnumNV) {
      if (!std::strcmp("vkCmdSetFragmentShadingRateEnumNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFragmentShadingRateEnumNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFragmentShadingRateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateKHR; };
    if constexpr (HasCmdSetFragmentShadingRateKHR) {
      if (!std::strcmp("vkCmdSetFragmentShadingRateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFragmentShadingRateKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFrontFace = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFace; };
    if constexpr (HasCmdSetFrontFace) {
      if (!std::strcmp("vkCmdSetFrontFace", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFrontFace<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFrontFaceEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFaceEXT; };
    if constexpr (HasCmdSetFrontFaceEXT) {
      if (!std::strcmp("vkCmdSetFrontFaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFrontFaceEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineRasterizationModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineRasterizationModeEXT; };
    if constexpr (HasCmdSetLineRasterizationModeEXT) {
      if (!std::strcmp("vkCmdSetLineRasterizationModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineRasterizationModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEXT; };
    if constexpr (HasCmdSetLineStippleEXT) {
      if (!std::strcmp("vkCmdSetLineStippleEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEnableEXT; };
    if constexpr (HasCmdSetLineStippleEnableEXT) {
      if (!std::strcmp("vkCmdSetLineStippleEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleKHR; };
    if constexpr (HasCmdSetLineStippleKHR) {
      if (!std::strcmp("vkCmdSetLineStippleKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineWidth = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineWidth; };
    if constexpr (HasCmdSetLineWidth) {
      if (!std::strcmp("vkCmdSetLineWidth", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineWidth<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLogicOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEXT; };
    if constexpr (HasCmdSetLogicOpEXT) {
      if (!std::strcmp("vkCmdSetLogicOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLogicOpEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLogicOpEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEnableEXT; };
    if constexpr (HasCmdSetLogicOpEnableEXT) {
      if (!std::strcmp("vkCmdSetLogicOpEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLogicOpEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPatchControlPointsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPatchControlPointsEXT; };
    if constexpr (HasCmdSetPatchControlPointsEXT) {
      if (!std::strcmp("vkCmdSetPatchControlPointsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPatchControlPointsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceMarkerINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceMarkerINTEL; };
    if constexpr (HasCmdSetPerformanceMarkerINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceMarkerINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceMarkerINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceOverrideINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceOverrideINTEL; };
    if constexpr (HasCmdSetPerformanceOverrideINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceOverrideINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceOverrideINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceStreamMarkerINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL; };
    if constexpr (HasCmdSetPerformanceStreamMarkerINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceStreamMarkerINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceStreamMarkerINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPolygonModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPolygonModeEXT; };
    if constexpr (HasCmdSetPolygonModeEXT) {
      if (!std::strcmp("vkCmdSetPolygonModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPolygonModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveRestartEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnable; };
    if constexpr (HasCmdSetPrimitiveRestartEnable) {
      if (!std::strcmp("vkCmdSetPrimitiveRestartEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveRestartEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveRestartEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnableEXT; };
    if constexpr (HasCmdSetPrimitiveRestartEnableEXT) {
      if (!std::strcmp("vkCmdSetPrimitiveRestartEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveRestartEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveTopology = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopology; };
    if constexpr (HasCmdSetPrimitiveTopology) {
      if (!std::strcmp("vkCmdSetPrimitiveTopology", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveTopology<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveTopologyEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopologyEXT; };
    if constexpr (HasCmdSetPrimitiveTopologyEXT) {
      if (!std::strcmp("vkCmdSetPrimitiveTopologyEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveTopologyEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetProvokingVertexModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetProvokingVertexModeEXT; };
    if constexpr (HasCmdSetProvokingVertexModeEXT) {
      if (!std::strcmp("vkCmdSetProvokingVertexModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetProvokingVertexModeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizationSamplesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationSamplesEXT; };
    if constexpr (HasCmdSetRasterizationSamplesEXT) {
      if (!std::strcmp("vkCmdSetRasterizationSamplesEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizationSamplesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizationStreamEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationStreamEXT; };
    if constexpr (HasCmdSetRasterizationStreamEXT) {
      if (!std::strcmp("vkCmdSetRasterizationStreamEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizationStreamEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizerDiscardEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnable; };
    if constexpr (HasCmdSetRasterizerDiscardEnable) {
      if (!std::strcmp("vkCmdSetRasterizerDiscardEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizerDiscardEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizerDiscardEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnableEXT; };
    if constexpr (HasCmdSetRasterizerDiscardEnableEXT) {
      if (!std::strcmp("vkCmdSetRasterizerDiscardEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizerDiscardEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRayTracingPipelineStackSizeKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR; };
    if constexpr (HasCmdSetRayTracingPipelineStackSizeKHR) {
      if (!std::strcmp("vkCmdSetRayTracingPipelineStackSizeKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRayTracingPipelineStackSizeKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRenderingAttachmentLocationsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR; };
    if constexpr (HasCmdSetRenderingAttachmentLocationsKHR) {
      if (!std::strcmp("vkCmdSetRenderingAttachmentLocationsKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRenderingAttachmentLocationsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRenderingInputAttachmentIndicesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR; };
    if constexpr (HasCmdSetRenderingInputAttachmentIndicesKHR) {
      if (!std::strcmp("vkCmdSetRenderingInputAttachmentIndicesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRenderingInputAttachmentIndicesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRepresentativeFragmentTestEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV; };
    if constexpr (HasCmdSetRepresentativeFragmentTestEnableNV) {
      if (!std::strcmp("vkCmdSetRepresentativeFragmentTestEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRepresentativeFragmentTestEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleLocationsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEXT; };
    if constexpr (HasCmdSetSampleLocationsEXT) {
      if (!std::strcmp("vkCmdSetSampleLocationsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleLocationsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleLocationsEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEnableEXT; };
    if constexpr (HasCmdSetSampleLocationsEnableEXT) {
      if (!std::strcmp("vkCmdSetSampleLocationsEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleLocationsEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleMaskEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleMaskEXT; };
    if constexpr (HasCmdSetSampleMaskEXT) {
      if (!std::strcmp("vkCmdSetSampleMaskEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleMaskEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissor = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissor; };
    if constexpr (HasCmdSetScissor) {
      if (!std::strcmp("vkCmdSetScissor", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissor<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissorWithCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCount; };
    if constexpr (HasCmdSetScissorWithCount) {
      if (!std::strcmp("vkCmdSetScissorWithCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissorWithCount<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissorWithCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCountEXT; };
    if constexpr (HasCmdSetScissorWithCountEXT) {
      if (!std::strcmp("vkCmdSetScissorWithCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissorWithCountEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetShadingRateImageEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetShadingRateImageEnableNV; };
    if constexpr (HasCmdSetShadingRateImageEnableNV) {
      if (!std::strcmp("vkCmdSetShadingRateImageEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetShadingRateImageEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilCompareMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilCompareMask; };
    if constexpr (HasCmdSetStencilCompareMask) {
      if (!std::strcmp("vkCmdSetStencilCompareMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilCompareMask<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilOp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOp; };
    if constexpr (HasCmdSetStencilOp) {
      if (!std::strcmp("vkCmdSetStencilOp", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilOp<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOpEXT; };
    if constexpr (HasCmdSetStencilOpEXT) {
      if (!std::strcmp("vkCmdSetStencilOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilOpEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilReference = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilReference; };
    if constexpr (HasCmdSetStencilReference) {
      if (!std::strcmp("vkCmdSetStencilReference", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilReference<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnable; };
    if constexpr (HasCmdSetStencilTestEnable) {
      if (!std::strcmp("vkCmdSetStencilTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilTestEnable<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnableEXT; };
    if constexpr (HasCmdSetStencilTestEnableEXT) {
      if (!std::strcmp("vkCmdSetStencilTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilTestEnableEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilWriteMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilWriteMask; };
    if constexpr (HasCmdSetStencilWriteMask) {
      if (!std::strcmp("vkCmdSetStencilWriteMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilWriteMask<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetTessellationDomainOriginEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetTessellationDomainOriginEXT; };
    if constexpr (HasCmdSetTessellationDomainOriginEXT) {
      if (!std::strcmp("vkCmdSetTessellationDomainOriginEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetTessellationDomainOriginEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetVertexInputEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetVertexInputEXT; };
    if constexpr (HasCmdSetVertexInputEXT) {
      if (!std::strcmp("vkCmdSetVertexInputEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetVertexInputEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewport = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewport; };
    if constexpr (HasCmdSetViewport) {
      if (!std::strcmp("vkCmdSetViewport", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewport<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportShadingRatePaletteNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportShadingRatePaletteNV; };
    if constexpr (HasCmdSetViewportShadingRatePaletteNV) {
      if (!std::strcmp("vkCmdSetViewportShadingRatePaletteNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportShadingRatePaletteNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportSwizzleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportSwizzleNV; };
    if constexpr (HasCmdSetViewportSwizzleNV) {
      if (!std::strcmp("vkCmdSetViewportSwizzleNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportSwizzleNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWScalingEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingEnableNV; };
    if constexpr (HasCmdSetViewportWScalingEnableNV) {
      if (!std::strcmp("vkCmdSetViewportWScalingEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWScalingEnableNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWScalingNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingNV; };
    if constexpr (HasCmdSetViewportWScalingNV) {
      if (!std::strcmp("vkCmdSetViewportWScalingNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWScalingNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWithCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCount; };
    if constexpr (HasCmdSetViewportWithCount) {
      if (!std::strcmp("vkCmdSetViewportWithCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWithCount<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWithCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCountEXT; };
    if constexpr (HasCmdSetViewportWithCountEXT) {
      if (!std::strcmp("vkCmdSetViewportWithCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWithCountEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSubpassShadingHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSubpassShadingHUAWEI; };
    if constexpr (HasCmdSubpassShadingHUAWEI) {
      if (!std::strcmp("vkCmdSubpassShadingHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdSubpassShadingHUAWEI<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysIndirect2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirect2KHR; };
    if constexpr (HasCmdTraceRaysIndirect2KHR) {
      if (!std::strcmp("vkCmdTraceRaysIndirect2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysIndirect2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysIndirectKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirectKHR; };
    if constexpr (HasCmdTraceRaysIndirectKHR) {
      if (!std::strcmp("vkCmdTraceRaysIndirectKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysIndirectKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysKHR; };
    if constexpr (HasCmdTraceRaysKHR) {
      if (!std::strcmp("vkCmdTraceRaysKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysNV; };
    if constexpr (HasCmdTraceRaysNV) {
      if (!std::strcmp("vkCmdTraceRaysNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdUpdateBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdateBuffer; };
    if constexpr (HasCmdUpdateBuffer) {
      if (!std::strcmp("vkCmdUpdateBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdUpdateBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdUpdatePipelineIndirectBufferNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdatePipelineIndirectBufferNV; };
    if constexpr (HasCmdUpdatePipelineIndirectBufferNV) {
      if (!std::strcmp("vkCmdUpdatePipelineIndirectBufferNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdUpdatePipelineIndirectBufferNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents; };
    if constexpr (HasCmdWaitEvents) {
      if (!std::strcmp("vkCmdWaitEvents", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2; };
    if constexpr (HasCmdWaitEvents2) {
      if (!std::strcmp("vkCmdWaitEvents2", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2KHR; };
    if constexpr (HasCmdWaitEvents2KHR) {
      if (!std::strcmp("vkCmdWaitEvents2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteAccelerationStructuresPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR; };
    if constexpr (HasCmdWriteAccelerationStructuresPropertiesKHR) {
      if (!std::strcmp("vkCmdWriteAccelerationStructuresPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteAccelerationStructuresPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteAccelerationStructuresPropertiesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV; };
    if constexpr (HasCmdWriteAccelerationStructuresPropertiesNV) {
      if (!std::strcmp("vkCmdWriteAccelerationStructuresPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteAccelerationStructuresPropertiesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteBufferMarker2AMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarker2AMD; };
    if constexpr (HasCmdWriteBufferMarker2AMD) {
      if (!std::strcmp("vkCmdWriteBufferMarker2AMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteBufferMarker2AMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteBufferMarkerAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarkerAMD; };
    if constexpr (HasCmdWriteBufferMarkerAMD) {
      if (!std::strcmp("vkCmdWriteBufferMarkerAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteBufferMarkerAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteMicromapsPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteMicromapsPropertiesEXT; };
    if constexpr (HasCmdWriteMicromapsPropertiesEXT) {
      if (!std::strcmp("vkCmdWriteMicromapsPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteMicromapsPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp; };
    if constexpr (HasCmdWriteTimestamp) {
      if (!std::strcmp("vkCmdWriteTimestamp", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2; };
    if constexpr (HasCmdWriteTimestamp2) {
      if (!std::strcmp("vkCmdWriteTimestamp2", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2KHR; };
    if constexpr (HasCmdWriteTimestamp2KHR) {
      if (!std::strcmp("vkCmdWriteTimestamp2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCompileDeferredNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CompileDeferredNV; };
    if constexpr (HasCompileDeferredNV) {
      if (!std::strcmp("vkCompileDeferredNV", name))
        return (PFN_vkVoidFunction) &wrap_CompileDeferredNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasConvertCooperativeVectorMatrixNV = requires(const DeviceOverrides& t) { &DeviceOverrides::ConvertCooperativeVectorMatrixNV; };
    if constexpr (HasConvertCooperativeVectorMatrixNV) {
      if (!std::strcmp("vkConvertCooperativeVectorMatrixNV", name))
        return (PFN_vkVoidFunction) &wrap_ConvertCooperativeVectorMatrixNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyAccelerationStructureKHR; };
    if constexpr (HasCopyAccelerationStructureKHR) {
      if (!std::strcmp("vkCopyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyAccelerationStructureToMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyAccelerationStructureToMemoryKHR; };
    if constexpr (HasCopyAccelerationStructureToMemoryKHR) {
      if (!std::strcmp("vkCopyAccelerationStructureToMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyAccelerationStructureToMemoryKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyImageToImageEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyImageToImageEXT; };
    if constexpr (HasCopyImageToImageEXT) {
      if (!std::strcmp("vkCopyImageToImageEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyImageToImageEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyImageToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyImageToMemoryEXT; };
    if constexpr (HasCopyImageToMemoryEXT) {
      if (!std::strcmp("vkCopyImageToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyImageToMemoryEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToAccelerationStructureKHR; };
    if constexpr (HasCopyMemoryToAccelerationStructureKHR) {
      if (!std::strcmp("vkCopyMemoryToAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToImageEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToImageEXT; };
    if constexpr (HasCopyMemoryToImageEXT) {
      if (!std::strcmp("vkCopyMemoryToImageEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToImageEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToMicromapEXT; };
    if constexpr (HasCopyMemoryToMicromapEXT) {
      if (!std::strcmp("vkCopyMemoryToMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMicromapEXT; };
    if constexpr (HasCopyMicromapEXT) {
      if (!std::strcmp("vkCopyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMicromapToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMicromapToMemoryEXT; };
    if constexpr (HasCopyMicromapToMemoryEXT) {
      if (!std::strcmp("vkCopyMicromapToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMicromapToMemoryEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateAccelerationStructureKHR; };
    if constexpr (HasCreateAccelerationStructureKHR) {
      if (!std::strcmp("vkCreateAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateAccelerationStructureNV; };
    if constexpr (HasCreateAccelerationStructureNV) {
      if (!std::strcmp("vkCreateAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateAccelerationStructureNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBuffer; };
    if constexpr (HasCreateBuffer) {
      if (!std::strcmp("vkCreateBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CreateBuffer<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasCreateBufferCollectionFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBufferCollectionFUCHSIA; };
    if constexpr (HasCreateBufferCollectionFUCHSIA) {
      if (!std::strcmp("vkCreateBufferCollectionFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_CreateBufferCollectionFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateBufferView = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBufferView; };
    if constexpr (HasCreateBufferView) {
      if (!std::strcmp("vkCreateBufferView", name))
        return (PFN_vkVoidFunction) &wrap_CreateBufferView<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCommandPool; };
    if constexpr (HasCreateCommandPool) {
      if (!std::strcmp("vkCreateCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateCommandPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateComputePipelines = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateComputePipelines; };
    if constexpr (HasCreateComputePipelines) {
      if (!std::strcmp("vkCreateComputePipelines", name))
        return (PFN_vkVoidFunction) &wrap_CreateComputePipelines<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateCudaFunctionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCudaFunctionNV; };
    if constexpr (HasCreateCudaFunctionNV) {
      if (!std::strcmp("vkCreateCudaFunctionNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateCudaFunctionNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateCudaModuleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCudaModuleNV; };
    if constexpr (HasCreateCudaModuleNV) {
      if (!std::strcmp("vkCreateCudaModuleNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateCudaModuleNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDataGraphPipelineSessionARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDataGraphPipelineSessionARM; };
    if constexpr (HasCreateDataGraphPipelineSessionARM) {
      if (!std::strcmp("vkCreateDataGraphPipelineSessionARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateDataGraphPipelineSessionARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDataGraphPipelinesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDataGraphPipelinesARM; };
    if constexpr (HasCreateDataGraphPipelinesARM) {
      if (!std::strcmp("vkCreateDataGraphPipelinesARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateDataGraphPipelinesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDeferredOperationKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDeferredOperationKHR; };
    if constexpr (HasCreateDeferredOperationKHR) {
      if (!std::strcmp("vkCreateDeferredOperationKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDeferredOperationKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorPool; };
    if constexpr (HasCreateDescriptorPool) {
      if (!std::strcmp("vkCreateDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorSetLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorSetLayout; };
    if constexpr (HasCreateDescriptorSetLayout) {
      if (!std::strcmp("vkCreateDescriptorSetLayout", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorSetLayout<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorUpdateTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorUpdateTemplate; };
    if constexpr (HasCreateDescriptorUpdateTemplate) {
      if (!std::strcmp("vkCreateDescriptorUpdateTemplate", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorUpdateTemplate<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorUpdateTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorUpdateTemplateKHR; };
    if constexpr (HasCreateDescriptorUpdateTemplateKHR) {
      if (!std::strcmp("vkCreateDescriptorUpdateTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorUpdateTemplateKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateEvent; };
    if constexpr (HasCreateEvent) {
      if (!std::strcmp("vkCreateEvent", name))
        return (PFN_vkVoidFunction) &wrap_CreateEvent<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateExecutionGraphPipelinesAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateExecutionGraphPipelinesAMDX; };
    if constexpr (HasCreateExecutionGraphPipelinesAMDX) {
      if (!std::strcmp("vkCreateExecutionGraphPipelinesAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CreateExecutionGraphPipelinesAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateExternalComputeQueueNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateExternalComputeQueueNV; };
    if constexpr (HasCreateExternalComputeQueueNV) {
      if (!std::strcmp("vkCreateExternalComputeQueueNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateExternalComputeQueueNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateFence = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateFence; };
    if constexpr (HasCreateFence) {
      if (!std::strcmp("vkCreateFence", name))
        return (PFN_vkVoidFunction) &wrap_CreateFence<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateFramebuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateFramebuffer; };
    if constexpr (HasCreateFramebuffer) {
      if (!std::strcmp("vkCreateFramebuffer", name))
        return (PFN_vkVoidFunction) &wrap_CreateFramebuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateGraphicsPipelines = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateGraphicsPipelines; };
    if constexpr (HasCreateGraphicsPipelines) {
      if (!std::strcmp("vkCreateGraphicsPipelines", name))
        return (PFN_vkVoidFunction) &wrap_CreateGraphicsPipelines<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateImage; };
    if constexpr (HasCreateImage) {
      if (!std::strcmp("vkCreateImage", name))
        return (PFN_vkVoidFunction) &wrap_CreateImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateImageView = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateImageView; };
    if constexpr (HasCreateImageView) {
      if (!std::strcmp("vkCreateImageView", name))
        return (PFN_vkVoidFunction) &wrap_CreateImageView<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectCommandsLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectCommandsLayoutEXT; };
    if constexpr (HasCreateIndirectCommandsLayoutEXT) {
      if (!std::strcmp("vkCreateIndirectCommandsLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectCommandsLayoutEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectCommandsLayoutNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectCommandsLayoutNV; };
    if constexpr (HasCreateIndirectCommandsLayoutNV) {
      if (!std::strcmp("vkCreateIndirectCommandsLayoutNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectCommandsLayoutNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectExecutionSetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectExecutionSetEXT; };
    if constexpr (HasCreateIndirectExecutionSetEXT) {
      if (!std::strcmp("vkCreateIndirectExecutionSetEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectExecutionSetEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateMicromapEXT; };
    if constexpr (HasCreateMicromapEXT) {
      if (!std::strcmp("vkCreateMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateOpticalFlowSessionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateOpticalFlowSessionNV; };
    if constexpr (HasCreateOpticalFlowSessionNV) {
      if (!std::strcmp("vkCreateOpticalFlowSessionNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateOpticalFlowSessionNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineBinariesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineBinariesKHR; };
    if constexpr (HasCreatePipelineBinariesKHR) {
      if (!std::strcmp("vkCreatePipelineBinariesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineBinariesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineCache = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineCache; };
    if constexpr (HasCreatePipelineCache) {
      if (!std::strcmp("vkCreatePipelineCache", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineCache<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineLayout; };
    if constexpr (HasCreatePipelineLayout) {
      if (!std::strcmp("vkCreatePipelineLayout", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineLayout<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePrivateDataSlot = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePrivateDataSlot; };
    if constexpr (HasCreatePrivateDataSlot) {
      if (!std::strcmp("vkCreatePrivateDataSlot", name))
        return (PFN_vkVoidFunction) &wrap_CreatePrivateDataSlot<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePrivateDataSlotEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePrivateDataSlotEXT; };
    if constexpr (HasCreatePrivateDataSlotEXT) {
      if (!std::strcmp("vkCreatePrivateDataSlotEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreatePrivateDataSlotEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateQueryPool; };
    if constexpr (HasCreateQueryPool) {
      if (!std::strcmp("vkCreateQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateQueryPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRayTracingPipelinesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRayTracingPipelinesKHR; };
    if constexpr (HasCreateRayTracingPipelinesKHR) {
      if (!std::strcmp("vkCreateRayTracingPipelinesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateRayTracingPipelinesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRayTracingPipelinesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRayTracingPipelinesNV; };
    if constexpr (HasCreateRayTracingPipelinesNV) {
      if (!std::strcmp("vkCreateRayTracingPipelinesNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateRayTracingPipelinesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass; };
    if constexpr (HasCreateRenderPass) {
      if (!std::strcmp("vkCreateRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass2; };
    if constexpr (HasCreateRenderPass2) {
      if (!std::strcmp("vkCreateRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass2KHR; };
    if constexpr (HasCreateRenderPass2KHR) {
      if (!std::strcmp("vkCreateRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSampler = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSampler; };
    if constexpr (HasCreateSampler) {
      if (!std::strcmp("vkCreateSampler", name))
        return (PFN_vkVoidFunction) &wrap_CreateSampler<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSamplerYcbcrConversion = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSamplerYcbcrConversion; };
    if constexpr (HasCreateSamplerYcbcrConversion) {
      if (!std::strcmp("vkCreateSamplerYcbcrConversion", name))
        return (PFN_vkVoidFunction) &wrap_CreateSamplerYcbcrConversion<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSamplerYcbcrConversionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSamplerYcbcrConversionKHR; };
    if constexpr (HasCreateSamplerYcbcrConversionKHR) {
      if (!std::strcmp("vkCreateSamplerYcbcrConversionKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSamplerYcbcrConversionKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSemaphore; };
    if constexpr (HasCreateSemaphore) {
      if (!std::strcmp("vkCreateSemaphore", name))
        return (PFN_vkVoidFunction) &wrap_CreateSemaphore<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateShaderModule = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateShaderModule; };
    if constexpr (HasCreateShaderModule) {
      if (!std::strcmp("vkCreateShaderModule", name))
        return (PFN_vkVoidFunction) &wrap_CreateShaderModule<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateShadersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateShadersEXT; };
    if constexpr (HasCreateShadersEXT) {
      if (!std::strcmp("vkCreateShadersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateShadersEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSharedSwapchainsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSharedSwapchainsKHR; };
    if constexpr (HasCreateSharedSwapchainsKHR) {
      if (!std::strcmp("vkCreateSharedSwapchainsKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSharedSwapchainsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSwapchainKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSwapchainKHR; };
    if constexpr (HasCreateSwapchainKHR) {
      if (!std::strcmp("vkCreateSwapchainKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSwapchainKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateTensorARM; };
    if constexpr (HasCreateTensorARM) {
      if (!std::strcmp("vkCreateTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateTensorARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateTensorViewARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateTensorViewARM; };
    if constexpr (HasCreateTensorViewARM) {
      if (!std::strcmp("vkCreateTensorViewARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateTensorViewARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateValidationCacheEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateValidationCacheEXT; };
    if constexpr (HasCreateValidationCacheEXT) {
      if (!std::strcmp("vkCreateValidationCacheEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateValidationCacheEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateVideoSessionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateVideoSessionKHR; };
    if constexpr (HasCreateVideoSessionKHR) {
      if (!std::strcmp("vkCreateVideoSessionKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateVideoSessionKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateVideoSessionParametersKHR; };
    if constexpr (HasCreateVideoSessionParametersKHR) {
      if (!std::strcmp("vkCreateVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateVideoSessionParametersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDebugMarkerSetObjectNameEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DebugMarkerSetObjectNameEXT; };
    if constexpr (HasDebugMarkerSetObjectNameEXT) {
      if (!std::strcmp("vkDebugMarkerSetObjectNameEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugMarkerSetObjectNameEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDebugMarkerSetObjectTagEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DebugMarkerSetObjectTagEXT; };
    if constexpr (HasDebugMarkerSetObjectTagEXT) {
      if (!std::strcmp("vkDebugMarkerSetObjectTagEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugMarkerSetObjectTagEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDeferredOperationJoinKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DeferredOperationJoinKHR; };
    if constexpr (HasDeferredOperationJoinKHR) {
      if (!std::strcmp("vkDeferredOperationJoinKHR", name))
        return (PFN_vkVoidFunction) &wrap_DeferredOperationJoinKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyAccelerationStructureKHR; };
    if constexpr (HasDestroyAccelerationStructureKHR) {
      if (!std::strcmp("vkDestroyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyAccelerationStructureKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyAccelerationStructureNV; };
    if constexpr (HasDestroyAccelerationStructureNV) {
      if (!std::strcmp("vkDestroyAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyAccelerationStructureNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBuffer; };
    if constexpr (HasDestroyBuffer) {
      if (!std::strcmp("vkDestroyBuffer", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBuffer<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasDestroyBufferCollectionFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBufferCollectionFUCHSIA; };
    if constexpr (HasDestroyBufferCollectionFUCHSIA) {
      if (!std::strcmp("vkDestroyBufferCollectionFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBufferCollectionFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDestroyBufferView = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBufferView; };
    if constexpr (HasDestroyBufferView) {
      if (!std::strcmp("vkDestroyBufferView", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBufferView<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCommandPool; };
    if constexpr (HasDestroyCommandPool) {
      if (!std::strcmp("vkDestroyCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCommandPool<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasDestroyCudaFunctionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCudaFunctionNV; };
    if constexpr (HasDestroyCudaFunctionNV) {
      if (!std::strcmp("vkDestroyCudaFunctionNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCudaFunctionNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasDestroyCudaModuleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCudaModuleNV; };
    if constexpr (HasDestroyCudaModuleNV) {
      if (!std::strcmp("vkDestroyCudaModuleNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCudaModuleNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDestroyDataGraphPipelineSessionARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDataGraphPipelineSessionARM; };
    if constexpr (HasDestroyDataGraphPipelineSessionARM) {
      if (!std::strcmp("vkDestroyDataGraphPipelineSessionARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDataGraphPipelineSessionARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDeferredOperationKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDeferredOperationKHR; };
    if constexpr (HasDestroyDeferredOperationKHR) {
      if (!std::strcmp("vkDestroyDeferredOperationKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDeferredOperationKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorPool; };
    if constexpr (HasDestroyDescriptorPool) {
      if (!std::strcmp("vkDestroyDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorSetLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorSetLayout; };
    if constexpr (HasDestroyDescriptorSetLayout) {
      if (!std::strcmp("vkDestroyDescriptorSetLayout", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorSetLayout<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorUpdateTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorUpdateTemplate; };
    if constexpr (HasDestroyDescriptorUpdateTemplate) {
      if (!std::strcmp("vkDestroyDescriptorUpdateTemplate", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorUpdateTemplate<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorUpdateTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorUpdateTemplateKHR; };
    if constexpr (HasDestroyDescriptorUpdateTemplateKHR) {
      if (!std::strcmp("vkDestroyDescriptorUpdateTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorUpdateTemplateKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDevice = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDevice; };
    if constexpr (HasDestroyDevice) {
      if (!std::strcmp("vkDestroyDevice", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDevice<InstanceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkDestroyDevice", name))
        return (PFN_vkVoidFunction) +[](VkDevice device, const VkAllocationCallbacks *pAllocator) -> void { const auto* dispatch = LookupDispatch(device); dispatch->DestroyDevice(device, pAllocator); };
    }

    constexpr bool HasDestroyEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyEvent; };
    if constexpr (HasDestroyEvent) {
      if (!std::strcmp("vkDestroyEvent", name))
        return (PFN_vkVoidFunction) &wrap_DestroyEvent<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyExternalComputeQueueNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyExternalComputeQueueNV; };
    if constexpr (HasDestroyExternalComputeQueueNV) {
      if (!std::strcmp("vkDestroyExternalComputeQueueNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyExternalComputeQueueNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyFence = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyFence; };
    if constexpr (HasDestroyFence) {
      if (!std::strcmp("vkDestroyFence", name))
        return (PFN_vkVoidFunction) &wrap_DestroyFence<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyFramebuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyFramebuffer; };
    if constexpr (HasDestroyFramebuffer) {
      if (!std::strcmp("vkDestroyFramebuffer", name))
        return (PFN_vkVoidFunction) &wrap_DestroyFramebuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyImage = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyImage; };
    if constexpr (HasDestroyImage) {
      if (!std::strcmp("vkDestroyImage", name))
        return (PFN_vkVoidFunction) &wrap_DestroyImage<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyImageView = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyImageView; };
    if constexpr (HasDestroyImageView) {
      if (!std::strcmp("vkDestroyImageView", name))
        return (PFN_vkVoidFunction) &wrap_DestroyImageView<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectCommandsLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectCommandsLayoutEXT; };
    if constexpr (HasDestroyIndirectCommandsLayoutEXT) {
      if (!std::strcmp("vkDestroyIndirectCommandsLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectCommandsLayoutEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectCommandsLayoutNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectCommandsLayoutNV; };
    if constexpr (HasDestroyIndirectCommandsLayoutNV) {
      if (!std::strcmp("vkDestroyIndirectCommandsLayoutNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectCommandsLayoutNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectExecutionSetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectExecutionSetEXT; };
    if constexpr (HasDestroyIndirectExecutionSetEXT) {
      if (!std::strcmp("vkDestroyIndirectExecutionSetEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectExecutionSetEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyMicromapEXT; };
    if constexpr (HasDestroyMicromapEXT) {
      if (!std::strcmp("vkDestroyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyMicromapEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyOpticalFlowSessionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyOpticalFlowSessionNV; };
    if constexpr (HasDestroyOpticalFlowSessionNV) {
      if (!std::strcmp("vkDestroyOpticalFlowSessionNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyOpticalFlowSessionNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipeline = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipeline; };
    if constexpr (HasDestroyPipeline) {
      if (!std::strcmp("vkDestroyPipeline", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipeline<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineBinaryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineBinaryKHR; };
    if constexpr (HasDestroyPipelineBinaryKHR) {
      if (!std::strcmp("vkDestroyPipelineBinaryKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineBinaryKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineCache = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineCache; };
    if constexpr (HasDestroyPipelineCache) {
      if (!std::strcmp("vkDestroyPipelineCache", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineCache<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineLayout; };
    if constexpr (HasDestroyPipelineLayout) {
      if (!std::strcmp("vkDestroyPipelineLayout", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineLayout<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPrivateDataSlot = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPrivateDataSlot; };
    if constexpr (HasDestroyPrivateDataSlot) {
      if (!std::strcmp("vkDestroyPrivateDataSlot", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPrivateDataSlot<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPrivateDataSlotEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPrivateDataSlotEXT; };
    if constexpr (HasDestroyPrivateDataSlotEXT) {
      if (!std::strcmp("vkDestroyPrivateDataSlotEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPrivateDataSlotEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyQueryPool; };
    if constexpr (HasDestroyQueryPool) {
      if (!std::strcmp("vkDestroyQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyQueryPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyRenderPass; };
    if constexpr (HasDestroyRenderPass) {
      if (!std::strcmp("vkDestroyRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_DestroyRenderPass<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySampler = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySampler; };
    if constexpr (HasDestroySampler) {
      if (!std::strcmp("vkDestroySampler", name))
        return (PFN_vkVoidFunction) &wrap_DestroySampler<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySamplerYcbcrConversion = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySamplerYcbcrConversion; };
    if constexpr (HasDestroySamplerYcbcrConversion) {
      if (!std::strcmp("vkDestroySamplerYcbcrConversion", name))
        return (PFN_vkVoidFunction) &wrap_DestroySamplerYcbcrConversion<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySamplerYcbcrConversionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySamplerYcbcrConversionKHR; };
    if constexpr (HasDestroySamplerYcbcrConversionKHR) {
      if (!std::strcmp("vkDestroySamplerYcbcrConversionKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySamplerYcbcrConversionKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySemaphore; };
    if constexpr (HasDestroySemaphore) {
      if (!std::strcmp("vkDestroySemaphore", name))
        return (PFN_vkVoidFunction) &wrap_DestroySemaphore<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyShaderEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyShaderEXT; };
    if constexpr (HasDestroyShaderEXT) {
      if (!std::strcmp("vkDestroyShaderEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyShaderEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyShaderModule = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyShaderModule; };
    if constexpr (HasDestroyShaderModule) {
      if (!std::strcmp("vkDestroyShaderModule", name))
        return (PFN_vkVoidFunction) &wrap_DestroyShaderModule<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySwapchainKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySwapchainKHR; };
    if constexpr (HasDestroySwapchainKHR) {
      if (!std::strcmp("vkDestroySwapchainKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySwapchainKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyTensorARM; };
    if constexpr (HasDestroyTensorARM) {
      if (!std::strcmp("vkDestroyTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyTensorARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyTensorViewARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyTensorViewARM; };
    if constexpr (HasDestroyTensorViewARM) {
      if (!std::strcmp("vkDestroyTensorViewARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyTensorViewARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyValidationCacheEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyValidationCacheEXT; };
    if constexpr (HasDestroyValidationCacheEXT) {
      if (!std::strcmp("vkDestroyValidationCacheEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyValidationCacheEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyVideoSessionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyVideoSessionKHR; };
    if constexpr (HasDestroyVideoSessionKHR) {
      if (!std::strcmp("vkDestroyVideoSessionKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyVideoSessionKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyVideoSessionParametersKHR; };
    if constexpr (HasDestroyVideoSessionParametersKHR) {
      if (!std::strcmp("vkDestroyVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyVideoSessionParametersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDeviceWaitIdle = requires(const DeviceOverrides& t) { &DeviceOverrides::DeviceWaitIdle; };
    if constexpr (HasDeviceWaitIdle) {
      if (!std::strcmp("vkDeviceWaitIdle", name))
        return (PFN_vkVoidFunction) &wrap_DeviceWaitIdle<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDisplayPowerControlEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DisplayPowerControlEXT; };
    if constexpr (HasDisplayPowerControlEXT) {
      if (!std::strcmp("vkDisplayPowerControlEXT", name))
        return (PFN_vkVoidFunction) &wrap_DisplayPowerControlEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEndCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::EndCommandBuffer; };
    if constexpr (HasEndCommandBuffer) {
      if (!std::strcmp("vkEndCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_EndCommandBuffer<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasExportMetalObjectsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ExportMetalObjectsEXT; };
    if constexpr (HasExportMetalObjectsEXT) {
      if (!std::strcmp("vkExportMetalObjectsEXT", name))
        return (PFN_vkVoidFunction) &wrap_ExportMetalObjectsEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasFlushMappedMemoryRanges = requires(const DeviceOverrides& t) { &DeviceOverrides::FlushMappedMemoryRanges; };
    if constexpr (HasFlushMappedMemoryRanges) {
      if (!std::strcmp("vkFlushMappedMemoryRanges", name))
        return (PFN_vkVoidFunction) &wrap_FlushMappedMemoryRanges<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasFreeCommandBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeCommandBuffers; };
    if constexpr (HasFreeCommandBuffers) {
      if (!std::strcmp("vkFreeCommandBuffers", name))
        return (PFN_vkVoidFunction) &wrap_FreeCommandBuffers<InstanceOverrides, DeviceOverrides>;
    }
    else {
      constexpr bool HasAnyCmdBufferOverrides = false
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::BeginCommandBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginConditionalRenderingEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginPerTileExecutionQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQuery; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQueryIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRendering; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginTransformFeedbackEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBuffersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindInvocationMaskHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipeline; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipelineShaderGroupNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadingRateImageNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTileMemoryQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTransformFeedbackBuffersEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructureNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildMicromapsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearAttachments; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearColorImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearDepthStencilImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdControlVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdConvertCooperativeVectorMatrixNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToImageIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToMicromapEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapToMemoryEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyQueryPoolResults; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyTensorARM; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCudaLaunchKernelNV; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerBeginEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerEndEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerInsertEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecodeVideoKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryIndirectCountNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatch; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBase; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBaseKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchDataGraphARM; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphAMDX; } )
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectAMDX; } )
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectCountAMDX; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchTileQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDraw; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterIndirectHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexed; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirect; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectByteCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEncodeVideoKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndConditionalRenderingEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndPerTileExecutionQCOM; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQuery; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQueryIndexedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndTransformFeedbackEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndVideoCodingKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteCommands; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdFillBuffer; } )
#ifdef VK_ENABLE_BETA_EXTENSIONS
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX; } )
#endif
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInsertDebugUtilsLabelEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdOpticalFlowExecuteNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSet2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetQueryPool; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToCoverageEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToOneEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetBlendConstants; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCheckpointNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoarseSampleOrderNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendAdvancedEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEquationEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteMaskEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetConservativeRasterizationModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationModeNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageReductionModeNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorLocationNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullMode; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBounds; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampRangeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMaskKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateEnumNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFace; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFaceEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineRasterizationModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineWidth; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPatchControlPointsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceMarkerINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceOverrideINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPolygonModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopology; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopologyEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetProvokingVertexModeEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationSamplesEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationStreamEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleMaskEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissor; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetShadingRateImageEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilCompareMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOpEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilReference; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnable; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnableEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilWriteMask; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetTessellationDomainOriginEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetVertexInputEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewport; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportShadingRatePaletteNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportSwizzleNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingEnableNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCount; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCountEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSubpassShadingHUAWEI; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirect2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirectKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdateBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdatePipelineIndirectBufferNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarker2AMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarkerAMD; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteMicromapsPropertiesEXT; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2KHR; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::EndCommandBuffer; } )
        || ( requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandBuffer; } )
        ;
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && HasAnyCmdBufferOverrides && !std::strcmp("vkFreeCommandBuffers", name))
        return (PFN_vkVoidFunction) +[](VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) -> void { const auto* dispatch = LookupDispatch(device); dispatch->FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers); };
    }

    constexpr bool HasFreeDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeDescriptorSets; };
    if constexpr (HasFreeDescriptorSets) {
      if (!std::strcmp("vkFreeDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_FreeDescriptorSets<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasFreeMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeMemory; };
    if constexpr (HasFreeMemory) {
      if (!std::strcmp("vkFreeMemory", name))
        return (PFN_vkVoidFunction) &wrap_FreeMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureBuildSizesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureBuildSizesKHR; };
    if constexpr (HasGetAccelerationStructureBuildSizesKHR) {
      if (!std::strcmp("vkGetAccelerationStructureBuildSizesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureBuildSizesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureDeviceAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureDeviceAddressKHR; };
    if constexpr (HasGetAccelerationStructureDeviceAddressKHR) {
      if (!std::strcmp("vkGetAccelerationStructureDeviceAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureDeviceAddressKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureHandleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureHandleNV; };
    if constexpr (HasGetAccelerationStructureHandleNV) {
      if (!std::strcmp("vkGetAccelerationStructureHandleNV", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureHandleNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureMemoryRequirementsNV; };
    if constexpr (HasGetAccelerationStructureMemoryRequirementsNV) {
      if (!std::strcmp("vkGetAccelerationStructureMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureMemoryRequirementsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetAccelerationStructureOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasGetAndroidHardwareBufferPropertiesANDROID = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAndroidHardwareBufferPropertiesANDROID; };
    if constexpr (HasGetAndroidHardwareBufferPropertiesANDROID) {
      if (!std::strcmp("vkGetAndroidHardwareBufferPropertiesANDROID", name))
        return (PFN_vkVoidFunction) &wrap_GetAndroidHardwareBufferPropertiesANDROID<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetBufferCollectionPropertiesFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferCollectionPropertiesFUCHSIA; };
    if constexpr (HasGetBufferCollectionPropertiesFUCHSIA) {
      if (!std::strcmp("vkGetBufferCollectionPropertiesFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferCollectionPropertiesFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetBufferDeviceAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddress; };
    if constexpr (HasGetBufferDeviceAddress) {
      if (!std::strcmp("vkGetBufferDeviceAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddress<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferDeviceAddressEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddressEXT; };
    if constexpr (HasGetBufferDeviceAddressEXT) {
      if (!std::strcmp("vkGetBufferDeviceAddressEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddressEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferDeviceAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddressKHR; };
    if constexpr (HasGetBufferDeviceAddressKHR) {
      if (!std::strcmp("vkGetBufferDeviceAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddressKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements; };
    if constexpr (HasGetBufferMemoryRequirements) {
      if (!std::strcmp("vkGetBufferMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements2; };
    if constexpr (HasGetBufferMemoryRequirements2) {
      if (!std::strcmp("vkGetBufferMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements2KHR; };
    if constexpr (HasGetBufferMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetBufferMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureAddress; };
    if constexpr (HasGetBufferOpaqueCaptureAddress) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureAddress<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureAddressKHR; };
    if constexpr (HasGetBufferOpaqueCaptureAddressKHR) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureAddressKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetBufferOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureDescriptorDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetCalibratedTimestampsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCalibratedTimestampsEXT; };
    if constexpr (HasGetCalibratedTimestampsEXT) {
      if (!std::strcmp("vkGetCalibratedTimestampsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetCalibratedTimestampsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetCalibratedTimestampsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCalibratedTimestampsKHR; };
    if constexpr (HasGetCalibratedTimestampsKHR) {
      if (!std::strcmp("vkGetCalibratedTimestampsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetCalibratedTimestampsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetClusterAccelerationStructureBuildSizesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetClusterAccelerationStructureBuildSizesNV; };
    if constexpr (HasGetClusterAccelerationStructureBuildSizesNV) {
      if (!std::strcmp("vkGetClusterAccelerationStructureBuildSizesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetClusterAccelerationStructureBuildSizesNV<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetCudaModuleCacheNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCudaModuleCacheNV; };
    if constexpr (HasGetCudaModuleCacheNV) {
      if (!std::strcmp("vkGetCudaModuleCacheNV", name))
        return (PFN_vkVoidFunction) &wrap_GetCudaModuleCacheNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetDataGraphPipelineAvailablePropertiesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineAvailablePropertiesARM; };
    if constexpr (HasGetDataGraphPipelineAvailablePropertiesARM) {
      if (!std::strcmp("vkGetDataGraphPipelineAvailablePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineAvailablePropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelinePropertiesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelinePropertiesARM; };
    if constexpr (HasGetDataGraphPipelinePropertiesARM) {
      if (!std::strcmp("vkGetDataGraphPipelinePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelinePropertiesARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelineSessionBindPointRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineSessionBindPointRequirementsARM; };
    if constexpr (HasGetDataGraphPipelineSessionBindPointRequirementsARM) {
      if (!std::strcmp("vkGetDataGraphPipelineSessionBindPointRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineSessionBindPointRequirementsARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelineSessionMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineSessionMemoryRequirementsARM; };
    if constexpr (HasGetDataGraphPipelineSessionMemoryRequirementsARM) {
      if (!std::strcmp("vkGetDataGraphPipelineSessionMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineSessionMemoryRequirementsARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeferredOperationMaxConcurrencyKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeferredOperationMaxConcurrencyKHR; };
    if constexpr (HasGetDeferredOperationMaxConcurrencyKHR) {
      if (!std::strcmp("vkGetDeferredOperationMaxConcurrencyKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeferredOperationMaxConcurrencyKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeferredOperationResultKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeferredOperationResultKHR; };
    if constexpr (HasGetDeferredOperationResultKHR) {
      if (!std::strcmp("vkGetDeferredOperationResultKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeferredOperationResultKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorEXT; };
    if constexpr (HasGetDescriptorEXT) {
      if (!std::strcmp("vkGetDescriptorEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetHostMappingVALVE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetHostMappingVALVE; };
    if constexpr (HasGetDescriptorSetHostMappingVALVE) {
      if (!std::strcmp("vkGetDescriptorSetHostMappingVALVE", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetHostMappingVALVE<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutBindingOffsetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutBindingOffsetEXT; };
    if constexpr (HasGetDescriptorSetLayoutBindingOffsetEXT) {
      if (!std::strcmp("vkGetDescriptorSetLayoutBindingOffsetEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutBindingOffsetEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutHostMappingInfoVALVE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutHostMappingInfoVALVE; };
    if constexpr (HasGetDescriptorSetLayoutHostMappingInfoVALVE) {
      if (!std::strcmp("vkGetDescriptorSetLayoutHostMappingInfoVALVE", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutHostMappingInfoVALVE<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSizeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSizeEXT; };
    if constexpr (HasGetDescriptorSetLayoutSizeEXT) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSizeEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSizeEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSupport = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSupport; };
    if constexpr (HasGetDescriptorSetLayoutSupport) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSupport", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSupport<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSupportKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSupportKHR; };
    if constexpr (HasGetDescriptorSetLayoutSupportKHR) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSupportKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceAccelerationStructureCompatibilityKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceAccelerationStructureCompatibilityKHR; };
    if constexpr (HasGetDeviceAccelerationStructureCompatibilityKHR) {
      if (!std::strcmp("vkGetDeviceAccelerationStructureCompatibilityKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceAccelerationStructureCompatibilityKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceBufferMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceBufferMemoryRequirements; };
    if constexpr (HasGetDeviceBufferMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceBufferMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceBufferMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceBufferMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceBufferMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceBufferMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceBufferMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceBufferMemoryRequirementsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceFaultInfoEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceFaultInfoEXT; };
    if constexpr (HasGetDeviceFaultInfoEXT) {
      if (!std::strcmp("vkGetDeviceFaultInfoEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceFaultInfoEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPeerMemoryFeatures = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPeerMemoryFeatures; };
    if constexpr (HasGetDeviceGroupPeerMemoryFeatures) {
      if (!std::strcmp("vkGetDeviceGroupPeerMemoryFeatures", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPeerMemoryFeatures<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPeerMemoryFeaturesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPeerMemoryFeaturesKHR; };
    if constexpr (HasGetDeviceGroupPeerMemoryFeaturesKHR) {
      if (!std::strcmp("vkGetDeviceGroupPeerMemoryFeaturesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPeerMemoryFeaturesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPresentCapabilitiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPresentCapabilitiesKHR; };
    if constexpr (HasGetDeviceGroupPresentCapabilitiesKHR) {
      if (!std::strcmp("vkGetDeviceGroupPresentCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPresentCapabilitiesKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetDeviceGroupSurfacePresentModes2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupSurfacePresentModes2EXT; };
    if constexpr (HasGetDeviceGroupSurfacePresentModes2EXT) {
      if (!std::strcmp("vkGetDeviceGroupSurfacePresentModes2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupSurfacePresentModes2EXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetDeviceGroupSurfacePresentModesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupSurfacePresentModesKHR; };
    if constexpr (HasGetDeviceGroupSurfacePresentModesKHR) {
      if (!std::strcmp("vkGetDeviceGroupSurfacePresentModesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupSurfacePresentModesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageMemoryRequirements; };
    if constexpr (HasGetDeviceImageMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceImageMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceImageMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceImageMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageMemoryRequirementsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSparseMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSparseMemoryRequirements; };
    if constexpr (HasGetDeviceImageSparseMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceImageSparseMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSparseMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSparseMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSparseMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceImageSparseMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceImageSparseMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSparseMemoryRequirementsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSubresourceLayoutKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSubresourceLayoutKHR; };
    if constexpr (HasGetDeviceImageSubresourceLayoutKHR) {
      if (!std::strcmp("vkGetDeviceImageSubresourceLayoutKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSubresourceLayoutKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryCommitment = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryCommitment; };
    if constexpr (HasGetDeviceMemoryCommitment) {
      if (!std::strcmp("vkGetDeviceMemoryCommitment", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryCommitment<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryOpaqueCaptureAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddress; };
    if constexpr (HasGetDeviceMemoryOpaqueCaptureAddress) {
      if (!std::strcmp("vkGetDeviceMemoryOpaqueCaptureAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryOpaqueCaptureAddress<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryOpaqueCaptureAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddressKHR; };
    if constexpr (HasGetDeviceMemoryOpaqueCaptureAddressKHR) {
      if (!std::strcmp("vkGetDeviceMemoryOpaqueCaptureAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryOpaqueCaptureAddressKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMicromapCompatibilityEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMicromapCompatibilityEXT; };
    if constexpr (HasGetDeviceMicromapCompatibilityEXT) {
      if (!std::strcmp("vkGetDeviceMicromapCompatibilityEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMicromapCompatibilityEXT<InstanceOverrides, DeviceOverrides>;
    }

    if (!std::strcmp("vkGetDeviceProcAddr", name))
      return (PFN_vkVoidFunction) &GetDeviceProcAddr<InstanceOverrides, DeviceOverrides>;

    constexpr bool HasGetDeviceQueue = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceQueue; };
    if constexpr (HasGetDeviceQueue) {
      if (!std::strcmp("vkGetDeviceQueue", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceQueue<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceQueue2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceQueue2; };
    if constexpr (HasGetDeviceQueue2) {
      if (!std::strcmp("vkGetDeviceQueue2", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceQueue2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI; };
    if constexpr (HasGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI) {
      if (!std::strcmp("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceTensorMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceTensorMemoryRequirementsARM; };
    if constexpr (HasGetDeviceTensorMemoryRequirementsARM) {
      if (!std::strcmp("vkGetDeviceTensorMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceTensorMemoryRequirementsARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDynamicRenderingTilePropertiesQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDynamicRenderingTilePropertiesQCOM; };
    if constexpr (HasGetDynamicRenderingTilePropertiesQCOM) {
      if (!std::strcmp("vkGetDynamicRenderingTilePropertiesQCOM", name))
        return (PFN_vkVoidFunction) &wrap_GetDynamicRenderingTilePropertiesQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetEncodedVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetEncodedVideoSessionParametersKHR; };
    if constexpr (HasGetEncodedVideoSessionParametersKHR) {
      if (!std::strcmp("vkGetEncodedVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetEncodedVideoSessionParametersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetEventStatus = requires(const DeviceOverrides& t) { &DeviceOverrides::GetEventStatus; };
    if constexpr (HasGetEventStatus) {
      if (!std::strcmp("vkGetEventStatus", name))
        return (PFN_vkVoidFunction) &wrap_GetEventStatus<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetExecutionGraphPipelineNodeIndexAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExecutionGraphPipelineNodeIndexAMDX; };
    if constexpr (HasGetExecutionGraphPipelineNodeIndexAMDX) {
      if (!std::strcmp("vkGetExecutionGraphPipelineNodeIndexAMDX", name))
        return (PFN_vkVoidFunction) &wrap_GetExecutionGraphPipelineNodeIndexAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetExecutionGraphPipelineScratchSizeAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExecutionGraphPipelineScratchSizeAMDX; };
    if constexpr (HasGetExecutionGraphPipelineScratchSizeAMDX) {
      if (!std::strcmp("vkGetExecutionGraphPipelineScratchSizeAMDX", name))
        return (PFN_vkVoidFunction) &wrap_GetExecutionGraphPipelineScratchSizeAMDX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetExternalComputeQueueDataNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExternalComputeQueueDataNV; };
    if constexpr (HasGetExternalComputeQueueDataNV) {
      if (!std::strcmp("vkGetExternalComputeQueueDataNV", name))
        return (PFN_vkVoidFunction) &wrap_GetExternalComputeQueueDataNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetFenceFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceFdKHR; };
    if constexpr (HasGetFenceFdKHR) {
      if (!std::strcmp("vkGetFenceFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceFdKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetFenceStatus = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceStatus; };
    if constexpr (HasGetFenceStatus) {
      if (!std::strcmp("vkGetFenceStatus", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceStatus<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetFenceWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceWin32HandleKHR; };
    if constexpr (HasGetFenceWin32HandleKHR) {
      if (!std::strcmp("vkGetFenceWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceWin32HandleKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetFramebufferTilePropertiesQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFramebufferTilePropertiesQCOM; };
    if constexpr (HasGetFramebufferTilePropertiesQCOM) {
      if (!std::strcmp("vkGetFramebufferTilePropertiesQCOM", name))
        return (PFN_vkVoidFunction) &wrap_GetFramebufferTilePropertiesQCOM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetGeneratedCommandsMemoryRequirementsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetGeneratedCommandsMemoryRequirementsEXT; };
    if constexpr (HasGetGeneratedCommandsMemoryRequirementsEXT) {
      if (!std::strcmp("vkGetGeneratedCommandsMemoryRequirementsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetGeneratedCommandsMemoryRequirementsEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetGeneratedCommandsMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetGeneratedCommandsMemoryRequirementsNV; };
    if constexpr (HasGetGeneratedCommandsMemoryRequirementsNV) {
      if (!std::strcmp("vkGetGeneratedCommandsMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetGeneratedCommandsMemoryRequirementsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageDrmFormatModifierPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageDrmFormatModifierPropertiesEXT; };
    if constexpr (HasGetImageDrmFormatModifierPropertiesEXT) {
      if (!std::strcmp("vkGetImageDrmFormatModifierPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageDrmFormatModifierPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements; };
    if constexpr (HasGetImageMemoryRequirements) {
      if (!std::strcmp("vkGetImageMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements2; };
    if constexpr (HasGetImageMemoryRequirements2) {
      if (!std::strcmp("vkGetImageMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements2KHR; };
    if constexpr (HasGetImageMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetImageMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetImageOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetImageOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageOpaqueCaptureDescriptorDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements; };
    if constexpr (HasGetImageSparseMemoryRequirements) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements2; };
    if constexpr (HasGetImageSparseMemoryRequirements2) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements2KHR; };
    if constexpr (HasGetImageSparseMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout; };
    if constexpr (HasGetImageSubresourceLayout) {
      if (!std::strcmp("vkGetImageSubresourceLayout", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout2EXT; };
    if constexpr (HasGetImageSubresourceLayout2EXT) {
      if (!std::strcmp("vkGetImageSubresourceLayout2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout2EXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout2KHR; };
    if constexpr (HasGetImageSubresourceLayout2KHR) {
      if (!std::strcmp("vkGetImageSubresourceLayout2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageViewOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageViewOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetImageViewOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetImageViewOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageViewOpaqueCaptureDescriptorDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetLatencyTimingsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetLatencyTimingsNV; };
    if constexpr (HasGetLatencyTimingsNV) {
      if (!std::strcmp("vkGetLatencyTimingsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetLatencyTimingsNV<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasGetMemoryAndroidHardwareBufferANDROID = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryAndroidHardwareBufferANDROID; };
    if constexpr (HasGetMemoryAndroidHardwareBufferANDROID) {
      if (!std::strcmp("vkGetMemoryAndroidHardwareBufferANDROID", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryAndroidHardwareBufferANDROID<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMemoryFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryFdKHR; };
    if constexpr (HasGetMemoryFdKHR) {
      if (!std::strcmp("vkGetMemoryFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryFdKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetMemoryFdPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryFdPropertiesKHR; };
    if constexpr (HasGetMemoryFdPropertiesKHR) {
      if (!std::strcmp("vkGetMemoryFdPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryFdPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetMemoryHostPointerPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryHostPointerPropertiesEXT; };
    if constexpr (HasGetMemoryHostPointerPropertiesEXT) {
      if (!std::strcmp("vkGetMemoryHostPointerPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryHostPointerPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasGetMemoryMetalHandleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryMetalHandleEXT; };
    if constexpr (HasGetMemoryMetalHandleEXT) {
      if (!std::strcmp("vkGetMemoryMetalHandleEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryMetalHandleEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasGetMemoryMetalHandlePropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryMetalHandlePropertiesEXT; };
    if constexpr (HasGetMemoryMetalHandlePropertiesEXT) {
      if (!std::strcmp("vkGetMemoryMetalHandlePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryMetalHandlePropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMemoryRemoteAddressNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryRemoteAddressNV; };
    if constexpr (HasGetMemoryRemoteAddressNV) {
      if (!std::strcmp("vkGetMemoryRemoteAddressNV", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryRemoteAddressNV<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandleKHR; };
    if constexpr (HasGetMemoryWin32HandleKHR) {
      if (!std::strcmp("vkGetMemoryWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandleKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandleNV; };
    if constexpr (HasGetMemoryWin32HandleNV) {
      if (!std::strcmp("vkGetMemoryWin32HandleNV", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandleNV<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandlePropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandlePropertiesKHR; };
    if constexpr (HasGetMemoryWin32HandlePropertiesKHR) {
      if (!std::strcmp("vkGetMemoryWin32HandlePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandlePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetMemoryZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryZirconHandleFUCHSIA; };
    if constexpr (HasGetMemoryZirconHandleFUCHSIA) {
      if (!std::strcmp("vkGetMemoryZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryZirconHandleFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetMemoryZirconHandlePropertiesFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryZirconHandlePropertiesFUCHSIA; };
    if constexpr (HasGetMemoryZirconHandlePropertiesFUCHSIA) {
      if (!std::strcmp("vkGetMemoryZirconHandlePropertiesFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryZirconHandlePropertiesFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMicromapBuildSizesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMicromapBuildSizesEXT; };
    if constexpr (HasGetMicromapBuildSizesEXT) {
      if (!std::strcmp("vkGetMicromapBuildSizesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMicromapBuildSizesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPartitionedAccelerationStructuresBuildSizesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPartitionedAccelerationStructuresBuildSizesNV; };
    if constexpr (HasGetPartitionedAccelerationStructuresBuildSizesNV) {
      if (!std::strcmp("vkGetPartitionedAccelerationStructuresBuildSizesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPartitionedAccelerationStructuresBuildSizesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPastPresentationTimingGOOGLE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPastPresentationTimingGOOGLE; };
    if constexpr (HasGetPastPresentationTimingGOOGLE) {
      if (!std::strcmp("vkGetPastPresentationTimingGOOGLE", name))
        return (PFN_vkVoidFunction) &wrap_GetPastPresentationTimingGOOGLE<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPerformanceParameterINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPerformanceParameterINTEL; };
    if constexpr (HasGetPerformanceParameterINTEL) {
      if (!std::strcmp("vkGetPerformanceParameterINTEL", name))
        return (PFN_vkVoidFunction) &wrap_GetPerformanceParameterINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineBinaryDataKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineBinaryDataKHR; };
    if constexpr (HasGetPipelineBinaryDataKHR) {
      if (!std::strcmp("vkGetPipelineBinaryDataKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineBinaryDataKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineCacheData = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineCacheData; };
    if constexpr (HasGetPipelineCacheData) {
      if (!std::strcmp("vkGetPipelineCacheData", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineCacheData<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutableInternalRepresentationsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutableInternalRepresentationsKHR; };
    if constexpr (HasGetPipelineExecutableInternalRepresentationsKHR) {
      if (!std::strcmp("vkGetPipelineExecutableInternalRepresentationsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutableInternalRepresentationsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutablePropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutablePropertiesKHR; };
    if constexpr (HasGetPipelineExecutablePropertiesKHR) {
      if (!std::strcmp("vkGetPipelineExecutablePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutablePropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutableStatisticsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutableStatisticsKHR; };
    if constexpr (HasGetPipelineExecutableStatisticsKHR) {
      if (!std::strcmp("vkGetPipelineExecutableStatisticsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutableStatisticsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineIndirectDeviceAddressNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineIndirectDeviceAddressNV; };
    if constexpr (HasGetPipelineIndirectDeviceAddressNV) {
      if (!std::strcmp("vkGetPipelineIndirectDeviceAddressNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineIndirectDeviceAddressNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineIndirectMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineIndirectMemoryRequirementsNV; };
    if constexpr (HasGetPipelineIndirectMemoryRequirementsNV) {
      if (!std::strcmp("vkGetPipelineIndirectMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineIndirectMemoryRequirementsNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineKeyKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineKeyKHR; };
    if constexpr (HasGetPipelineKeyKHR) {
      if (!std::strcmp("vkGetPipelineKeyKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineKeyKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelinePropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelinePropertiesEXT; };
    if constexpr (HasGetPipelinePropertiesEXT) {
      if (!std::strcmp("vkGetPipelinePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelinePropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPrivateData = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPrivateData; };
    if constexpr (HasGetPrivateData) {
      if (!std::strcmp("vkGetPrivateData", name))
        return (PFN_vkVoidFunction) &wrap_GetPrivateData<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPrivateDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPrivateDataEXT; };
    if constexpr (HasGetPrivateDataEXT) {
      if (!std::strcmp("vkGetPrivateDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPrivateDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueryPoolResults = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueryPoolResults; };
    if constexpr (HasGetQueryPoolResults) {
      if (!std::strcmp("vkGetQueryPoolResults", name))
        return (PFN_vkVoidFunction) &wrap_GetQueryPoolResults<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueueCheckpointData2NV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueueCheckpointData2NV; };
    if constexpr (HasGetQueueCheckpointData2NV) {
      if (!std::strcmp("vkGetQueueCheckpointData2NV", name))
        return (PFN_vkVoidFunction) &wrap_GetQueueCheckpointData2NV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueueCheckpointDataNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueueCheckpointDataNV; };
    if constexpr (HasGetQueueCheckpointDataNV) {
      if (!std::strcmp("vkGetQueueCheckpointDataNV", name))
        return (PFN_vkVoidFunction) &wrap_GetQueueCheckpointDataNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingCaptureReplayShaderGroupHandlesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingCaptureReplayShaderGroupHandlesKHR; };
    if constexpr (HasGetRayTracingCaptureReplayShaderGroupHandlesKHR) {
      if (!std::strcmp("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingCaptureReplayShaderGroupHandlesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupHandlesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupHandlesKHR; };
    if constexpr (HasGetRayTracingShaderGroupHandlesKHR) {
      if (!std::strcmp("vkGetRayTracingShaderGroupHandlesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupHandlesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupHandlesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupHandlesNV; };
    if constexpr (HasGetRayTracingShaderGroupHandlesNV) {
      if (!std::strcmp("vkGetRayTracingShaderGroupHandlesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupHandlesNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupStackSizeKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupStackSizeKHR; };
    if constexpr (HasGetRayTracingShaderGroupStackSizeKHR) {
      if (!std::strcmp("vkGetRayTracingShaderGroupStackSizeKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupStackSizeKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRefreshCycleDurationGOOGLE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRefreshCycleDurationGOOGLE; };
    if constexpr (HasGetRefreshCycleDurationGOOGLE) {
      if (!std::strcmp("vkGetRefreshCycleDurationGOOGLE", name))
        return (PFN_vkVoidFunction) &wrap_GetRefreshCycleDurationGOOGLE<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRenderAreaGranularity = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRenderAreaGranularity; };
    if constexpr (HasGetRenderAreaGranularity) {
      if (!std::strcmp("vkGetRenderAreaGranularity", name))
        return (PFN_vkVoidFunction) &wrap_GetRenderAreaGranularity<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRenderingAreaGranularityKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRenderingAreaGranularityKHR; };
    if constexpr (HasGetRenderingAreaGranularityKHR) {
      if (!std::strcmp("vkGetRenderingAreaGranularityKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRenderingAreaGranularityKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSamplerOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSamplerOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetSamplerOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetSamplerOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetSamplerOpaqueCaptureDescriptorDataEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasGetScreenBufferPropertiesQNX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetScreenBufferPropertiesQNX; };
    if constexpr (HasGetScreenBufferPropertiesQNX) {
      if (!std::strcmp("vkGetScreenBufferPropertiesQNX", name))
        return (PFN_vkVoidFunction) &wrap_GetScreenBufferPropertiesQNX<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetSemaphoreCounterValue = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreCounterValue; };
    if constexpr (HasGetSemaphoreCounterValue) {
      if (!std::strcmp("vkGetSemaphoreCounterValue", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreCounterValue<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSemaphoreCounterValueKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreCounterValueKHR; };
    if constexpr (HasGetSemaphoreCounterValueKHR) {
      if (!std::strcmp("vkGetSemaphoreCounterValueKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreCounterValueKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSemaphoreFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreFdKHR; };
    if constexpr (HasGetSemaphoreFdKHR) {
      if (!std::strcmp("vkGetSemaphoreFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreFdKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetSemaphoreWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreWin32HandleKHR; };
    if constexpr (HasGetSemaphoreWin32HandleKHR) {
      if (!std::strcmp("vkGetSemaphoreWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreWin32HandleKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetSemaphoreZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreZirconHandleFUCHSIA; };
    if constexpr (HasGetSemaphoreZirconHandleFUCHSIA) {
      if (!std::strcmp("vkGetSemaphoreZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreZirconHandleFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetShaderBinaryDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderBinaryDataEXT; };
    if constexpr (HasGetShaderBinaryDataEXT) {
      if (!std::strcmp("vkGetShaderBinaryDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderBinaryDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderInfoAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderInfoAMD; };
    if constexpr (HasGetShaderInfoAMD) {
      if (!std::strcmp("vkGetShaderInfoAMD", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderInfoAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderModuleCreateInfoIdentifierEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderModuleCreateInfoIdentifierEXT; };
    if constexpr (HasGetShaderModuleCreateInfoIdentifierEXT) {
      if (!std::strcmp("vkGetShaderModuleCreateInfoIdentifierEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderModuleCreateInfoIdentifierEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderModuleIdentifierEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderModuleIdentifierEXT; };
    if constexpr (HasGetShaderModuleIdentifierEXT) {
      if (!std::strcmp("vkGetShaderModuleIdentifierEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderModuleIdentifierEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainCounterEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainCounterEXT; };
    if constexpr (HasGetSwapchainCounterEXT) {
      if (!std::strcmp("vkGetSwapchainCounterEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainCounterEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainImagesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainImagesKHR; };
    if constexpr (HasGetSwapchainImagesKHR) {
      if (!std::strcmp("vkGetSwapchainImagesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainImagesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainStatusKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainStatusKHR; };
    if constexpr (HasGetSwapchainStatusKHR) {
      if (!std::strcmp("vkGetSwapchainStatusKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainStatusKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorMemoryRequirementsARM; };
    if constexpr (HasGetTensorMemoryRequirementsARM) {
      if (!std::strcmp("vkGetTensorMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorMemoryRequirementsARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorOpaqueCaptureDescriptorDataARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorOpaqueCaptureDescriptorDataARM; };
    if constexpr (HasGetTensorOpaqueCaptureDescriptorDataARM) {
      if (!std::strcmp("vkGetTensorOpaqueCaptureDescriptorDataARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorOpaqueCaptureDescriptorDataARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorViewOpaqueCaptureDescriptorDataARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorViewOpaqueCaptureDescriptorDataARM; };
    if constexpr (HasGetTensorViewOpaqueCaptureDescriptorDataARM) {
      if (!std::strcmp("vkGetTensorViewOpaqueCaptureDescriptorDataARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorViewOpaqueCaptureDescriptorDataARM<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetValidationCacheDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetValidationCacheDataEXT; };
    if constexpr (HasGetValidationCacheDataEXT) {
      if (!std::strcmp("vkGetValidationCacheDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetValidationCacheDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetVideoSessionMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetVideoSessionMemoryRequirementsKHR; };
    if constexpr (HasGetVideoSessionMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetVideoSessionMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetVideoSessionMemoryRequirementsKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasImportFenceFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportFenceFdKHR; };
    if constexpr (HasImportFenceFdKHR) {
      if (!std::strcmp("vkImportFenceFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportFenceFdKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasImportFenceWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportFenceWin32HandleKHR; };
    if constexpr (HasImportFenceWin32HandleKHR) {
      if (!std::strcmp("vkImportFenceWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportFenceWin32HandleKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasImportSemaphoreFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreFdKHR; };
    if constexpr (HasImportSemaphoreFdKHR) {
      if (!std::strcmp("vkImportSemaphoreFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreFdKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasImportSemaphoreWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreWin32HandleKHR; };
    if constexpr (HasImportSemaphoreWin32HandleKHR) {
      if (!std::strcmp("vkImportSemaphoreWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreWin32HandleKHR<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasImportSemaphoreZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreZirconHandleFUCHSIA; };
    if constexpr (HasImportSemaphoreZirconHandleFUCHSIA) {
      if (!std::strcmp("vkImportSemaphoreZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreZirconHandleFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasInitializePerformanceApiINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::InitializePerformanceApiINTEL; };
    if constexpr (HasInitializePerformanceApiINTEL) {
      if (!std::strcmp("vkInitializePerformanceApiINTEL", name))
        return (PFN_vkVoidFunction) &wrap_InitializePerformanceApiINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasInvalidateMappedMemoryRanges = requires(const DeviceOverrides& t) { &DeviceOverrides::InvalidateMappedMemoryRanges; };
    if constexpr (HasInvalidateMappedMemoryRanges) {
      if (!std::strcmp("vkInvalidateMappedMemoryRanges", name))
        return (PFN_vkVoidFunction) &wrap_InvalidateMappedMemoryRanges<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasLatencySleepNV = requires(const DeviceOverrides& t) { &DeviceOverrides::LatencySleepNV; };
    if constexpr (HasLatencySleepNV) {
      if (!std::strcmp("vkLatencySleepNV", name))
        return (PFN_vkVoidFunction) &wrap_LatencySleepNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMapMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::MapMemory; };
    if constexpr (HasMapMemory) {
      if (!std::strcmp("vkMapMemory", name))
        return (PFN_vkVoidFunction) &wrap_MapMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMapMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::MapMemory2KHR; };
    if constexpr (HasMapMemory2KHR) {
      if (!std::strcmp("vkMapMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_MapMemory2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMergePipelineCaches = requires(const DeviceOverrides& t) { &DeviceOverrides::MergePipelineCaches; };
    if constexpr (HasMergePipelineCaches) {
      if (!std::strcmp("vkMergePipelineCaches", name))
        return (PFN_vkVoidFunction) &wrap_MergePipelineCaches<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMergeValidationCachesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::MergeValidationCachesEXT; };
    if constexpr (HasMergeValidationCachesEXT) {
      if (!std::strcmp("vkMergeValidationCachesEXT", name))
        return (PFN_vkVoidFunction) &wrap_MergeValidationCachesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueBeginDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueBeginDebugUtilsLabelEXT; };
    if constexpr (HasQueueBeginDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueBeginDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueBeginDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueBindSparse = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueBindSparse; };
    if constexpr (HasQueueBindSparse) {
      if (!std::strcmp("vkQueueBindSparse", name))
        return (PFN_vkVoidFunction) &wrap_QueueBindSparse<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueEndDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueEndDebugUtilsLabelEXT; };
    if constexpr (HasQueueEndDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueEndDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueEndDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueInsertDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueInsertDebugUtilsLabelEXT; };
    if constexpr (HasQueueInsertDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueInsertDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueInsertDebugUtilsLabelEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueNotifyOutOfBandNV = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueNotifyOutOfBandNV; };
    if constexpr (HasQueueNotifyOutOfBandNV) {
      if (!std::strcmp("vkQueueNotifyOutOfBandNV", name))
        return (PFN_vkVoidFunction) &wrap_QueueNotifyOutOfBandNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueuePresentKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::QueuePresentKHR; };
    if constexpr (HasQueuePresentKHR) {
      if (!std::strcmp("vkQueuePresentKHR", name))
        return (PFN_vkVoidFunction) &wrap_QueuePresentKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSetPerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSetPerformanceConfigurationINTEL; };
    if constexpr (HasQueueSetPerformanceConfigurationINTEL) {
      if (!std::strcmp("vkQueueSetPerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_QueueSetPerformanceConfigurationINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit; };
    if constexpr (HasQueueSubmit) {
      if (!std::strcmp("vkQueueSubmit", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit2 = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit2; };
    if constexpr (HasQueueSubmit2) {
      if (!std::strcmp("vkQueueSubmit2", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit2<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit2KHR; };
    if constexpr (HasQueueSubmit2KHR) {
      if (!std::strcmp("vkQueueSubmit2KHR", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueWaitIdle = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueWaitIdle; };
    if constexpr (HasQueueWaitIdle) {
      if (!std::strcmp("vkQueueWaitIdle", name))
        return (PFN_vkVoidFunction) &wrap_QueueWaitIdle<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasRegisterDeviceEventEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::RegisterDeviceEventEXT; };
    if constexpr (HasRegisterDeviceEventEXT) {
      if (!std::strcmp("vkRegisterDeviceEventEXT", name))
        return (PFN_vkVoidFunction) &wrap_RegisterDeviceEventEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasRegisterDisplayEventEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::RegisterDisplayEventEXT; };
    if constexpr (HasRegisterDisplayEventEXT) {
      if (!std::strcmp("vkRegisterDisplayEventEXT", name))
        return (PFN_vkVoidFunction) &wrap_RegisterDisplayEventEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseCapturedPipelineDataKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseCapturedPipelineDataKHR; };
    if constexpr (HasReleaseCapturedPipelineDataKHR) {
      if (!std::strcmp("vkReleaseCapturedPipelineDataKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseCapturedPipelineDataKHR<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasReleaseFullScreenExclusiveModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseFullScreenExclusiveModeEXT; };
    if constexpr (HasReleaseFullScreenExclusiveModeEXT) {
      if (!std::strcmp("vkReleaseFullScreenExclusiveModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseFullScreenExclusiveModeEXT<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasReleasePerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleasePerformanceConfigurationINTEL; };
    if constexpr (HasReleasePerformanceConfigurationINTEL) {
      if (!std::strcmp("vkReleasePerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_ReleasePerformanceConfigurationINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseProfilingLockKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseProfilingLockKHR; };
    if constexpr (HasReleaseProfilingLockKHR) {
      if (!std::strcmp("vkReleaseProfilingLockKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseProfilingLockKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseSwapchainImagesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseSwapchainImagesEXT; };
    if constexpr (HasReleaseSwapchainImagesEXT) {
      if (!std::strcmp("vkReleaseSwapchainImagesEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseSwapchainImagesEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseSwapchainImagesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseSwapchainImagesKHR; };
    if constexpr (HasReleaseSwapchainImagesKHR) {
      if (!std::strcmp("vkReleaseSwapchainImagesKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseSwapchainImagesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandBuffer; };
    if constexpr (HasResetCommandBuffer) {
      if (!std::strcmp("vkResetCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_ResetCommandBuffer<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandPool; };
    if constexpr (HasResetCommandPool) {
      if (!std::strcmp("vkResetCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetCommandPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetDescriptorPool; };
    if constexpr (HasResetDescriptorPool) {
      if (!std::strcmp("vkResetDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetDescriptorPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetEvent; };
    if constexpr (HasResetEvent) {
      if (!std::strcmp("vkResetEvent", name))
        return (PFN_vkVoidFunction) &wrap_ResetEvent<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetFences = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetFences; };
    if constexpr (HasResetFences) {
      if (!std::strcmp("vkResetFences", name))
        return (PFN_vkVoidFunction) &wrap_ResetFences<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetQueryPool; };
    if constexpr (HasResetQueryPool) {
      if (!std::strcmp("vkResetQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetQueryPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetQueryPoolEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetQueryPoolEXT; };
    if constexpr (HasResetQueryPoolEXT) {
      if (!std::strcmp("vkResetQueryPoolEXT", name))
        return (PFN_vkVoidFunction) &wrap_ResetQueryPoolEXT<InstanceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasSetBufferCollectionBufferConstraintsFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::SetBufferCollectionBufferConstraintsFUCHSIA; };
    if constexpr (HasSetBufferCollectionBufferConstraintsFUCHSIA) {
      if (!std::strcmp("vkSetBufferCollectionBufferConstraintsFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_SetBufferCollectionBufferConstraintsFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasSetBufferCollectionImageConstraintsFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::SetBufferCollectionImageConstraintsFUCHSIA; };
    if constexpr (HasSetBufferCollectionImageConstraintsFUCHSIA) {
      if (!std::strcmp("vkSetBufferCollectionImageConstraintsFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_SetBufferCollectionImageConstraintsFUCHSIA<InstanceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasSetDebugUtilsObjectNameEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDebugUtilsObjectNameEXT; };
    if constexpr (HasSetDebugUtilsObjectNameEXT) {
      if (!std::strcmp("vkSetDebugUtilsObjectNameEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDebugUtilsObjectNameEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetDebugUtilsObjectTagEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDebugUtilsObjectTagEXT; };
    if constexpr (HasSetDebugUtilsObjectTagEXT) {
      if (!std::strcmp("vkSetDebugUtilsObjectTagEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDebugUtilsObjectTagEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetDeviceMemoryPriorityEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDeviceMemoryPriorityEXT; };
    if constexpr (HasSetDeviceMemoryPriorityEXT) {
      if (!std::strcmp("vkSetDeviceMemoryPriorityEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDeviceMemoryPriorityEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::SetEvent; };
    if constexpr (HasSetEvent) {
      if (!std::strcmp("vkSetEvent", name))
        return (PFN_vkVoidFunction) &wrap_SetEvent<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetHdrMetadataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetHdrMetadataEXT; };
    if constexpr (HasSetHdrMetadataEXT) {
      if (!std::strcmp("vkSetHdrMetadataEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetHdrMetadataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLatencyMarkerNV = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLatencyMarkerNV; };
    if constexpr (HasSetLatencyMarkerNV) {
      if (!std::strcmp("vkSetLatencyMarkerNV", name))
        return (PFN_vkVoidFunction) &wrap_SetLatencyMarkerNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLatencySleepModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLatencySleepModeNV; };
    if constexpr (HasSetLatencySleepModeNV) {
      if (!std::strcmp("vkSetLatencySleepModeNV", name))
        return (PFN_vkVoidFunction) &wrap_SetLatencySleepModeNV<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLocalDimmingAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLocalDimmingAMD; };
    if constexpr (HasSetLocalDimmingAMD) {
      if (!std::strcmp("vkSetLocalDimmingAMD", name))
        return (PFN_vkVoidFunction) &wrap_SetLocalDimmingAMD<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetPrivateData = requires(const DeviceOverrides& t) { &DeviceOverrides::SetPrivateData; };
    if constexpr (HasSetPrivateData) {
      if (!std::strcmp("vkSetPrivateData", name))
        return (PFN_vkVoidFunction) &wrap_SetPrivateData<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetPrivateDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetPrivateDataEXT; };
    if constexpr (HasSetPrivateDataEXT) {
      if (!std::strcmp("vkSetPrivateDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetPrivateDataEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSignalSemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::SignalSemaphore; };
    if constexpr (HasSignalSemaphore) {
      if (!std::strcmp("vkSignalSemaphore", name))
        return (PFN_vkVoidFunction) &wrap_SignalSemaphore<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSignalSemaphoreKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::SignalSemaphoreKHR; };
    if constexpr (HasSignalSemaphoreKHR) {
      if (!std::strcmp("vkSignalSemaphoreKHR", name))
        return (PFN_vkVoidFunction) &wrap_SignalSemaphoreKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTransitionImageLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::TransitionImageLayoutEXT; };
    if constexpr (HasTransitionImageLayoutEXT) {
      if (!std::strcmp("vkTransitionImageLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_TransitionImageLayoutEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTrimCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::TrimCommandPool; };
    if constexpr (HasTrimCommandPool) {
      if (!std::strcmp("vkTrimCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_TrimCommandPool<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTrimCommandPoolKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::TrimCommandPoolKHR; };
    if constexpr (HasTrimCommandPoolKHR) {
      if (!std::strcmp("vkTrimCommandPoolKHR", name))
        return (PFN_vkVoidFunction) &wrap_TrimCommandPoolKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUninitializePerformanceApiINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::UninitializePerformanceApiINTEL; };
    if constexpr (HasUninitializePerformanceApiINTEL) {
      if (!std::strcmp("vkUninitializePerformanceApiINTEL", name))
        return (PFN_vkVoidFunction) &wrap_UninitializePerformanceApiINTEL<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUnmapMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::UnmapMemory; };
    if constexpr (HasUnmapMemory) {
      if (!std::strcmp("vkUnmapMemory", name))
        return (PFN_vkVoidFunction) &wrap_UnmapMemory<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUnmapMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UnmapMemory2KHR; };
    if constexpr (HasUnmapMemory2KHR) {
      if (!std::strcmp("vkUnmapMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_UnmapMemory2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSetWithTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSetWithTemplate; };
    if constexpr (HasUpdateDescriptorSetWithTemplate) {
      if (!std::strcmp("vkUpdateDescriptorSetWithTemplate", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSetWithTemplate<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSetWithTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSetWithTemplateKHR; };
    if constexpr (HasUpdateDescriptorSetWithTemplateKHR) {
      if (!std::strcmp("vkUpdateDescriptorSetWithTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSetWithTemplateKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSets; };
    if constexpr (HasUpdateDescriptorSets) {
      if (!std::strcmp("vkUpdateDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSets<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateIndirectExecutionSetPipelineEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateIndirectExecutionSetPipelineEXT; };
    if constexpr (HasUpdateIndirectExecutionSetPipelineEXT) {
      if (!std::strcmp("vkUpdateIndirectExecutionSetPipelineEXT", name))
        return (PFN_vkVoidFunction) &wrap_UpdateIndirectExecutionSetPipelineEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateIndirectExecutionSetShaderEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateIndirectExecutionSetShaderEXT; };
    if constexpr (HasUpdateIndirectExecutionSetShaderEXT) {
      if (!std::strcmp("vkUpdateIndirectExecutionSetShaderEXT", name))
        return (PFN_vkVoidFunction) &wrap_UpdateIndirectExecutionSetShaderEXT<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateVideoSessionParametersKHR; };
    if constexpr (HasUpdateVideoSessionParametersKHR) {
      if (!std::strcmp("vkUpdateVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_UpdateVideoSessionParametersKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForFences = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForFences; };
    if constexpr (HasWaitForFences) {
      if (!std::strcmp("vkWaitForFences", name))
        return (PFN_vkVoidFunction) &wrap_WaitForFences<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForPresent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForPresent2KHR; };
    if constexpr (HasWaitForPresent2KHR) {
      if (!std::strcmp("vkWaitForPresent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitForPresent2KHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForPresentKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForPresentKHR; };
    if constexpr (HasWaitForPresentKHR) {
      if (!std::strcmp("vkWaitForPresentKHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitForPresentKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitSemaphores = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitSemaphores; };
    if constexpr (HasWaitSemaphores) {
      if (!std::strcmp("vkWaitSemaphores", name))
        return (PFN_vkVoidFunction) &wrap_WaitSemaphores<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitSemaphoresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitSemaphoresKHR; };
    if constexpr (HasWaitSemaphoresKHR) {
      if (!std::strcmp("vkWaitSemaphoresKHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitSemaphoresKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWriteAccelerationStructuresPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WriteAccelerationStructuresPropertiesKHR; };
    if constexpr (HasWriteAccelerationStructuresPropertiesKHR) {
      if (!std::strcmp("vkWriteAccelerationStructuresPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_WriteAccelerationStructuresPropertiesKHR<InstanceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWriteMicromapsPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::WriteMicromapsPropertiesEXT; };
    if constexpr (HasWriteMicromapsPropertiesEXT) {
      if (!std::strcmp("vkWriteMicromapsPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_WriteMicromapsPropertiesEXT<InstanceOverrides, DeviceOverrides>;
    }

    if (dispatch)
      return dispatch->GetDeviceProcAddr(device, name);
    else
      return NULL;
  }

  namespace helpers {
    template <typename EnumType>
    constexpr const char* enumString(EnumType type);

    template <> constexpr const char* enumString<VkAccelerationStructureBuildTypeKHR>(VkAccelerationStructureBuildTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureBuildTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureCompatibilityKHR>(VkAccelerationStructureCompatibilityKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureCompatibilityKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureCreateFlagBitsKHR>(VkAccelerationStructureCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV";
        default: return "VkAccelerationStructureCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureMemoryRequirementsTypeNV>(VkAccelerationStructureMemoryRequirementsTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_NV_MAX_ENUM";
        default: return "VkAccelerationStructureMemoryRequirementsTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureMotionInstanceTypeNV>(VkAccelerationStructureMotionInstanceTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_NV_MAX_ENUM";
        default: return "VkAccelerationStructureMotionInstanceTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureTypeKHR>(VkAccelerationStructureTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_TYPE_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccessFlagBits>(VkAccessFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ACCESS_INDIRECT_COMMAND_READ_BIT";
        case static_cast<uint64_t>(2): return "VK_ACCESS_INDEX_READ_BIT";
        case static_cast<uint64_t>(4): return "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT";
        case static_cast<uint64_t>(8): return "VK_ACCESS_UNIFORM_READ_BIT";
        case static_cast<uint64_t>(16): return "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(32): return "VK_ACCESS_SHADER_READ_BIT";
        case static_cast<uint64_t>(64): return "VK_ACCESS_SHADER_WRITE_BIT";
        case static_cast<uint64_t>(128): return "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(256): return "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT";
        case static_cast<uint64_t>(512): return "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(1024): return "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT";
        case static_cast<uint64_t>(2048): return "VK_ACCESS_TRANSFER_READ_BIT";
        case static_cast<uint64_t>(4096): return "VK_ACCESS_TRANSFER_WRITE_BIT";
        case static_cast<uint64_t>(8192): return "VK_ACCESS_HOST_READ_BIT";
        case static_cast<uint64_t>(16384): return "VK_ACCESS_HOST_WRITE_BIT";
        case static_cast<uint64_t>(32768): return "VK_ACCESS_MEMORY_READ_BIT";
        case static_cast<uint64_t>(65536): return "VK_ACCESS_MEMORY_WRITE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_ACCESS_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(0): return "VK_ACCESS_NONE";
        case static_cast<uint64_t>(33554432): return "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT";
        case static_cast<uint64_t>(134217728): return "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT";
        case static_cast<uint64_t>(524288): return "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR";
        case static_cast<uint64_t>(4194304): return "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR";
        default: return "VkAccessFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAntiLagModeAMD>(VkAntiLagModeAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD";
        case static_cast<uint64_t>(1): return "VK_ANTI_LAG_MODE_ON_AMD";
        case static_cast<uint64_t>(2): return "VK_ANTI_LAG_MODE_OFF_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_ANTI_LAG_MODE_AMD_MAX_ENUM";
        default: return "VkAntiLagModeAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAntiLagStageAMD>(VkAntiLagStageAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ANTI_LAG_STAGE_INPUT_AMD";
        case static_cast<uint64_t>(1): return "VK_ANTI_LAG_STAGE_PRESENT_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_ANTI_LAG_STAGE_AMD_MAX_ENUM";
        default: return "VkAntiLagStageAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentDescriptionFlagBits>(VkAttachmentDescriptionFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM";
        default: return "VkAttachmentDescriptionFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentLoadOp>(VkAttachmentLoadOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ATTACHMENT_LOAD_OP_LOAD";
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_LOAD_OP_CLEAR";
        case static_cast<uint64_t>(2): return "VK_ATTACHMENT_LOAD_OP_DONT_CARE";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_LOAD_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000400000): return "VK_ATTACHMENT_LOAD_OP_NONE";
        default: return "VkAttachmentLoadOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentStoreOp>(VkAttachmentStoreOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ATTACHMENT_STORE_OP_STORE";
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_STORE_OP_DONT_CARE";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_STORE_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000301000): return "VK_ATTACHMENT_STORE_OP_NONE";
        default: return "VkAttachmentStoreOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendFactor>(VkBlendFactor type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_FACTOR_ZERO";
        case static_cast<uint64_t>(1): return "VK_BLEND_FACTOR_ONE";
        case static_cast<uint64_t>(2): return "VK_BLEND_FACTOR_SRC_COLOR";
        case static_cast<uint64_t>(3): return "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR";
        case static_cast<uint64_t>(4): return "VK_BLEND_FACTOR_DST_COLOR";
        case static_cast<uint64_t>(5): return "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR";
        case static_cast<uint64_t>(6): return "VK_BLEND_FACTOR_SRC_ALPHA";
        case static_cast<uint64_t>(7): return "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA";
        case static_cast<uint64_t>(8): return "VK_BLEND_FACTOR_DST_ALPHA";
        case static_cast<uint64_t>(9): return "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA";
        case static_cast<uint64_t>(10): return "VK_BLEND_FACTOR_CONSTANT_COLOR";
        case static_cast<uint64_t>(11): return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR";
        case static_cast<uint64_t>(12): return "VK_BLEND_FACTOR_CONSTANT_ALPHA";
        case static_cast<uint64_t>(13): return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA";
        case static_cast<uint64_t>(14): return "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE";
        case static_cast<uint64_t>(15): return "VK_BLEND_FACTOR_SRC1_COLOR";
        case static_cast<uint64_t>(16): return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR";
        case static_cast<uint64_t>(17): return "VK_BLEND_FACTOR_SRC1_ALPHA";
        case static_cast<uint64_t>(18): return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_FACTOR_MAX_ENUM";
        default: return "VkBlendFactor_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendOp>(VkBlendOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_OP_ADD";
        case static_cast<uint64_t>(1): return "VK_BLEND_OP_SUBTRACT";
        case static_cast<uint64_t>(2): return "VK_BLEND_OP_REVERSE_SUBTRACT";
        case static_cast<uint64_t>(3): return "VK_BLEND_OP_MIN";
        case static_cast<uint64_t>(4): return "VK_BLEND_OP_MAX";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000148000): return "VK_BLEND_OP_ZERO_EXT";
        case static_cast<uint64_t>(1000148001): return "VK_BLEND_OP_SRC_EXT";
        case static_cast<uint64_t>(1000148002): return "VK_BLEND_OP_DST_EXT";
        case static_cast<uint64_t>(1000148003): return "VK_BLEND_OP_SRC_OVER_EXT";
        case static_cast<uint64_t>(1000148004): return "VK_BLEND_OP_DST_OVER_EXT";
        case static_cast<uint64_t>(1000148005): return "VK_BLEND_OP_SRC_IN_EXT";
        case static_cast<uint64_t>(1000148006): return "VK_BLEND_OP_DST_IN_EXT";
        case static_cast<uint64_t>(1000148007): return "VK_BLEND_OP_SRC_OUT_EXT";
        case static_cast<uint64_t>(1000148008): return "VK_BLEND_OP_DST_OUT_EXT";
        case static_cast<uint64_t>(1000148009): return "VK_BLEND_OP_SRC_ATOP_EXT";
        case static_cast<uint64_t>(1000148010): return "VK_BLEND_OP_DST_ATOP_EXT";
        case static_cast<uint64_t>(1000148011): return "VK_BLEND_OP_XOR_EXT";
        case static_cast<uint64_t>(1000148012): return "VK_BLEND_OP_MULTIPLY_EXT";
        case static_cast<uint64_t>(1000148013): return "VK_BLEND_OP_SCREEN_EXT";
        case static_cast<uint64_t>(1000148014): return "VK_BLEND_OP_OVERLAY_EXT";
        case static_cast<uint64_t>(1000148015): return "VK_BLEND_OP_DARKEN_EXT";
        case static_cast<uint64_t>(1000148016): return "VK_BLEND_OP_LIGHTEN_EXT";
        case static_cast<uint64_t>(1000148017): return "VK_BLEND_OP_COLORDODGE_EXT";
        case static_cast<uint64_t>(1000148018): return "VK_BLEND_OP_COLORBURN_EXT";
        case static_cast<uint64_t>(1000148019): return "VK_BLEND_OP_HARDLIGHT_EXT";
        case static_cast<uint64_t>(1000148020): return "VK_BLEND_OP_SOFTLIGHT_EXT";
        case static_cast<uint64_t>(1000148021): return "VK_BLEND_OP_DIFFERENCE_EXT";
        case static_cast<uint64_t>(1000148022): return "VK_BLEND_OP_EXCLUSION_EXT";
        case static_cast<uint64_t>(1000148023): return "VK_BLEND_OP_INVERT_EXT";
        case static_cast<uint64_t>(1000148024): return "VK_BLEND_OP_INVERT_RGB_EXT";
        case static_cast<uint64_t>(1000148025): return "VK_BLEND_OP_LINEARDODGE_EXT";
        case static_cast<uint64_t>(1000148026): return "VK_BLEND_OP_LINEARBURN_EXT";
        case static_cast<uint64_t>(1000148027): return "VK_BLEND_OP_VIVIDLIGHT_EXT";
        case static_cast<uint64_t>(1000148028): return "VK_BLEND_OP_LINEARLIGHT_EXT";
        case static_cast<uint64_t>(1000148029): return "VK_BLEND_OP_PINLIGHT_EXT";
        case static_cast<uint64_t>(1000148030): return "VK_BLEND_OP_HARDMIX_EXT";
        case static_cast<uint64_t>(1000148031): return "VK_BLEND_OP_HSL_HUE_EXT";
        case static_cast<uint64_t>(1000148032): return "VK_BLEND_OP_HSL_SATURATION_EXT";
        case static_cast<uint64_t>(1000148033): return "VK_BLEND_OP_HSL_COLOR_EXT";
        case static_cast<uint64_t>(1000148034): return "VK_BLEND_OP_HSL_LUMINOSITY_EXT";
        case static_cast<uint64_t>(1000148035): return "VK_BLEND_OP_PLUS_EXT";
        case static_cast<uint64_t>(1000148036): return "VK_BLEND_OP_PLUS_CLAMPED_EXT";
        case static_cast<uint64_t>(1000148037): return "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT";
        case static_cast<uint64_t>(1000148038): return "VK_BLEND_OP_PLUS_DARKER_EXT";
        case static_cast<uint64_t>(1000148039): return "VK_BLEND_OP_MINUS_EXT";
        case static_cast<uint64_t>(1000148040): return "VK_BLEND_OP_MINUS_CLAMPED_EXT";
        case static_cast<uint64_t>(1000148041): return "VK_BLEND_OP_CONTRAST_EXT";
        case static_cast<uint64_t>(1000148042): return "VK_BLEND_OP_INVERT_OVG_EXT";
        case static_cast<uint64_t>(1000148043): return "VK_BLEND_OP_RED_EXT";
        case static_cast<uint64_t>(1000148044): return "VK_BLEND_OP_GREEN_EXT";
        case static_cast<uint64_t>(1000148045): return "VK_BLEND_OP_BLUE_EXT";
        default: return "VkBlendOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendOverlapEXT>(VkBlendOverlapEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_OVERLAP_UNCORRELATED_EXT";
        case static_cast<uint64_t>(1): return "VK_BLEND_OVERLAP_DISJOINT_EXT";
        case static_cast<uint64_t>(2): return "VK_BLEND_OVERLAP_CONJOINT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_OVERLAP_EXT_MAX_ENUM";
        default: return "VkBlendOverlapEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlockMatchWindowCompareModeQCOM>(VkBlockMatchWindowCompareModeQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM";
        case static_cast<uint64_t>(1): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_QCOM_MAX_ENUM";
        default: return "VkBlockMatchWindowCompareModeQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBorderColor>(VkBorderColor type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK";
        case static_cast<uint64_t>(1): return "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK";
        case static_cast<uint64_t>(2): return "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK";
        case static_cast<uint64_t>(3): return "VK_BORDER_COLOR_INT_OPAQUE_BLACK";
        case static_cast<uint64_t>(4): return "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE";
        case static_cast<uint64_t>(5): return "VK_BORDER_COLOR_INT_OPAQUE_WHITE";
        case static_cast<uint64_t>(2147483647): return "VK_BORDER_COLOR_MAX_ENUM";
        case static_cast<uint64_t>(1000287003): return "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT";
        case static_cast<uint64_t>(1000287004): return "VK_BORDER_COLOR_INT_CUSTOM_EXT";
        default: return "VkBorderColor_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBufferCreateFlagBits>(VkBufferCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUFFER_CREATE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2): return "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT";
        case static_cast<uint64_t>(4): return "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_BUFFER_CREATE_PROTECTED_BIT";
        case static_cast<uint64_t>(16): return "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT";
        case static_cast<uint64_t>(32): return "VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR";
        default: return "VkBufferCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBufferUsageFlagBits>(VkBufferUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUFFER_USAGE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_BUFFER_USAGE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(8): return "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(16): return "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT";
        case static_cast<uint64_t>(32): return "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT";
        case static_cast<uint64_t>(64): return "VK_BUFFER_USAGE_INDEX_BUFFER_BIT";
        case static_cast<uint64_t>(128): return "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT";
        case static_cast<uint64_t>(256): return "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(131072): return "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT";
        case static_cast<uint64_t>(8192): return "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT";
        case static_cast<uint64_t>(33554432): return "VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX";
        case static_cast<uint64_t>(32768): return "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(2097152): return "VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT";
        case static_cast<uint64_t>(134217728): return "VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM";
        case static_cast<uint64_t>(524288): return "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR";
        default: return "VkBufferUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildAccelerationStructureFlagBitsKHR>(VkBuildAccelerationStructureFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV";
        case static_cast<uint64_t>(64): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV";
        case static_cast<uint64_t>(2048): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR";
        default: return "VkBuildAccelerationStructureFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildAccelerationStructureModeKHR>(VkBuildAccelerationStructureModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR";
        case static_cast<uint64_t>(1): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_KHR_MAX_ENUM";
        default: return "VkBuildAccelerationStructureModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildMicromapFlagBitsEXT>(VkBuildMicromapFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_MICROMAP_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkBuildMicromapFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildMicromapModeEXT>(VkBuildMicromapModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BUILD_MICROMAP_MODE_BUILD_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_MICROMAP_MODE_EXT_MAX_ENUM";
        default: return "VkBuildMicromapModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkChromaLocation>(VkChromaLocation type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CHROMA_LOCATION_COSITED_EVEN";
        case static_cast<uint64_t>(1): return "VK_CHROMA_LOCATION_MIDPOINT";
        case static_cast<uint64_t>(2147483647): return "VK_CHROMA_LOCATION_MAX_ENUM";
        default: return "VkChromaLocation_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureAddressResolutionFlagBitsNV>(VkClusterAccelerationStructureAddressResolutionFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV";
        case static_cast<uint64_t>(32): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureAddressResolutionFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureClusterFlagBitsNV>(VkClusterAccelerationStructureClusterFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureClusterFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureGeometryFlagBitsNV>(VkClusterAccelerationStructureGeometryFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureGeometryFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureIndexFormatFlagBitsNV>(VkClusterAccelerationStructureIndexFormatFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureIndexFormatFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureOpModeNV>(VkClusterAccelerationStructureOpModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureOpModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureOpTypeNV>(VkClusterAccelerationStructureOpTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(3): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(5): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureOpTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureTypeNV>(VkClusterAccelerationStructureTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoarseSampleOrderTypeNV>(VkCoarseSampleOrderTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV";
        case static_cast<uint64_t>(1): return "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV";
        case static_cast<uint64_t>(2): return "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV";
        case static_cast<uint64_t>(3): return "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COARSE_SAMPLE_ORDER_TYPE_NV_MAX_ENUM";
        default: return "VkCoarseSampleOrderTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkColorComponentFlagBits>(VkColorComponentFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COLOR_COMPONENT_R_BIT";
        case static_cast<uint64_t>(2): return "VK_COLOR_COMPONENT_G_BIT";
        case static_cast<uint64_t>(4): return "VK_COLOR_COMPONENT_B_BIT";
        case static_cast<uint64_t>(8): return "VK_COLOR_COMPONENT_A_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM";
        default: return "VkColorComponentFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkColorSpaceKHR>(VkColorSpaceKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COLOR_SPACE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000104001): return "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104002): return "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT";
        case static_cast<uint64_t>(1000104003): return "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT";
        case static_cast<uint64_t>(1000104004): return "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104005): return "VK_COLOR_SPACE_BT709_LINEAR_EXT";
        case static_cast<uint64_t>(1000104006): return "VK_COLOR_SPACE_BT709_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104007): return "VK_COLOR_SPACE_BT2020_LINEAR_EXT";
        case static_cast<uint64_t>(1000104008): return "VK_COLOR_SPACE_HDR10_ST2084_EXT";
        case static_cast<uint64_t>(1000104009): return "VK_COLOR_SPACE_DOLBYVISION_EXT";
        case static_cast<uint64_t>(1000104010): return "VK_COLOR_SPACE_HDR10_HLG_EXT";
        case static_cast<uint64_t>(1000104011): return "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT";
        case static_cast<uint64_t>(1000104012): return "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104013): return "VK_COLOR_SPACE_PASS_THROUGH_EXT";
        case static_cast<uint64_t>(1000104014): return "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000213000): return "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD";
        default: return "VkColorSpaceKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferLevel>(VkCommandBufferLevel type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMMAND_BUFFER_LEVEL_PRIMARY";
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_LEVEL_SECONDARY";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM";
        default: return "VkCommandBufferLevel_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferResetFlagBits>(VkCommandBufferResetFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandBufferResetFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferUsageFlagBits>(VkCommandBufferUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT";
        case static_cast<uint64_t>(2): return "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT";
        case static_cast<uint64_t>(4): return "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandBufferUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandPoolCreateFlagBits>(VkCommandPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT";
        case static_cast<uint64_t>(2): return "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_COMMAND_POOL_CREATE_PROTECTED_BIT";
        default: return "VkCommandPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandPoolResetFlagBits>(VkCommandPoolResetFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandPoolResetFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCompareOp>(VkCompareOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPARE_OP_NEVER";
        case static_cast<uint64_t>(1): return "VK_COMPARE_OP_LESS";
        case static_cast<uint64_t>(2): return "VK_COMPARE_OP_EQUAL";
        case static_cast<uint64_t>(3): return "VK_COMPARE_OP_LESS_OR_EQUAL";
        case static_cast<uint64_t>(4): return "VK_COMPARE_OP_GREATER";
        case static_cast<uint64_t>(5): return "VK_COMPARE_OP_NOT_EQUAL";
        case static_cast<uint64_t>(6): return "VK_COMPARE_OP_GREATER_OR_EQUAL";
        case static_cast<uint64_t>(7): return "VK_COMPARE_OP_ALWAYS";
        case static_cast<uint64_t>(2147483647): return "VK_COMPARE_OP_MAX_ENUM";
        default: return "VkCompareOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkComponentSwizzle>(VkComponentSwizzle type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPONENT_SWIZZLE_IDENTITY";
        case static_cast<uint64_t>(1): return "VK_COMPONENT_SWIZZLE_ZERO";
        case static_cast<uint64_t>(2): return "VK_COMPONENT_SWIZZLE_ONE";
        case static_cast<uint64_t>(3): return "VK_COMPONENT_SWIZZLE_R";
        case static_cast<uint64_t>(4): return "VK_COMPONENT_SWIZZLE_G";
        case static_cast<uint64_t>(5): return "VK_COMPONENT_SWIZZLE_B";
        case static_cast<uint64_t>(6): return "VK_COMPONENT_SWIZZLE_A";
        case static_cast<uint64_t>(2147483647): return "VK_COMPONENT_SWIZZLE_MAX_ENUM";
        default: return "VkComponentSwizzle_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkComponentTypeKHR>(VkComponentTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPONENT_TYPE_FLOAT16_KHR";
        case static_cast<uint64_t>(1): return "VK_COMPONENT_TYPE_FLOAT32_KHR";
        case static_cast<uint64_t>(2): return "VK_COMPONENT_TYPE_FLOAT64_KHR";
        case static_cast<uint64_t>(3): return "VK_COMPONENT_TYPE_SINT8_KHR";
        case static_cast<uint64_t>(4): return "VK_COMPONENT_TYPE_SINT16_KHR";
        case static_cast<uint64_t>(5): return "VK_COMPONENT_TYPE_SINT32_KHR";
        case static_cast<uint64_t>(6): return "VK_COMPONENT_TYPE_SINT64_KHR";
        case static_cast<uint64_t>(7): return "VK_COMPONENT_TYPE_UINT8_KHR";
        case static_cast<uint64_t>(8): return "VK_COMPONENT_TYPE_UINT16_KHR";
        case static_cast<uint64_t>(9): return "VK_COMPONENT_TYPE_UINT32_KHR";
        case static_cast<uint64_t>(10): return "VK_COMPONENT_TYPE_UINT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COMPONENT_TYPE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000141000): return "VK_COMPONENT_TYPE_BFLOAT16_KHR";
        case static_cast<uint64_t>(1000491000): return "VK_COMPONENT_TYPE_SINT8_PACKED_NV";
        case static_cast<uint64_t>(1000491001): return "VK_COMPONENT_TYPE_UINT8_PACKED_NV";
        case static_cast<uint64_t>(1000491002): return "VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT";
        case static_cast<uint64_t>(1000491003): return "VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT";
        default: return "VkComponentTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCompositeAlphaFlagBitsKHR>(VkCompositeAlphaFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COMPOSITE_ALPHA_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkCompositeAlphaFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkConditionalRenderingFlagBitsEXT>(VkConditionalRenderingFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_CONDITIONAL_RENDERING_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkConditionalRenderingFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkConservativeRasterizationModeEXT>(VkConservativeRasterizationModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT";
        case static_cast<uint64_t>(1): return "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT";
        case static_cast<uint64_t>(2): return "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_CONSERVATIVE_RASTERIZATION_MODE_EXT_MAX_ENUM";
        default: return "VkConservativeRasterizationModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCooperativeVectorMatrixLayoutNV>(VkCooperativeVectorMatrixLayoutNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV";
        case static_cast<uint64_t>(1): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV";
        case static_cast<uint64_t>(2): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV";
        case static_cast<uint64_t>(3): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_NV_MAX_ENUM";
        default: return "VkCooperativeVectorMatrixLayoutNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCopyAccelerationStructureModeKHR>(VkCopyAccelerationStructureModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR";
        case static_cast<uint64_t>(1): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR";
        case static_cast<uint64_t>(3): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR";
        default: return "VkCopyAccelerationStructureModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCopyMicromapModeEXT>(VkCopyMicromapModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COPY_MICROMAP_MODE_CLONE_EXT";
        case static_cast<uint64_t>(1): return "VK_COPY_MICROMAP_MODE_SERIALIZE_EXT";
        case static_cast<uint64_t>(2): return "VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT";
        case static_cast<uint64_t>(3): return "VK_COPY_MICROMAP_MODE_COMPACT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_COPY_MICROMAP_MODE_EXT_MAX_ENUM";
        default: return "VkCopyMicromapModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoverageModulationModeNV>(VkCoverageModulationModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COVERAGE_MODULATION_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_COVERAGE_MODULATION_MODE_RGB_NV";
        case static_cast<uint64_t>(2): return "VK_COVERAGE_MODULATION_MODE_ALPHA_NV";
        case static_cast<uint64_t>(3): return "VK_COVERAGE_MODULATION_MODE_RGBA_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COVERAGE_MODULATION_MODE_NV_MAX_ENUM";
        default: return "VkCoverageModulationModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoverageReductionModeNV>(VkCoverageReductionModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COVERAGE_REDUCTION_MODE_MERGE_NV";
        case static_cast<uint64_t>(1): return "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COVERAGE_REDUCTION_MODE_NV_MAX_ENUM";
        default: return "VkCoverageReductionModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCubicFilterWeightsQCOM>(VkCubicFilterWeightsQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM";
        case static_cast<uint64_t>(1): return "VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM";
        case static_cast<uint64_t>(2): return "VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM";
        case static_cast<uint64_t>(3): return "VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_CUBIC_FILTER_WEIGHTS_QCOM_MAX_ENUM";
        default: return "VkCubicFilterWeightsQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCullModeFlagBits>(VkCullModeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CULL_MODE_NONE";
        case static_cast<uint64_t>(1): return "VK_CULL_MODE_FRONT_BIT";
        case static_cast<uint64_t>(2): return "VK_CULL_MODE_BACK_BIT";
        case static_cast<uint64_t>(3): return "VK_CULL_MODE_FRONT_AND_BACK";
        case static_cast<uint64_t>(2147483647): return "VK_CULL_MODE_FLAG_BITS_MAX_ENUM";
        default: return "VkCullModeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelinePropertyARM>(VkDataGraphPipelinePropertyARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM";
        case static_cast<uint64_t>(1): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelinePropertyARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelineSessionBindPointARM>(VkDataGraphPipelineSessionBindPointARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelineSessionBindPointARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelineSessionBindPointTypeARM>(VkDataGraphPipelineSessionBindPointTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelineSessionBindPointTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugReportFlagBitsEXT>(VkDebugReportFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_REPORT_INFORMATION_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_REPORT_WARNING_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_DEBUG_REPORT_ERROR_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_REPORT_DEBUG_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_REPORT_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDebugReportFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugReportObjectTypeEXT>(VkDebugReportObjectTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT";
        case static_cast<uint64_t>(1): return "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT";
        case static_cast<uint64_t>(3): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT";
        case static_cast<uint64_t>(5): return "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT";
        case static_cast<uint64_t>(6): return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT";
        case static_cast<uint64_t>(7): return "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT";
        case static_cast<uint64_t>(8): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT";
        case static_cast<uint64_t>(9): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT";
        case static_cast<uint64_t>(10): return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT";
        case static_cast<uint64_t>(11): return "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT";
        case static_cast<uint64_t>(12): return "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT";
        case static_cast<uint64_t>(13): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT";
        case static_cast<uint64_t>(14): return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT";
        case static_cast<uint64_t>(15): return "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT";
        case static_cast<uint64_t>(17): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT";
        case static_cast<uint64_t>(18): return "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT";
        case static_cast<uint64_t>(19): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT";
        case static_cast<uint64_t>(20): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT";
        case static_cast<uint64_t>(21): return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT";
        case static_cast<uint64_t>(22): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT";
        case static_cast<uint64_t>(23): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT";
        case static_cast<uint64_t>(24): return "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT";
        case static_cast<uint64_t>(25): return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT";
        case static_cast<uint64_t>(26): return "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT";
        case static_cast<uint64_t>(27): return "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT";
        case static_cast<uint64_t>(28): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT";
        case static_cast<uint64_t>(29): return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT";
        case static_cast<uint64_t>(30): return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT";
        case static_cast<uint64_t>(33): return "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_REPORT_OBJECT_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT";
        case static_cast<uint64_t>(1000085000): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT";
        case static_cast<uint64_t>(1000165000): return "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT";
        case static_cast<uint64_t>(1000307000): return "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT";
        case static_cast<uint64_t>(1000307001): return "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT";
        case static_cast<uint64_t>(1000366000): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT";
        default: return "VkDebugReportObjectTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugUtilsMessageSeverityFlagBitsEXT>(VkDebugUtilsMessageSeverityFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDebugUtilsMessageSeverityFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugUtilsMessageTypeFlagBitsEXT>(VkDebugUtilsMessageTypeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_EXT_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT";
        default: return "VkDebugUtilsMessageTypeFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDefaultVertexAttributeValueKHR>(VkDefaultVertexAttributeValueKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR";
        case static_cast<uint64_t>(1): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_KHR_MAX_ENUM";
        default: return "VkDefaultVertexAttributeValueKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDependencyFlagBits>(VkDependencyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEPENDENCY_BY_REGION_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_DEPENDENCY_DEVICE_GROUP_BIT";
        case static_cast<uint64_t>(2): return "VK_DEPENDENCY_VIEW_LOCAL_BIT";
        case static_cast<uint64_t>(8): return "VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR";
        default: return "VkDependencyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDepthBiasRepresentationEXT>(VkDepthBiasRepresentationEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT";
        case static_cast<uint64_t>(1): return "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT";
        case static_cast<uint64_t>(2): return "VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPTH_BIAS_REPRESENTATION_EXT_MAX_ENUM";
        default: return "VkDepthBiasRepresentationEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDepthClampModeEXT>(VkDepthClampModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPTH_CLAMP_MODE_EXT_MAX_ENUM";
        default: return "VkDepthClampModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorBindingFlagBits>(VkDescriptorBindingFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM";
        default: return "VkDescriptorBindingFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorPoolCreateFlagBits>(VkDescriptorPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV";
        default: return "VkDescriptorPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorSetLayoutCreateFlagBits>(VkDescriptorSetLayoutCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT";
        case static_cast<uint64_t>(16): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV";
        default: return "VkDescriptorSetLayoutCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorType>(VkDescriptorType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DESCRIPTOR_TYPE_SAMPLER";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE";
        case static_cast<uint64_t>(3): return "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER";
        case static_cast<uint64_t>(5): return "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER";
        case static_cast<uint64_t>(6): return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER";
        case static_cast<uint64_t>(7): return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC";
        case static_cast<uint64_t>(9): return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC";
        case static_cast<uint64_t>(10): return "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000138000): return "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK";
        case static_cast<uint64_t>(1000165000): return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000440000): return "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM";
        case static_cast<uint64_t>(1000440001): return "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM";
        case static_cast<uint64_t>(1000460000): return "VK_DESCRIPTOR_TYPE_TENSOR_ARM";
        case static_cast<uint64_t>(1000351000): return "VK_DESCRIPTOR_TYPE_MUTABLE_EXT";
        case static_cast<uint64_t>(1000570000): return "VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000150000): return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR";
        default: return "VkDescriptorType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorUpdateTemplateType>(VkDescriptorUpdateTemplateType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS";
        default: return "VkDescriptorUpdateTemplateType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceAddressBindingFlagBitsEXT>(VkDeviceAddressBindingFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDeviceAddressBindingFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceAddressBindingTypeEXT>(VkDeviceAddressBindingTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_ADDRESS_BINDING_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceAddressBindingTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceDiagnosticsConfigFlagBitsNV>(VkDeviceDiagnosticsConfigFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkDeviceDiagnosticsConfigFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceEventTypeEXT>(VkDeviceEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceFaultAddressTypeEXT>(VkDeviceFaultAddressTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT";
        case static_cast<uint64_t>(2): return "VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT";
        case static_cast<uint64_t>(3): return "VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT";
        case static_cast<uint64_t>(4): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT";
        case static_cast<uint64_t>(5): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT";
        case static_cast<uint64_t>(6): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_FAULT_ADDRESS_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceFaultAddressTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceFaultVendorBinaryHeaderVersionEXT>(VkDeviceFaultVendorBinaryHeaderVersionEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_EXT_MAX_ENUM";
        default: return "VkDeviceFaultVendorBinaryHeaderVersionEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceGroupPresentModeFlagBitsKHR>(VkDeviceGroupPresentModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkDeviceGroupPresentModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceMemoryReportEventTypeEXT>(VkDeviceMemoryReportEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT";
        case static_cast<uint64_t>(2): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT";
        case static_cast<uint64_t>(3): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceMemoryReportEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceQueueCreateFlagBits>(VkDeviceQueueCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT";
        default: return "VkDeviceQueueCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDirectDriverLoadingModeLUNARG>(VkDirectDriverLoadingModeLUNARG type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG";
        case static_cast<uint64_t>(1): return "VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG";
        case static_cast<uint64_t>(2147483647): return "VK_DIRECT_DRIVER_LOADING_MODE_LUNARG_MAX_ENUM";
        default: return "VkDirectDriverLoadingModeLUNARG_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDiscardRectangleModeEXT>(VkDiscardRectangleModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT";
        case static_cast<uint64_t>(1): return "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISCARD_RECTANGLE_MODE_EXT_MAX_ENUM";
        default: return "VkDiscardRectangleModeEXT_UNKNOWN";
      }
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    template <> constexpr const char* enumString<VkDisplacementMicromapFormatNV>(VkDisplacementMicromapFormatNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV";
        case static_cast<uint64_t>(2): return "VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV";
        case static_cast<uint64_t>(3): return "VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLACEMENT_MICROMAP_FORMAT_NV_MAX_ENUM";
        default: return "VkDisplacementMicromapFormatNV_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkDisplayEventTypeEXT>(VkDisplayEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDisplayEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplayPlaneAlphaFlagBitsKHR>(VkDisplayPlaneAlphaFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkDisplayPlaneAlphaFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplayPowerStateEXT>(VkDisplayPowerStateEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_POWER_STATE_OFF_EXT";
        case static_cast<uint64_t>(1): return "VK_DISPLAY_POWER_STATE_SUSPEND_EXT";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_POWER_STATE_ON_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_POWER_STATE_EXT_MAX_ENUM";
        default: return "VkDisplayPowerStateEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplaySurfaceStereoTypeNV>(VkDisplaySurfaceStereoTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV";
        case static_cast<uint64_t>(3): return "VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_SURFACE_STEREO_TYPE_NV_MAX_ENUM";
        default: return "VkDisplaySurfaceStereoTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDriverId>(VkDriverId type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DRIVER_ID_AMD_PROPRIETARY";
        case static_cast<uint64_t>(2): return "VK_DRIVER_ID_AMD_OPEN_SOURCE";
        case static_cast<uint64_t>(3): return "VK_DRIVER_ID_MESA_RADV";
        case static_cast<uint64_t>(4): return "VK_DRIVER_ID_NVIDIA_PROPRIETARY";
        case static_cast<uint64_t>(5): return "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS";
        case static_cast<uint64_t>(6): return "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA";
        case static_cast<uint64_t>(7): return "VK_DRIVER_ID_IMAGINATION_PROPRIETARY";
        case static_cast<uint64_t>(8): return "VK_DRIVER_ID_QUALCOMM_PROPRIETARY";
        case static_cast<uint64_t>(9): return "VK_DRIVER_ID_ARM_PROPRIETARY";
        case static_cast<uint64_t>(10): return "VK_DRIVER_ID_GOOGLE_SWIFTSHADER";
        case static_cast<uint64_t>(11): return "VK_DRIVER_ID_GGP_PROPRIETARY";
        case static_cast<uint64_t>(12): return "VK_DRIVER_ID_BROADCOM_PROPRIETARY";
        case static_cast<uint64_t>(13): return "VK_DRIVER_ID_MESA_LLVMPIPE";
        case static_cast<uint64_t>(14): return "VK_DRIVER_ID_MOLTENVK";
        case static_cast<uint64_t>(15): return "VK_DRIVER_ID_COREAVI_PROPRIETARY";
        case static_cast<uint64_t>(16): return "VK_DRIVER_ID_JUICE_PROPRIETARY";
        case static_cast<uint64_t>(17): return "VK_DRIVER_ID_VERISILICON_PROPRIETARY";
        case static_cast<uint64_t>(18): return "VK_DRIVER_ID_MESA_TURNIP";
        case static_cast<uint64_t>(19): return "VK_DRIVER_ID_MESA_V3DV";
        case static_cast<uint64_t>(20): return "VK_DRIVER_ID_MESA_PANVK";
        case static_cast<uint64_t>(21): return "VK_DRIVER_ID_SAMSUNG_PROPRIETARY";
        case static_cast<uint64_t>(22): return "VK_DRIVER_ID_MESA_VENUS";
        case static_cast<uint64_t>(23): return "VK_DRIVER_ID_MESA_DOZEN";
        case static_cast<uint64_t>(24): return "VK_DRIVER_ID_MESA_NVK";
        case static_cast<uint64_t>(25): return "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA";
        case static_cast<uint64_t>(26): return "VK_DRIVER_ID_MESA_HONEYKRISP";
        case static_cast<uint64_t>(27): return "VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN";
        case static_cast<uint64_t>(2147483647): return "VK_DRIVER_ID_MAX_ENUM";
        default: return "VkDriverId_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDynamicState>(VkDynamicState type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DYNAMIC_STATE_VIEWPORT";
        case static_cast<uint64_t>(1): return "VK_DYNAMIC_STATE_SCISSOR";
        case static_cast<uint64_t>(2): return "VK_DYNAMIC_STATE_LINE_WIDTH";
        case static_cast<uint64_t>(3): return "VK_DYNAMIC_STATE_DEPTH_BIAS";
        case static_cast<uint64_t>(4): return "VK_DYNAMIC_STATE_BLEND_CONSTANTS";
        case static_cast<uint64_t>(5): return "VK_DYNAMIC_STATE_DEPTH_BOUNDS";
        case static_cast<uint64_t>(6): return "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK";
        case static_cast<uint64_t>(7): return "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK";
        case static_cast<uint64_t>(8): return "VK_DYNAMIC_STATE_STENCIL_REFERENCE";
        case static_cast<uint64_t>(2147483647): return "VK_DYNAMIC_STATE_MAX_ENUM";
        case static_cast<uint64_t>(1000267000): return "VK_DYNAMIC_STATE_CULL_MODE";
        case static_cast<uint64_t>(1000267001): return "VK_DYNAMIC_STATE_FRONT_FACE";
        case static_cast<uint64_t>(1000267002): return "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY";
        case static_cast<uint64_t>(1000267003): return "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT";
        case static_cast<uint64_t>(1000267004): return "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT";
        case static_cast<uint64_t>(1000267005): return "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE";
        case static_cast<uint64_t>(1000267006): return "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE";
        case static_cast<uint64_t>(1000267007): return "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE";
        case static_cast<uint64_t>(1000267008): return "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP";
        case static_cast<uint64_t>(1000267009): return "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE";
        case static_cast<uint64_t>(1000267010): return "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE";
        case static_cast<uint64_t>(1000267011): return "VK_DYNAMIC_STATE_STENCIL_OP";
        case static_cast<uint64_t>(1000377001): return "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE";
        case static_cast<uint64_t>(1000377002): return "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE";
        case static_cast<uint64_t>(1000377004): return "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE";
        case static_cast<uint64_t>(1000259000): return "VK_DYNAMIC_STATE_LINE_STIPPLE";
        case static_cast<uint64_t>(1000087000): return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV";
        case static_cast<uint64_t>(1000099000): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT";
        case static_cast<uint64_t>(1000099001): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT";
        case static_cast<uint64_t>(1000099002): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT";
        case static_cast<uint64_t>(1000143000): return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT";
        case static_cast<uint64_t>(1000164004): return "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV";
        case static_cast<uint64_t>(1000164006): return "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV";
        case static_cast<uint64_t>(1000205000): return "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV";
        case static_cast<uint64_t>(1000205001): return "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV";
        case static_cast<uint64_t>(1000226000): return "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR";
        case static_cast<uint64_t>(1000352000): return "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT";
        case static_cast<uint64_t>(1000377000): return "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT";
        case static_cast<uint64_t>(1000377003): return "VK_DYNAMIC_STATE_LOGIC_OP_EXT";
        case static_cast<uint64_t>(1000381000): return "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455003): return "VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455004): return "VK_DYNAMIC_STATE_POLYGON_MODE_EXT";
        case static_cast<uint64_t>(1000455005): return "VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT";
        case static_cast<uint64_t>(1000455006): return "VK_DYNAMIC_STATE_SAMPLE_MASK_EXT";
        case static_cast<uint64_t>(1000455007): return "VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455008): return "VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455009): return "VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455010): return "VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT";
        case static_cast<uint64_t>(1000455011): return "VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT";
        case static_cast<uint64_t>(1000455012): return "VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT";
        case static_cast<uint64_t>(1000455002): return "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT";
        case static_cast<uint64_t>(1000455013): return "VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT";
        case static_cast<uint64_t>(1000455014): return "VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT";
        case static_cast<uint64_t>(1000455015): return "VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT";
        case static_cast<uint64_t>(1000455016): return "VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455017): return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT";
        case static_cast<uint64_t>(1000455018): return "VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT";
        case static_cast<uint64_t>(1000455019): return "VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT";
        case static_cast<uint64_t>(1000455020): return "VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT";
        case static_cast<uint64_t>(1000455021): return "VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455022): return "VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT";
        case static_cast<uint64_t>(1000455023): return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV";
        case static_cast<uint64_t>(1000455024): return "VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV";
        case static_cast<uint64_t>(1000455025): return "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV";
        case static_cast<uint64_t>(1000455026): return "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV";
        case static_cast<uint64_t>(1000455027): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV";
        case static_cast<uint64_t>(1000455028): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV";
        case static_cast<uint64_t>(1000455029): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV";
        case static_cast<uint64_t>(1000455030): return "VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV";
        case static_cast<uint64_t>(1000455031): return "VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV";
        case static_cast<uint64_t>(1000455032): return "VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV";
        case static_cast<uint64_t>(1000524000): return "VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT";
        case static_cast<uint64_t>(1000582000): return "VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT";
        case static_cast<uint64_t>(1000347000): return "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR";
        default: return "VkDynamicState_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkEventCreateFlagBits>(VkEventCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_EVENT_CREATE_DEVICE_ONLY_BIT";
        default: return "VkEventCreateFlagBits_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    template <> constexpr const char* enumString<VkExportMetalObjectTypeFlagBitsEXT>(VkExportMetalObjectTypeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkExportMetalObjectTypeFlagBitsEXT_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkExternalFenceFeatureFlagBits>(VkExternalFenceFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalFenceFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalFenceHandleTypeFlagBits>(VkExternalFenceHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalFenceHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryFeatureFlagBits>(VkExternalMemoryFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalMemoryFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryFeatureFlagBitsNV>(VkExternalMemoryFeatureFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkExternalMemoryFeatureFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryHandleTypeFlagBits>(VkExternalMemoryHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT";
        case static_cast<uint64_t>(16): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT";
        case static_cast<uint64_t>(32): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT";
        case static_cast<uint64_t>(64): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(512): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID";
        case static_cast<uint64_t>(128): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT";
        case static_cast<uint64_t>(2048): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA";
        case static_cast<uint64_t>(4096): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV";
        case static_cast<uint64_t>(16384): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX";
        case static_cast<uint64_t>(65536): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT";
        default: return "VkExternalMemoryHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryHandleTypeFlagBitsNV>(VkExternalMemoryHandleTypeFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkExternalMemoryHandleTypeFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalSemaphoreFeatureFlagBits>(VkExternalSemaphoreFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalSemaphoreFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalSemaphoreHandleTypeFlagBits>(VkExternalSemaphoreHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT";
        case static_cast<uint64_t>(16): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(128): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA";
        default: return "VkExternalSemaphoreHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFenceCreateFlagBits>(VkFenceCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FENCE_CREATE_SIGNALED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM";
        default: return "VkFenceCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFenceImportFlagBits>(VkFenceImportFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FENCE_IMPORT_TEMPORARY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM";
        default: return "VkFenceImportFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFilter>(VkFilter type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FILTER_NEAREST";
        case static_cast<uint64_t>(1): return "VK_FILTER_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_FILTER_MAX_ENUM";
        case static_cast<uint64_t>(1000015000): return "VK_FILTER_CUBIC_EXT";
        default: return "VkFilter_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFormat>(VkFormat type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FORMAT_UNDEFINED";
        case static_cast<uint64_t>(1): return "VK_FORMAT_R4G4_UNORM_PACK8";
        case static_cast<uint64_t>(2): return "VK_FORMAT_R4G4B4A4_UNORM_PACK16";
        case static_cast<uint64_t>(3): return "VK_FORMAT_B4G4R4A4_UNORM_PACK16";
        case static_cast<uint64_t>(4): return "VK_FORMAT_R5G6B5_UNORM_PACK16";
        case static_cast<uint64_t>(5): return "VK_FORMAT_B5G6R5_UNORM_PACK16";
        case static_cast<uint64_t>(6): return "VK_FORMAT_R5G5B5A1_UNORM_PACK16";
        case static_cast<uint64_t>(7): return "VK_FORMAT_B5G5R5A1_UNORM_PACK16";
        case static_cast<uint64_t>(8): return "VK_FORMAT_A1R5G5B5_UNORM_PACK16";
        case static_cast<uint64_t>(9): return "VK_FORMAT_R8_UNORM";
        case static_cast<uint64_t>(10): return "VK_FORMAT_R8_SNORM";
        case static_cast<uint64_t>(11): return "VK_FORMAT_R8_USCALED";
        case static_cast<uint64_t>(12): return "VK_FORMAT_R8_SSCALED";
        case static_cast<uint64_t>(13): return "VK_FORMAT_R8_UINT";
        case static_cast<uint64_t>(14): return "VK_FORMAT_R8_SINT";
        case static_cast<uint64_t>(15): return "VK_FORMAT_R8_SRGB";
        case static_cast<uint64_t>(16): return "VK_FORMAT_R8G8_UNORM";
        case static_cast<uint64_t>(17): return "VK_FORMAT_R8G8_SNORM";
        case static_cast<uint64_t>(18): return "VK_FORMAT_R8G8_USCALED";
        case static_cast<uint64_t>(19): return "VK_FORMAT_R8G8_SSCALED";
        case static_cast<uint64_t>(20): return "VK_FORMAT_R8G8_UINT";
        case static_cast<uint64_t>(21): return "VK_FORMAT_R8G8_SINT";
        case static_cast<uint64_t>(22): return "VK_FORMAT_R8G8_SRGB";
        case static_cast<uint64_t>(23): return "VK_FORMAT_R8G8B8_UNORM";
        case static_cast<uint64_t>(24): return "VK_FORMAT_R8G8B8_SNORM";
        case static_cast<uint64_t>(25): return "VK_FORMAT_R8G8B8_USCALED";
        case static_cast<uint64_t>(26): return "VK_FORMAT_R8G8B8_SSCALED";
        case static_cast<uint64_t>(27): return "VK_FORMAT_R8G8B8_UINT";
        case static_cast<uint64_t>(28): return "VK_FORMAT_R8G8B8_SINT";
        case static_cast<uint64_t>(29): return "VK_FORMAT_R8G8B8_SRGB";
        case static_cast<uint64_t>(30): return "VK_FORMAT_B8G8R8_UNORM";
        case static_cast<uint64_t>(31): return "VK_FORMAT_B8G8R8_SNORM";
        case static_cast<uint64_t>(32): return "VK_FORMAT_B8G8R8_USCALED";
        case static_cast<uint64_t>(33): return "VK_FORMAT_B8G8R8_SSCALED";
        case static_cast<uint64_t>(34): return "VK_FORMAT_B8G8R8_UINT";
        case static_cast<uint64_t>(35): return "VK_FORMAT_B8G8R8_SINT";
        case static_cast<uint64_t>(36): return "VK_FORMAT_B8G8R8_SRGB";
        case static_cast<uint64_t>(37): return "VK_FORMAT_R8G8B8A8_UNORM";
        case static_cast<uint64_t>(38): return "VK_FORMAT_R8G8B8A8_SNORM";
        case static_cast<uint64_t>(39): return "VK_FORMAT_R8G8B8A8_USCALED";
        case static_cast<uint64_t>(40): return "VK_FORMAT_R8G8B8A8_SSCALED";
        case static_cast<uint64_t>(41): return "VK_FORMAT_R8G8B8A8_UINT";
        case static_cast<uint64_t>(42): return "VK_FORMAT_R8G8B8A8_SINT";
        case static_cast<uint64_t>(43): return "VK_FORMAT_R8G8B8A8_SRGB";
        case static_cast<uint64_t>(44): return "VK_FORMAT_B8G8R8A8_UNORM";
        case static_cast<uint64_t>(45): return "VK_FORMAT_B8G8R8A8_SNORM";
        case static_cast<uint64_t>(46): return "VK_FORMAT_B8G8R8A8_USCALED";
        case static_cast<uint64_t>(47): return "VK_FORMAT_B8G8R8A8_SSCALED";
        case static_cast<uint64_t>(48): return "VK_FORMAT_B8G8R8A8_UINT";
        case static_cast<uint64_t>(49): return "VK_FORMAT_B8G8R8A8_SINT";
        case static_cast<uint64_t>(50): return "VK_FORMAT_B8G8R8A8_SRGB";
        case static_cast<uint64_t>(51): return "VK_FORMAT_A8B8G8R8_UNORM_PACK32";
        case static_cast<uint64_t>(52): return "VK_FORMAT_A8B8G8R8_SNORM_PACK32";
        case static_cast<uint64_t>(53): return "VK_FORMAT_A8B8G8R8_USCALED_PACK32";
        case static_cast<uint64_t>(54): return "VK_FORMAT_A8B8G8R8_SSCALED_PACK32";
        case static_cast<uint64_t>(55): return "VK_FORMAT_A8B8G8R8_UINT_PACK32";
        case static_cast<uint64_t>(56): return "VK_FORMAT_A8B8G8R8_SINT_PACK32";
        case static_cast<uint64_t>(57): return "VK_FORMAT_A8B8G8R8_SRGB_PACK32";
        case static_cast<uint64_t>(58): return "VK_FORMAT_A2R10G10B10_UNORM_PACK32";
        case static_cast<uint64_t>(59): return "VK_FORMAT_A2R10G10B10_SNORM_PACK32";
        case static_cast<uint64_t>(60): return "VK_FORMAT_A2R10G10B10_USCALED_PACK32";
        case static_cast<uint64_t>(61): return "VK_FORMAT_A2R10G10B10_SSCALED_PACK32";
        case static_cast<uint64_t>(62): return "VK_FORMAT_A2R10G10B10_UINT_PACK32";
        case static_cast<uint64_t>(63): return "VK_FORMAT_A2R10G10B10_SINT_PACK32";
        case static_cast<uint64_t>(64): return "VK_FORMAT_A2B10G10R10_UNORM_PACK32";
        case static_cast<uint64_t>(65): return "VK_FORMAT_A2B10G10R10_SNORM_PACK32";
        case static_cast<uint64_t>(66): return "VK_FORMAT_A2B10G10R10_USCALED_PACK32";
        case static_cast<uint64_t>(67): return "VK_FORMAT_A2B10G10R10_SSCALED_PACK32";
        case static_cast<uint64_t>(68): return "VK_FORMAT_A2B10G10R10_UINT_PACK32";
        case static_cast<uint64_t>(69): return "VK_FORMAT_A2B10G10R10_SINT_PACK32";
        case static_cast<uint64_t>(70): return "VK_FORMAT_R16_UNORM";
        case static_cast<uint64_t>(71): return "VK_FORMAT_R16_SNORM";
        case static_cast<uint64_t>(72): return "VK_FORMAT_R16_USCALED";
        case static_cast<uint64_t>(73): return "VK_FORMAT_R16_SSCALED";
        case static_cast<uint64_t>(74): return "VK_FORMAT_R16_UINT";
        case static_cast<uint64_t>(75): return "VK_FORMAT_R16_SINT";
        case static_cast<uint64_t>(76): return "VK_FORMAT_R16_SFLOAT";
        case static_cast<uint64_t>(77): return "VK_FORMAT_R16G16_UNORM";
        case static_cast<uint64_t>(78): return "VK_FORMAT_R16G16_SNORM";
        case static_cast<uint64_t>(79): return "VK_FORMAT_R16G16_USCALED";
        case static_cast<uint64_t>(80): return "VK_FORMAT_R16G16_SSCALED";
        case static_cast<uint64_t>(81): return "VK_FORMAT_R16G16_UINT";
        case static_cast<uint64_t>(82): return "VK_FORMAT_R16G16_SINT";
        case static_cast<uint64_t>(83): return "VK_FORMAT_R16G16_SFLOAT";
        case static_cast<uint64_t>(84): return "VK_FORMAT_R16G16B16_UNORM";
        case static_cast<uint64_t>(85): return "VK_FORMAT_R16G16B16_SNORM";
        case static_cast<uint64_t>(86): return "VK_FORMAT_R16G16B16_USCALED";
        case static_cast<uint64_t>(87): return "VK_FORMAT_R16G16B16_SSCALED";
        case static_cast<uint64_t>(88): return "VK_FORMAT_R16G16B16_UINT";
        case static_cast<uint64_t>(89): return "VK_FORMAT_R16G16B16_SINT";
        case static_cast<uint64_t>(90): return "VK_FORMAT_R16G16B16_SFLOAT";
        case static_cast<uint64_t>(91): return "VK_FORMAT_R16G16B16A16_UNORM";
        case static_cast<uint64_t>(92): return "VK_FORMAT_R16G16B16A16_SNORM";
        case static_cast<uint64_t>(93): return "VK_FORMAT_R16G16B16A16_USCALED";
        case static_cast<uint64_t>(94): return "VK_FORMAT_R16G16B16A16_SSCALED";
        case static_cast<uint64_t>(95): return "VK_FORMAT_R16G16B16A16_UINT";
        case static_cast<uint64_t>(96): return "VK_FORMAT_R16G16B16A16_SINT";
        case static_cast<uint64_t>(97): return "VK_FORMAT_R16G16B16A16_SFLOAT";
        case static_cast<uint64_t>(98): return "VK_FORMAT_R32_UINT";
        case static_cast<uint64_t>(99): return "VK_FORMAT_R32_SINT";
        case static_cast<uint64_t>(100): return "VK_FORMAT_R32_SFLOAT";
        case static_cast<uint64_t>(101): return "VK_FORMAT_R32G32_UINT";
        case static_cast<uint64_t>(102): return "VK_FORMAT_R32G32_SINT";
        case static_cast<uint64_t>(103): return "VK_FORMAT_R32G32_SFLOAT";
        case static_cast<uint64_t>(104): return "VK_FORMAT_R32G32B32_UINT";
        case static_cast<uint64_t>(105): return "VK_FORMAT_R32G32B32_SINT";
        case static_cast<uint64_t>(106): return "VK_FORMAT_R32G32B32_SFLOAT";
        case static_cast<uint64_t>(107): return "VK_FORMAT_R32G32B32A32_UINT";
        case static_cast<uint64_t>(108): return "VK_FORMAT_R32G32B32A32_SINT";
        case static_cast<uint64_t>(109): return "VK_FORMAT_R32G32B32A32_SFLOAT";
        case static_cast<uint64_t>(110): return "VK_FORMAT_R64_UINT";
        case static_cast<uint64_t>(111): return "VK_FORMAT_R64_SINT";
        case static_cast<uint64_t>(112): return "VK_FORMAT_R64_SFLOAT";
        case static_cast<uint64_t>(113): return "VK_FORMAT_R64G64_UINT";
        case static_cast<uint64_t>(114): return "VK_FORMAT_R64G64_SINT";
        case static_cast<uint64_t>(115): return "VK_FORMAT_R64G64_SFLOAT";
        case static_cast<uint64_t>(116): return "VK_FORMAT_R64G64B64_UINT";
        case static_cast<uint64_t>(117): return "VK_FORMAT_R64G64B64_SINT";
        case static_cast<uint64_t>(118): return "VK_FORMAT_R64G64B64_SFLOAT";
        case static_cast<uint64_t>(119): return "VK_FORMAT_R64G64B64A64_UINT";
        case static_cast<uint64_t>(120): return "VK_FORMAT_R64G64B64A64_SINT";
        case static_cast<uint64_t>(121): return "VK_FORMAT_R64G64B64A64_SFLOAT";
        case static_cast<uint64_t>(122): return "VK_FORMAT_B10G11R11_UFLOAT_PACK32";
        case static_cast<uint64_t>(123): return "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32";
        case static_cast<uint64_t>(124): return "VK_FORMAT_D16_UNORM";
        case static_cast<uint64_t>(125): return "VK_FORMAT_X8_D24_UNORM_PACK32";
        case static_cast<uint64_t>(126): return "VK_FORMAT_D32_SFLOAT";
        case static_cast<uint64_t>(127): return "VK_FORMAT_S8_UINT";
        case static_cast<uint64_t>(128): return "VK_FORMAT_D16_UNORM_S8_UINT";
        case static_cast<uint64_t>(129): return "VK_FORMAT_D24_UNORM_S8_UINT";
        case static_cast<uint64_t>(130): return "VK_FORMAT_D32_SFLOAT_S8_UINT";
        case static_cast<uint64_t>(131): return "VK_FORMAT_BC1_RGB_UNORM_BLOCK";
        case static_cast<uint64_t>(132): return "VK_FORMAT_BC1_RGB_SRGB_BLOCK";
        case static_cast<uint64_t>(133): return "VK_FORMAT_BC1_RGBA_UNORM_BLOCK";
        case static_cast<uint64_t>(134): return "VK_FORMAT_BC1_RGBA_SRGB_BLOCK";
        case static_cast<uint64_t>(135): return "VK_FORMAT_BC2_UNORM_BLOCK";
        case static_cast<uint64_t>(136): return "VK_FORMAT_BC2_SRGB_BLOCK";
        case static_cast<uint64_t>(137): return "VK_FORMAT_BC3_UNORM_BLOCK";
        case static_cast<uint64_t>(138): return "VK_FORMAT_BC3_SRGB_BLOCK";
        case static_cast<uint64_t>(139): return "VK_FORMAT_BC4_UNORM_BLOCK";
        case static_cast<uint64_t>(140): return "VK_FORMAT_BC4_SNORM_BLOCK";
        case static_cast<uint64_t>(141): return "VK_FORMAT_BC5_UNORM_BLOCK";
        case static_cast<uint64_t>(142): return "VK_FORMAT_BC5_SNORM_BLOCK";
        case static_cast<uint64_t>(143): return "VK_FORMAT_BC6H_UFLOAT_BLOCK";
        case static_cast<uint64_t>(144): return "VK_FORMAT_BC6H_SFLOAT_BLOCK";
        case static_cast<uint64_t>(145): return "VK_FORMAT_BC7_UNORM_BLOCK";
        case static_cast<uint64_t>(146): return "VK_FORMAT_BC7_SRGB_BLOCK";
        case static_cast<uint64_t>(147): return "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK";
        case static_cast<uint64_t>(148): return "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK";
        case static_cast<uint64_t>(149): return "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK";
        case static_cast<uint64_t>(150): return "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK";
        case static_cast<uint64_t>(151): return "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK";
        case static_cast<uint64_t>(152): return "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK";
        case static_cast<uint64_t>(153): return "VK_FORMAT_EAC_R11_UNORM_BLOCK";
        case static_cast<uint64_t>(154): return "VK_FORMAT_EAC_R11_SNORM_BLOCK";
        case static_cast<uint64_t>(155): return "VK_FORMAT_EAC_R11G11_UNORM_BLOCK";
        case static_cast<uint64_t>(156): return "VK_FORMAT_EAC_R11G11_SNORM_BLOCK";
        case static_cast<uint64_t>(157): return "VK_FORMAT_ASTC_4x4_UNORM_BLOCK";
        case static_cast<uint64_t>(158): return "VK_FORMAT_ASTC_4x4_SRGB_BLOCK";
        case static_cast<uint64_t>(159): return "VK_FORMAT_ASTC_5x4_UNORM_BLOCK";
        case static_cast<uint64_t>(160): return "VK_FORMAT_ASTC_5x4_SRGB_BLOCK";
        case static_cast<uint64_t>(161): return "VK_FORMAT_ASTC_5x5_UNORM_BLOCK";
        case static_cast<uint64_t>(162): return "VK_FORMAT_ASTC_5x5_SRGB_BLOCK";
        case static_cast<uint64_t>(163): return "VK_FORMAT_ASTC_6x5_UNORM_BLOCK";
        case static_cast<uint64_t>(164): return "VK_FORMAT_ASTC_6x5_SRGB_BLOCK";
        case static_cast<uint64_t>(165): return "VK_FORMAT_ASTC_6x6_UNORM_BLOCK";
        case static_cast<uint64_t>(166): return "VK_FORMAT_ASTC_6x6_SRGB_BLOCK";
        case static_cast<uint64_t>(167): return "VK_FORMAT_ASTC_8x5_UNORM_BLOCK";
        case static_cast<uint64_t>(168): return "VK_FORMAT_ASTC_8x5_SRGB_BLOCK";
        case static_cast<uint64_t>(169): return "VK_FORMAT_ASTC_8x6_UNORM_BLOCK";
        case static_cast<uint64_t>(170): return "VK_FORMAT_ASTC_8x6_SRGB_BLOCK";
        case static_cast<uint64_t>(171): return "VK_FORMAT_ASTC_8x8_UNORM_BLOCK";
        case static_cast<uint64_t>(172): return "VK_FORMAT_ASTC_8x8_SRGB_BLOCK";
        case static_cast<uint64_t>(173): return "VK_FORMAT_ASTC_10x5_UNORM_BLOCK";
        case static_cast<uint64_t>(174): return "VK_FORMAT_ASTC_10x5_SRGB_BLOCK";
        case static_cast<uint64_t>(175): return "VK_FORMAT_ASTC_10x6_UNORM_BLOCK";
        case static_cast<uint64_t>(176): return "VK_FORMAT_ASTC_10x6_SRGB_BLOCK";
        case static_cast<uint64_t>(177): return "VK_FORMAT_ASTC_10x8_UNORM_BLOCK";
        case static_cast<uint64_t>(178): return "VK_FORMAT_ASTC_10x8_SRGB_BLOCK";
        case static_cast<uint64_t>(179): return "VK_FORMAT_ASTC_10x10_UNORM_BLOCK";
        case static_cast<uint64_t>(180): return "VK_FORMAT_ASTC_10x10_SRGB_BLOCK";
        case static_cast<uint64_t>(181): return "VK_FORMAT_ASTC_12x10_UNORM_BLOCK";
        case static_cast<uint64_t>(182): return "VK_FORMAT_ASTC_12x10_SRGB_BLOCK";
        case static_cast<uint64_t>(183): return "VK_FORMAT_ASTC_12x12_UNORM_BLOCK";
        case static_cast<uint64_t>(184): return "VK_FORMAT_ASTC_12x12_SRGB_BLOCK";
        case static_cast<uint64_t>(2147483647): return "VK_FORMAT_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_FORMAT_G8B8G8R8_422_UNORM";
        case static_cast<uint64_t>(1000156001): return "VK_FORMAT_B8G8R8G8_422_UNORM";
        case static_cast<uint64_t>(1000156002): return "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156003): return "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156004): return "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156005): return "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156006): return "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM";
        case static_cast<uint64_t>(1000156007): return "VK_FORMAT_R10X6_UNORM_PACK16";
        case static_cast<uint64_t>(1000156008): return "VK_FORMAT_R10X6G10X6_UNORM_2PACK16";
        case static_cast<uint64_t>(1000156009): return "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156010): return "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156011): return "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156012): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156013): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156014): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156015): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156016): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156017): return "VK_FORMAT_R12X4_UNORM_PACK16";
        case static_cast<uint64_t>(1000156018): return "VK_FORMAT_R12X4G12X4_UNORM_2PACK16";
        case static_cast<uint64_t>(1000156019): return "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156020): return "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156021): return "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156022): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156023): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156024): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156025): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156026): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156027): return "VK_FORMAT_G16B16G16R16_422_UNORM";
        case static_cast<uint64_t>(1000156028): return "VK_FORMAT_B16G16R16G16_422_UNORM";
        case static_cast<uint64_t>(1000156029): return "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156030): return "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156031): return "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156032): return "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156033): return "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM";
        case static_cast<uint64_t>(1000330000): return "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM";
        case static_cast<uint64_t>(1000330001): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000330002): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000330003): return "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM";
        case static_cast<uint64_t>(1000340000): return "VK_FORMAT_A4R4G4B4_UNORM_PACK16";
        case static_cast<uint64_t>(1000340001): return "VK_FORMAT_A4B4G4R4_UNORM_PACK16";
        case static_cast<uint64_t>(1000066000): return "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066001): return "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066002): return "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066003): return "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066004): return "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066005): return "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066006): return "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066007): return "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066008): return "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066009): return "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066010): return "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066011): return "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066012): return "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066013): return "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000470000): return "VK_FORMAT_A1B5G5R5_UNORM_PACK16";
        case static_cast<uint64_t>(1000470001): return "VK_FORMAT_A8_UNORM";
        case static_cast<uint64_t>(1000054000): return "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054001): return "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054002): return "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054003): return "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054004): return "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054005): return "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054006): return "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054007): return "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000460000): return "VK_FORMAT_R8_BOOL_ARM";
        case static_cast<uint64_t>(1000464000): return "VK_FORMAT_R16G16_SFIXED5_NV";
        case static_cast<uint64_t>(1000609000): return "VK_FORMAT_R10X6_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609001): return "VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609002): return "VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609003): return "VK_FORMAT_R12X4_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609004): return "VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609005): return "VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609006): return "VK_FORMAT_R14X2_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609007): return "VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609008): return "VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609009): return "VK_FORMAT_R14X2_UNORM_PACK16_ARM";
        case static_cast<uint64_t>(1000609010): return "VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM";
        case static_cast<uint64_t>(1000609011): return "VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM";
        case static_cast<uint64_t>(1000609012): return "VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM";
        case static_cast<uint64_t>(1000609013): return "VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM";
        default: return "VkFormat_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFormatFeatureFlagBits>(VkFormatFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT";
        case static_cast<uint64_t>(2): return "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT";
        case static_cast<uint64_t>(4): return "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT";
        case static_cast<uint64_t>(8): return "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(16): return "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(32): return "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT";
        case static_cast<uint64_t>(64): return "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT";
        case static_cast<uint64_t>(128): return "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT";
        case static_cast<uint64_t>(256): return "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT";
        case static_cast<uint64_t>(512): return "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT";
        case static_cast<uint64_t>(1024): return "VK_FORMAT_FEATURE_BLIT_SRC_BIT";
        case static_cast<uint64_t>(2048): return "VK_FORMAT_FEATURE_BLIT_DST_BIT";
        case static_cast<uint64_t>(4096): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16384): return "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(32768): return "VK_FORMAT_FEATURE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(131072): return "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT";
        case static_cast<uint64_t>(262144): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT";
        case static_cast<uint64_t>(524288): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT";
        case static_cast<uint64_t>(1048576): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT";
        case static_cast<uint64_t>(2097152): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT";
        case static_cast<uint64_t>(4194304): return "VK_FORMAT_FEATURE_DISJOINT_BIT";
        case static_cast<uint64_t>(8388608): return "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT";
        case static_cast<uint64_t>(65536): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT";
        case static_cast<uint64_t>(33554432): return "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR";
        case static_cast<uint64_t>(67108864): return "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT";
        case static_cast<uint64_t>(1073741824): return "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(134217728): return "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR";
        case static_cast<uint64_t>(268435456): return "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(536870912): return "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR";
        default: return "VkFormatFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateCombinerOpKHR>(VkFragmentShadingRateCombinerOpKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR";
        case static_cast<uint64_t>(2): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR";
        case static_cast<uint64_t>(3): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR";
        case static_cast<uint64_t>(4): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KHR_MAX_ENUM";
        default: return "VkFragmentShadingRateCombinerOpKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateNV>(VkFragmentShadingRateNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV";
        case static_cast<uint64_t>(4): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV";
        case static_cast<uint64_t>(5): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV";
        case static_cast<uint64_t>(6): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV";
        case static_cast<uint64_t>(9): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV";
        case static_cast<uint64_t>(10): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV";
        case static_cast<uint64_t>(11): return "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(12): return "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(13): return "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(14): return "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(15): return "VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_NV_MAX_ENUM";
        default: return "VkFragmentShadingRateNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateTypeNV>(VkFragmentShadingRateTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_TYPE_NV_MAX_ENUM";
        default: return "VkFragmentShadingRateTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFrameBoundaryFlagBitsEXT>(VkFrameBoundaryFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_FRAME_BOUNDARY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkFrameBoundaryFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFramebufferCreateFlagBits>(VkFramebufferCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT";
        default: return "VkFramebufferCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFrontFace>(VkFrontFace type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRONT_FACE_COUNTER_CLOCKWISE";
        case static_cast<uint64_t>(1): return "VK_FRONT_FACE_CLOCKWISE";
        case static_cast<uint64_t>(2147483647): return "VK_FRONT_FACE_MAX_ENUM";
        default: return "VkFrontFace_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template <> constexpr const char* enumString<VkFullScreenExclusiveEXT>(VkFullScreenExclusiveEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT";
        case static_cast<uint64_t>(1): return "VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT";
        case static_cast<uint64_t>(2): return "VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT";
        case static_cast<uint64_t>(3): return "VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_FULL_SCREEN_EXCLUSIVE_EXT_MAX_ENUM";
        default: return "VkFullScreenExclusiveEXT_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkGeometryFlagBitsKHR>(VkGeometryFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkGeometryFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGeometryInstanceFlagBitsKHR>(VkGeometryInstanceFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_INSTANCE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT";
        default: return "VkGeometryInstanceFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGeometryTypeKHR>(VkGeometryTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_GEOMETRY_TYPE_TRIANGLES_KHR";
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_TYPE_AABBS_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_TYPE_INSTANCES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_TYPE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000429004): return "VK_GEOMETRY_TYPE_SPHERES_NV";
        case static_cast<uint64_t>(1000429005): return "VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV";
        default: return "VkGeometryTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGraphicsPipelineLibraryFlagBitsEXT>(VkGraphicsPipelineLibraryFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkGraphicsPipelineLibraryFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkHostImageCopyFlagBits>(VkHostImageCopyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_HOST_IMAGE_COPY_MEMCPY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM";
        default: return "VkHostImageCopyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageAspectFlagBits>(VkImageAspectFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_ASPECT_COLOR_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_ASPECT_DEPTH_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_ASPECT_STENCIL_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_ASPECT_METADATA_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_IMAGE_ASPECT_PLANE_0_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_ASPECT_PLANE_1_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_ASPECT_PLANE_2_BIT";
        case static_cast<uint64_t>(0): return "VK_IMAGE_ASPECT_NONE";
        case static_cast<uint64_t>(128): return "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT";
        default: return "VkImageAspectFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageCompressionFixedRateFlagBitsEXT>(VkImageCompressionFixedRateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT";
        case static_cast<uint64_t>(1): return "VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT";
        case static_cast<uint64_t>(65536): return "VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT";
        case static_cast<uint64_t>(524288): return "VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkImageCompressionFixedRateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageCompressionFlagBitsEXT>(VkImageCompressionFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_COMPRESSION_DEFAULT_EXT";
        case static_cast<uint64_t>(1): return "VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_COMPRESSION_DISABLED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_COMPRESSION_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkImageCompressionFlagBitsEXT_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    template <> constexpr const char* enumString<VkImageConstraintsInfoFlagBitsFUCHSIA>(VkImageConstraintsInfoFlagBitsFUCHSIA type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA";
        case static_cast<uint64_t>(2): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA";
        case static_cast<uint64_t>(4): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA";
        case static_cast<uint64_t>(8): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA";
        case static_cast<uint64_t>(16): return "VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_FUCHSIA_MAX_ENUM";
        default: return "VkImageConstraintsInfoFlagBitsFUCHSIA_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkImageCreateFlagBits>(VkImageCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_CREATE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_CREATE_ALIAS_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_CREATE_PROTECTED_BIT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_CREATE_DISJOINT_BIT";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT";
        case static_cast<uint64_t>(65536): return "VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT";
        default: return "VkImageCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageLayout>(VkImageLayout type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_LAYOUT_UNDEFINED";
        case static_cast<uint64_t>(1): return "VK_IMAGE_LAYOUT_GENERAL";
        case static_cast<uint64_t>(2): return "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(3): return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(4): return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(5): return "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(6): return "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL";
        case static_cast<uint64_t>(7): return "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL";
        case static_cast<uint64_t>(8): return "VK_IMAGE_LAYOUT_PREINITIALIZED";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_LAYOUT_MAX_ENUM";
        case static_cast<uint64_t>(1000117000): return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000117001): return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000241000): return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000241001): return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000241002): return "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000241003): return "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000314000): return "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000314001): return "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000232000): return "VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ";
        case static_cast<uint64_t>(1000001002): return "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR";
        case static_cast<uint64_t>(1000024000): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR";
        case static_cast<uint64_t>(1000024001): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR";
        case static_cast<uint64_t>(1000024002): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR";
        case static_cast<uint64_t>(1000111000): return "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR";
        case static_cast<uint64_t>(1000218000): return "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT";
        case static_cast<uint64_t>(1000164003): return "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR";
        case static_cast<uint64_t>(1000299000): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR";
        case static_cast<uint64_t>(1000299001): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR";
        case static_cast<uint64_t>(1000299002): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR";
        case static_cast<uint64_t>(1000339000): return "VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT";
        case static_cast<uint64_t>(1000460000): return "VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM";
        case static_cast<uint64_t>(1000553000): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR";
        case static_cast<uint64_t>(1000620000): return "VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT";
        default: return "VkImageLayout_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageTiling>(VkImageTiling type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_TILING_OPTIMAL";
        case static_cast<uint64_t>(1): return "VK_IMAGE_TILING_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_TILING_MAX_ENUM";
        case static_cast<uint64_t>(1000158000): return "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT";
        default: return "VkImageTiling_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageType>(VkImageType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_TYPE_1D";
        case static_cast<uint64_t>(1): return "VK_IMAGE_TYPE_2D";
        case static_cast<uint64_t>(2): return "VK_IMAGE_TYPE_3D";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_TYPE_MAX_ENUM";
        default: return "VkImageType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageUsageFlagBits>(VkImageUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_USAGE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_USAGE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_USAGE_SAMPLED_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_USAGE_STORAGE_BIT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4194304): return "VK_IMAGE_USAGE_HOST_TRANSFER_BIT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM";
        case static_cast<uint64_t>(2097152): return "VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM";
        case static_cast<uint64_t>(8388608): return "VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM";
        case static_cast<uint64_t>(134217728): return "VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM";
        case static_cast<uint64_t>(33554432): return "VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(67108864): return "VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR";
        default: return "VkImageUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageViewCreateFlagBits>(VkImageViewCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT";
        default: return "VkImageViewCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageViewType>(VkImageViewType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_VIEW_TYPE_1D";
        case static_cast<uint64_t>(1): return "VK_IMAGE_VIEW_TYPE_2D";
        case static_cast<uint64_t>(2): return "VK_IMAGE_VIEW_TYPE_3D";
        case static_cast<uint64_t>(3): return "VK_IMAGE_VIEW_TYPE_CUBE";
        case static_cast<uint64_t>(4): return "VK_IMAGE_VIEW_TYPE_1D_ARRAY";
        case static_cast<uint64_t>(5): return "VK_IMAGE_VIEW_TYPE_2D_ARRAY";
        case static_cast<uint64_t>(6): return "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_VIEW_TYPE_MAX_ENUM";
        default: return "VkImageViewType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndexType>(VkIndexType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDEX_TYPE_UINT16";
        case static_cast<uint64_t>(1): return "VK_INDEX_TYPE_UINT32";
        case static_cast<uint64_t>(2147483647): return "VK_INDEX_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000265000): return "VK_INDEX_TYPE_UINT8";
        case static_cast<uint64_t>(1000165000): return "VK_INDEX_TYPE_NONE_KHR";
        default: return "VkIndexType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsInputModeFlagBitsEXT>(VkIndirectCommandsInputModeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkIndirectCommandsInputModeFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsLayoutUsageFlagBitsEXT>(VkIndirectCommandsLayoutUsageFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkIndirectCommandsLayoutUsageFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsLayoutUsageFlagBitsNV>(VkIndirectCommandsLayoutUsageFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkIndirectCommandsLayoutUsageFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsTokenTypeEXT>(VkIndirectCommandsTokenTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT";
        case static_cast<uint64_t>(3): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT";
        case static_cast<uint64_t>(5): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT";
        case static_cast<uint64_t>(6): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT";
        case static_cast<uint64_t>(7): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT";
        case static_cast<uint64_t>(8): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT";
        case static_cast<uint64_t>(9): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000202002): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT";
        case static_cast<uint64_t>(1000202003): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT";
        case static_cast<uint64_t>(1000386004): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT";
        case static_cast<uint64_t>(1000328000): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT";
        case static_cast<uint64_t>(1000328001): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT";
        default: return "VkIndirectCommandsTokenTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsTokenTypeNV>(VkIndirectCommandsTokenTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV";
        case static_cast<uint64_t>(3): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV";
        case static_cast<uint64_t>(5): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV";
        case static_cast<uint64_t>(6): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV";
        case static_cast<uint64_t>(7): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_NV_MAX_ENUM";
        case static_cast<uint64_t>(1000428003): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV";
        case static_cast<uint64_t>(1000428004): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV";
        case static_cast<uint64_t>(1000328000): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV";
        default: return "VkIndirectCommandsTokenTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectExecutionSetInfoTypeEXT>(VkIndirectExecutionSetInfoTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_EXT_MAX_ENUM";
        default: return "VkIndirectExecutionSetInfoTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectStateFlagBitsNV>(VkIndirectStateFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_STATE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkIndirectStateFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkInstanceCreateFlagBits>(VkInstanceCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR";
        default: return "VkInstanceCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkInternalAllocationType>(VkInternalAllocationType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE";
        case static_cast<uint64_t>(2147483647): return "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM";
        default: return "VkInternalAllocationType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLatencyMarkerNV>(VkLatencyMarkerNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LATENCY_MARKER_SIMULATION_START_NV";
        case static_cast<uint64_t>(1): return "VK_LATENCY_MARKER_SIMULATION_END_NV";
        case static_cast<uint64_t>(2): return "VK_LATENCY_MARKER_RENDERSUBMIT_START_NV";
        case static_cast<uint64_t>(3): return "VK_LATENCY_MARKER_RENDERSUBMIT_END_NV";
        case static_cast<uint64_t>(4): return "VK_LATENCY_MARKER_PRESENT_START_NV";
        case static_cast<uint64_t>(5): return "VK_LATENCY_MARKER_PRESENT_END_NV";
        case static_cast<uint64_t>(6): return "VK_LATENCY_MARKER_INPUT_SAMPLE_NV";
        case static_cast<uint64_t>(7): return "VK_LATENCY_MARKER_TRIGGER_FLASH_NV";
        case static_cast<uint64_t>(8): return "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV";
        case static_cast<uint64_t>(9): return "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV";
        case static_cast<uint64_t>(10): return "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV";
        case static_cast<uint64_t>(11): return "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV";
        case static_cast<uint64_t>(2147483647): return "VK_LATENCY_MARKER_NV_MAX_ENUM";
        default: return "VkLatencyMarkerNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLayerSettingTypeEXT>(VkLayerSettingTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LAYER_SETTING_TYPE_BOOL32_EXT";
        case static_cast<uint64_t>(1): return "VK_LAYER_SETTING_TYPE_INT32_EXT";
        case static_cast<uint64_t>(2): return "VK_LAYER_SETTING_TYPE_INT64_EXT";
        case static_cast<uint64_t>(3): return "VK_LAYER_SETTING_TYPE_UINT32_EXT";
        case static_cast<uint64_t>(4): return "VK_LAYER_SETTING_TYPE_UINT64_EXT";
        case static_cast<uint64_t>(5): return "VK_LAYER_SETTING_TYPE_FLOAT32_EXT";
        case static_cast<uint64_t>(6): return "VK_LAYER_SETTING_TYPE_FLOAT64_EXT";
        case static_cast<uint64_t>(7): return "VK_LAYER_SETTING_TYPE_STRING_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_LAYER_SETTING_TYPE_EXT_MAX_ENUM";
        default: return "VkLayerSettingTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLayeredDriverUnderlyingApiMSFT>(VkLayeredDriverUnderlyingApiMSFT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT";
        case static_cast<uint64_t>(1): return "VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT";
        case static_cast<uint64_t>(2147483647): return "VK_LAYERED_DRIVER_UNDERLYING_API_MSFT_MAX_ENUM";
        default: return "VkLayeredDriverUnderlyingApiMSFT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLineRasterizationMode>(VkLineRasterizationMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LINE_RASTERIZATION_MODE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_LINE_RASTERIZATION_MODE_RECTANGULAR";
        case static_cast<uint64_t>(2): return "VK_LINE_RASTERIZATION_MODE_BRESENHAM";
        case static_cast<uint64_t>(3): return "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH";
        case static_cast<uint64_t>(2147483647): return "VK_LINE_RASTERIZATION_MODE_MAX_ENUM";
        default: return "VkLineRasterizationMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLogicOp>(VkLogicOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LOGIC_OP_CLEAR";
        case static_cast<uint64_t>(1): return "VK_LOGIC_OP_AND";
        case static_cast<uint64_t>(2): return "VK_LOGIC_OP_AND_REVERSE";
        case static_cast<uint64_t>(3): return "VK_LOGIC_OP_COPY";
        case static_cast<uint64_t>(4): return "VK_LOGIC_OP_AND_INVERTED";
        case static_cast<uint64_t>(5): return "VK_LOGIC_OP_NO_OP";
        case static_cast<uint64_t>(6): return "VK_LOGIC_OP_XOR";
        case static_cast<uint64_t>(7): return "VK_LOGIC_OP_OR";
        case static_cast<uint64_t>(8): return "VK_LOGIC_OP_NOR";
        case static_cast<uint64_t>(9): return "VK_LOGIC_OP_EQUIVALENT";
        case static_cast<uint64_t>(10): return "VK_LOGIC_OP_INVERT";
        case static_cast<uint64_t>(11): return "VK_LOGIC_OP_OR_REVERSE";
        case static_cast<uint64_t>(12): return "VK_LOGIC_OP_COPY_INVERTED";
        case static_cast<uint64_t>(13): return "VK_LOGIC_OP_OR_INVERTED";
        case static_cast<uint64_t>(14): return "VK_LOGIC_OP_NAND";
        case static_cast<uint64_t>(15): return "VK_LOGIC_OP_SET";
        case static_cast<uint64_t>(2147483647): return "VK_LOGIC_OP_MAX_ENUM";
        default: return "VkLogicOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryAllocateFlagBits>(VkMemoryAllocateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT";
        case static_cast<uint64_t>(4): return "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT";
        default: return "VkMemoryAllocateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryHeapFlagBits>(VkMemoryHeapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM";
        default: return "VkMemoryHeapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryMapFlagBits>(VkMemoryMapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_MEMORY_MAP_PLACED_BIT_EXT";
        default: return "VkMemoryMapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryOverallocationBehaviorAMD>(VkMemoryOverallocationBehaviorAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD";
        case static_cast<uint64_t>(1): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD";
        case static_cast<uint64_t>(2): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_AMD_MAX_ENUM";
        default: return "VkMemoryOverallocationBehaviorAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryPropertyFlagBits>(VkMemoryPropertyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT";
        case static_cast<uint64_t>(2): return "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT";
        case static_cast<uint64_t>(4): return "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_PROPERTY_HOST_CACHED_BIT";
        case static_cast<uint64_t>(16): return "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_MEMORY_PROPERTY_PROTECTED_BIT";
        case static_cast<uint64_t>(64): return "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD";
        case static_cast<uint64_t>(128): return "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD";
        case static_cast<uint64_t>(256): return "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV";
        default: return "VkMemoryPropertyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryUnmapFlagBits>(VkMemoryUnmapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_MEMORY_UNMAP_RESERVE_BIT_EXT";
        default: return "VkMemoryUnmapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMicromapCreateFlagBitsEXT>(VkMicromapCreateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_MICROMAP_CREATE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkMicromapCreateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMicromapTypeEXT>(VkMicromapTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_MICROMAP_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000397000): return "VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV";
        default: return "VkMicromapTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkObjectType>(VkObjectType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OBJECT_TYPE_UNKNOWN";
        case static_cast<uint64_t>(1): return "VK_OBJECT_TYPE_INSTANCE";
        case static_cast<uint64_t>(2): return "VK_OBJECT_TYPE_PHYSICAL_DEVICE";
        case static_cast<uint64_t>(3): return "VK_OBJECT_TYPE_DEVICE";
        case static_cast<uint64_t>(4): return "VK_OBJECT_TYPE_QUEUE";
        case static_cast<uint64_t>(5): return "VK_OBJECT_TYPE_SEMAPHORE";
        case static_cast<uint64_t>(6): return "VK_OBJECT_TYPE_COMMAND_BUFFER";
        case static_cast<uint64_t>(7): return "VK_OBJECT_TYPE_FENCE";
        case static_cast<uint64_t>(8): return "VK_OBJECT_TYPE_DEVICE_MEMORY";
        case static_cast<uint64_t>(9): return "VK_OBJECT_TYPE_BUFFER";
        case static_cast<uint64_t>(10): return "VK_OBJECT_TYPE_IMAGE";
        case static_cast<uint64_t>(11): return "VK_OBJECT_TYPE_EVENT";
        case static_cast<uint64_t>(12): return "VK_OBJECT_TYPE_QUERY_POOL";
        case static_cast<uint64_t>(13): return "VK_OBJECT_TYPE_BUFFER_VIEW";
        case static_cast<uint64_t>(14): return "VK_OBJECT_TYPE_IMAGE_VIEW";
        case static_cast<uint64_t>(15): return "VK_OBJECT_TYPE_SHADER_MODULE";
        case static_cast<uint64_t>(16): return "VK_OBJECT_TYPE_PIPELINE_CACHE";
        case static_cast<uint64_t>(17): return "VK_OBJECT_TYPE_PIPELINE_LAYOUT";
        case static_cast<uint64_t>(18): return "VK_OBJECT_TYPE_RENDER_PASS";
        case static_cast<uint64_t>(19): return "VK_OBJECT_TYPE_PIPELINE";
        case static_cast<uint64_t>(20): return "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT";
        case static_cast<uint64_t>(21): return "VK_OBJECT_TYPE_SAMPLER";
        case static_cast<uint64_t>(22): return "VK_OBJECT_TYPE_DESCRIPTOR_POOL";
        case static_cast<uint64_t>(23): return "VK_OBJECT_TYPE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(24): return "VK_OBJECT_TYPE_FRAMEBUFFER";
        case static_cast<uint64_t>(25): return "VK_OBJECT_TYPE_COMMAND_POOL";
        case static_cast<uint64_t>(2147483647): return "VK_OBJECT_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION";
        case static_cast<uint64_t>(1000085000): return "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE";
        case static_cast<uint64_t>(1000295000): return "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT";
        case static_cast<uint64_t>(1000000000): return "VK_OBJECT_TYPE_SURFACE_KHR";
        case static_cast<uint64_t>(1000001000): return "VK_OBJECT_TYPE_SWAPCHAIN_KHR";
        case static_cast<uint64_t>(1000002000): return "VK_OBJECT_TYPE_DISPLAY_KHR";
        case static_cast<uint64_t>(1000002001): return "VK_OBJECT_TYPE_DISPLAY_MODE_KHR";
        case static_cast<uint64_t>(1000011000): return "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT";
        case static_cast<uint64_t>(1000023000): return "VK_OBJECT_TYPE_VIDEO_SESSION_KHR";
        case static_cast<uint64_t>(1000023001): return "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR";
        case static_cast<uint64_t>(1000128000): return "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT";
        case static_cast<uint64_t>(1000160000): return "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT";
        case static_cast<uint64_t>(1000165000): return "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000210000): return "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL";
        case static_cast<uint64_t>(1000268000): return "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR";
        case static_cast<uint64_t>(1000277000): return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV";
        case static_cast<uint64_t>(1000307000): return "VK_OBJECT_TYPE_CUDA_MODULE_NV";
        case static_cast<uint64_t>(1000307001): return "VK_OBJECT_TYPE_CUDA_FUNCTION_NV";
        case static_cast<uint64_t>(1000366000): return "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA";
        case static_cast<uint64_t>(1000396000): return "VK_OBJECT_TYPE_MICROMAP_EXT";
        case static_cast<uint64_t>(1000460000): return "VK_OBJECT_TYPE_TENSOR_ARM";
        case static_cast<uint64_t>(1000460001): return "VK_OBJECT_TYPE_TENSOR_VIEW_ARM";
        case static_cast<uint64_t>(1000464000): return "VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV";
        case static_cast<uint64_t>(1000482000): return "VK_OBJECT_TYPE_SHADER_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_OBJECT_TYPE_PIPELINE_BINARY_KHR";
        case static_cast<uint64_t>(1000507000): return "VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM";
        case static_cast<uint64_t>(1000556000): return "VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV";
        case static_cast<uint64_t>(1000572000): return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT";
        case static_cast<uint64_t>(1000572001): return "VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR";
        default: return "VkObjectType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpacityMicromapFormatEXT>(VkOpacityMicromapFormatEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT";
        case static_cast<uint64_t>(2): return "VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_OPACITY_MICROMAP_FORMAT_EXT_MAX_ENUM";
        default: return "VkOpacityMicromapFormatEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpacityMicromapSpecialIndexEXT>(VkOpacityMicromapSpecialIndexEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(-1): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT";
        case static_cast<uint64_t>(-2): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT";
        case static_cast<uint64_t>(-3): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT";
        case static_cast<uint64_t>(-4): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_EXT_MAX_ENUM";
        case static_cast<uint64_t>(-5): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV";
        default: return "VkOpacityMicromapSpecialIndexEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowExecuteFlagBitsNV>(VkOpticalFlowExecuteFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowExecuteFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowGridSizeFlagBitsNV>(VkOpticalFlowGridSizeFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowGridSizeFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowPerformanceLevelNV>(VkOpticalFlowPerformanceLevelNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV";
        case static_cast<uint64_t>(3): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_NV_MAX_ENUM";
        default: return "VkOpticalFlowPerformanceLevelNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowSessionBindingPointNV>(VkOpticalFlowSessionBindingPointNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV";
        case static_cast<uint64_t>(3): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV";
        case static_cast<uint64_t>(5): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV";
        case static_cast<uint64_t>(6): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV";
        case static_cast<uint64_t>(7): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_NV_MAX_ENUM";
        default: return "VkOpticalFlowSessionBindingPointNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowSessionCreateFlagBitsNV>(VkOpticalFlowSessionCreateFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowSessionCreateFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowUsageFlagBitsNV>(VkOpticalFlowUsageFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_USAGE_COST_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_USAGE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowUsageFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOutOfBandQueueTypeNV>(VkOutOfBandQueueTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV";
        case static_cast<uint64_t>(1): return "VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OUT_OF_BAND_QUEUE_TYPE_NV_MAX_ENUM";
        default: return "VkOutOfBandQueueTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPartitionedAccelerationStructureInstanceFlagBitsNV>(VkPartitionedAccelerationStructureInstanceFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV";
        case static_cast<uint64_t>(2147483647): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkPartitionedAccelerationStructureInstanceFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPartitionedAccelerationStructureOpTypeNV>(VkPartitionedAccelerationStructureOpTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV";
        case static_cast<uint64_t>(1): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV";
        case static_cast<uint64_t>(2): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV";
        case static_cast<uint64_t>(2147483647): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_NV_MAX_ENUM";
        default: return "VkPartitionedAccelerationStructureOpTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPeerMemoryFeatureFlagBits>(VkPeerMemoryFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT";
        case static_cast<uint64_t>(8): return "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkPeerMemoryFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceConfigurationTypeINTEL>(VkPerformanceConfigurationTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_CONFIGURATION_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceConfigurationTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterDescriptionFlagBitsKHR>(VkPerformanceCounterDescriptionFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterDescriptionFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterScopeKHR>(VkPerformanceCounterScopeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_SCOPE_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterScopeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterStorageKHR>(VkPerformanceCounterStorageKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR";
        case static_cast<uint64_t>(5): return "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_STORAGE_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterStorageKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterUnitKHR>(VkPerformanceCounterUnitKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR";
        case static_cast<uint64_t>(5): return "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR";
        case static_cast<uint64_t>(6): return "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR";
        case static_cast<uint64_t>(7): return "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR";
        case static_cast<uint64_t>(8): return "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR";
        case static_cast<uint64_t>(9): return "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR";
        case static_cast<uint64_t>(10): return "VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_UNIT_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterUnitKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceOverrideTypeINTEL>(VkPerformanceOverrideTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_OVERRIDE_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceOverrideTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceParameterTypeINTEL>(VkPerformanceParameterTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_PARAMETER_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceParameterTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceValueTypeINTEL>(VkPerformanceValueTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_VALUE_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceValueTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceDataGraphOperationTypeARM>(VkPhysicalDeviceDataGraphOperationTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_ARM_MAX_ENUM";
        default: return "VkPhysicalDeviceDataGraphOperationTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceDataGraphProcessingEngineTypeARM>(VkPhysicalDeviceDataGraphProcessingEngineTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_ARM_MAX_ENUM";
        default: return "VkPhysicalDeviceDataGraphProcessingEngineTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceLayeredApiKHR>(VkPhysicalDeviceLayeredApiKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR";
        case static_cast<uint64_t>(1): return "VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR";
        case static_cast<uint64_t>(2): return "VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR";
        case static_cast<uint64_t>(3): return "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR";
        case static_cast<uint64_t>(4): return "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_LAYERED_API_KHR_MAX_ENUM";
        default: return "VkPhysicalDeviceLayeredApiKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceType>(VkPhysicalDeviceType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_TYPE_OTHER";
        case static_cast<uint64_t>(1): return "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU";
        case static_cast<uint64_t>(2): return "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU";
        case static_cast<uint64_t>(3): return "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU";
        case static_cast<uint64_t>(4): return "VK_PHYSICAL_DEVICE_TYPE_CPU";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM";
        default: return "VkPhysicalDeviceType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineBindPoint>(VkPipelineBindPoint type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_BIND_POINT_GRAPHICS";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_BIND_POINT_COMPUTE";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_BIND_POINT_MAX_ENUM";
        case static_cast<uint64_t>(1000134000): return "VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX";
        case static_cast<uint64_t>(1000369003): return "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI";
        case static_cast<uint64_t>(1000507000): return "VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM";
        case static_cast<uint64_t>(1000165000): return "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR";
        default: return "VkPipelineBindPoint_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCacheCreateFlagBits>(VkPipelineCacheCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR";
        default: return "VkPipelineCacheCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCacheHeaderVersion>(VkPipelineCacheHeaderVersion type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CACHE_HEADER_VERSION_ONE";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM";
        default: return "VkPipelineCacheHeaderVersion_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineColorBlendStateCreateFlagBits>(VkPipelineColorBlendStateCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT";
        default: return "VkPipelineColorBlendStateCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCreateFlagBits>(VkPipelineCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_CREATE_DERIVATIVE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT";
        case static_cast<uint64_t>(16): return "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT";
        case static_cast<uint64_t>(256): return "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT";
        case static_cast<uint64_t>(512): return "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT";
        case static_cast<uint64_t>(134217728): return "VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT";
        case static_cast<uint64_t>(1073741824): return "VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT";
        case static_cast<uint64_t>(32): return "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV";
        case static_cast<uint64_t>(4194304): return "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV";
        case static_cast<uint64_t>(2048): return "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR";
        case static_cast<uint64_t>(536870912): return "VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV";
        case static_cast<uint64_t>(33554432): return "VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT";
        case static_cast<uint64_t>(268435456): return "VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV";
        case static_cast<uint64_t>(16384): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR";
        default: return "VkPipelineCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCreationFeedbackFlagBits>(VkPipelineCreationFeedbackFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM";
        default: return "VkPipelineCreationFeedbackFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineDepthStencilStateCreateFlagBits>(VkPipelineDepthStencilStateCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT";
        default: return "VkPipelineDepthStencilStateCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineExecutableStatisticFormatKHR>(VkPipelineExecutableStatisticFormatKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_KHR_MAX_ENUM";
        default: return "VkPipelineExecutableStatisticFormatKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineLayoutCreateFlagBits>(VkPipelineLayoutCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT";
        default: return "VkPipelineLayoutCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineRobustnessBufferBehavior>(VkPipelineRobustnessBufferBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM";
        default: return "VkPipelineRobustnessBufferBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineRobustnessImageBehavior>(VkPipelineRobustnessImageBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM";
        default: return "VkPipelineRobustnessImageBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineShaderStageCreateFlagBits>(VkPipelineShaderStageCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT";
        default: return "VkPipelineShaderStageCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineStageFlagBits>(VkPipelineStageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT";
        case static_cast<uint64_t>(16): return "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT";
        case static_cast<uint64_t>(32): return "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT";
        case static_cast<uint64_t>(64): return "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT";
        case static_cast<uint64_t>(128): return "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT";
        case static_cast<uint64_t>(256): return "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT";
        case static_cast<uint64_t>(512): return "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT";
        case static_cast<uint64_t>(1024): return "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT";
        case static_cast<uint64_t>(2048): return "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT";
        case static_cast<uint64_t>(4096): return "VK_PIPELINE_STAGE_TRANSFER_BIT";
        case static_cast<uint64_t>(8192): return "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT";
        case static_cast<uint64_t>(16384): return "VK_PIPELINE_STAGE_HOST_BIT";
        case static_cast<uint64_t>(32768): return "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT";
        case static_cast<uint64_t>(65536): return "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(0): return "VK_PIPELINE_STAGE_NONE";
        case static_cast<uint64_t>(16777216): return "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT";
        case static_cast<uint64_t>(33554432): return "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR";
        case static_cast<uint64_t>(2097152): return "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT";
        default: return "VkPipelineStageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPointClippingBehavior>(VkPointClippingBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES";
        case static_cast<uint64_t>(1): return "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY";
        case static_cast<uint64_t>(2147483647): return "VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM";
        default: return "VkPointClippingBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPolygonMode>(VkPolygonMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_POLYGON_MODE_FILL";
        case static_cast<uint64_t>(1): return "VK_POLYGON_MODE_LINE";
        case static_cast<uint64_t>(2): return "VK_POLYGON_MODE_POINT";
        case static_cast<uint64_t>(2147483647): return "VK_POLYGON_MODE_MAX_ENUM";
        case static_cast<uint64_t>(1000153000): return "VK_POLYGON_MODE_FILL_RECTANGLE_NV";
        default: return "VkPolygonMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentGravityFlagBitsKHR>(VkPresentGravityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PRESENT_GRAVITY_MIN_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_GRAVITY_MAX_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_PRESENT_GRAVITY_CENTERED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_GRAVITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPresentGravityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentModeKHR>(VkPresentModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PRESENT_MODE_IMMEDIATE_KHR";
        case static_cast<uint64_t>(1): return "VK_PRESENT_MODE_MAILBOX_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_MODE_FIFO_KHR";
        case static_cast<uint64_t>(3): return "VK_PRESENT_MODE_FIFO_RELAXED_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_MODE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000111000): return "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR";
        case static_cast<uint64_t>(1000111001): return "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR";
        case static_cast<uint64_t>(1000361000): return "VK_PRESENT_MODE_FIFO_LATEST_READY_KHR";
        default: return "VkPresentModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentScalingFlagBitsKHR>(VkPresentScalingFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_PRESENT_SCALING_STRETCH_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_SCALING_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPresentScalingFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPrimitiveTopology>(VkPrimitiveTopology type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PRIMITIVE_TOPOLOGY_POINT_LIST";
        case static_cast<uint64_t>(1): return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST";
        case static_cast<uint64_t>(2): return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP";
        case static_cast<uint64_t>(3): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST";
        case static_cast<uint64_t>(4): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP";
        case static_cast<uint64_t>(5): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN";
        case static_cast<uint64_t>(6): return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY";
        case static_cast<uint64_t>(7): return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY";
        case static_cast<uint64_t>(8): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY";
        case static_cast<uint64_t>(9): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY";
        case static_cast<uint64_t>(10): return "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST";
        case static_cast<uint64_t>(2147483647): return "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM";
        default: return "VkPrimitiveTopology_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkProvokingVertexModeEXT>(VkProvokingVertexModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT";
        case static_cast<uint64_t>(1): return "VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_PROVOKING_VERTEX_MODE_EXT_MAX_ENUM";
        default: return "VkProvokingVertexModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryControlFlagBits>(VkQueryControlFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_CONTROL_PRECISE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM";
        default: return "VkQueryControlFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPipelineStatisticFlagBits>(VkQueryPipelineStatisticFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT";
        case static_cast<uint64_t>(2): return "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT";
        case static_cast<uint64_t>(4): return "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(8): return "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(16): return "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT";
        case static_cast<uint64_t>(32): return "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT";
        case static_cast<uint64_t>(64): return "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT";
        case static_cast<uint64_t>(128): return "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(256): return "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT";
        case static_cast<uint64_t>(512): return "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(1024): return "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8192): return "VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI";
        case static_cast<uint64_t>(2048): return "VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT";
        default: return "VkQueryPipelineStatisticFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPoolCreateFlagBits>(VkQueryPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_QUERY_POOL_CREATE_RESET_BIT_KHR";
        default: return "VkQueryPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPoolSamplingModeINTEL>(VkQueryPoolSamplingModeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_POOL_SAMPLING_MODE_INTEL_MAX_ENUM";
        default: return "VkQueryPoolSamplingModeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryResultFlagBits>(VkQueryResultFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_RESULT_64_BIT";
        case static_cast<uint64_t>(2): return "VK_QUERY_RESULT_WAIT_BIT";
        case static_cast<uint64_t>(4): return "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT";
        case static_cast<uint64_t>(8): return "VK_QUERY_RESULT_PARTIAL_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR";
        default: return "VkQueryResultFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryResultStatusKHR>(VkQueryResultStatusKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(-1): return "VK_QUERY_RESULT_STATUS_ERROR_KHR";
        case static_cast<uint64_t>(0): return "VK_QUERY_RESULT_STATUS_NOT_READY_KHR";
        case static_cast<uint64_t>(1): return "VK_QUERY_RESULT_STATUS_COMPLETE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_RESULT_STATUS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(-1000299000): return "VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR";
        default: return "VkQueryResultStatusKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryType>(VkQueryType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_QUERY_TYPE_OCCLUSION";
        case static_cast<uint64_t>(1): return "VK_QUERY_TYPE_PIPELINE_STATISTICS";
        case static_cast<uint64_t>(2): return "VK_QUERY_TYPE_TIMESTAMP";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000023000): return "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR";
        case static_cast<uint64_t>(1000028004): return "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT";
        case static_cast<uint64_t>(1000116000): return "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR";
        case static_cast<uint64_t>(1000165000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV";
        case static_cast<uint64_t>(1000210000): return "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL";
        case static_cast<uint64_t>(1000299000): return "VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR";
        case static_cast<uint64_t>(1000382000): return "VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT";
        case static_cast<uint64_t>(1000386000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR";
        case static_cast<uint64_t>(1000386001): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR";
        case static_cast<uint64_t>(1000396000): return "VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT";
        case static_cast<uint64_t>(1000396001): return "VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR";
        case static_cast<uint64_t>(1000150001): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR";
        case static_cast<uint64_t>(1000328000): return "VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT";
        default: return "VkQueryType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueueFlagBits>(VkQueueFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUEUE_GRAPHICS_BIT";
        case static_cast<uint64_t>(2): return "VK_QUEUE_COMPUTE_BIT";
        case static_cast<uint64_t>(4): return "VK_QUEUE_TRANSFER_BIT";
        case static_cast<uint64_t>(8): return "VK_QUEUE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUEUE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_QUEUE_PROTECTED_BIT";
        case static_cast<uint64_t>(32): return "VK_QUEUE_VIDEO_DECODE_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_QUEUE_VIDEO_ENCODE_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_QUEUE_OPTICAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(1024): return "VK_QUEUE_DATA_GRAPH_BIT_ARM";
        default: return "VkQueueFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueueGlobalPriority>(VkQueueGlobalPriority type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(128): return "VK_QUEUE_GLOBAL_PRIORITY_LOW";
        case static_cast<uint64_t>(256): return "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM";
        case static_cast<uint64_t>(512): return "VK_QUEUE_GLOBAL_PRIORITY_HIGH";
        case static_cast<uint64_t>(1024): return "VK_QUEUE_GLOBAL_PRIORITY_REALTIME";
        case static_cast<uint64_t>(2147483647): return "VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM";
        default: return "VkQueueGlobalPriority_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRasterizationOrderAMD>(VkRasterizationOrderAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RASTERIZATION_ORDER_STRICT_AMD";
        case static_cast<uint64_t>(1): return "VK_RASTERIZATION_ORDER_RELAXED_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_RASTERIZATION_ORDER_AMD_MAX_ENUM";
        default: return "VkRasterizationOrderAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingInvocationReorderModeNV>(VkRayTracingInvocationReorderModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingInvocationReorderModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingLssIndexingModeNV>(VkRayTracingLssIndexingModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_LSS_INDEXING_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingLssIndexingModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingLssPrimitiveEndCapsModeNV>(VkRayTracingLssPrimitiveEndCapsModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingLssPrimitiveEndCapsModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingShaderGroupTypeKHR>(VkRayTracingShaderGroupTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR";
        case static_cast<uint64_t>(2): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_KHR_MAX_ENUM";
        default: return "VkRayTracingShaderGroupTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRenderPassCreateFlagBits>(VkRenderPassCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM";
        case static_cast<uint64_t>(4): return "VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE";
        default: return "VkRenderPassCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRenderingFlagBits>(VkRenderingFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT";
        case static_cast<uint64_t>(2): return "VK_RENDERING_SUSPENDING_BIT";
        case static_cast<uint64_t>(4): return "VK_RENDERING_RESUMING_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_RENDERING_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_RENDERING_CONTENTS_INLINE_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE";
        default: return "VkRenderingFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkResolveModeFlagBits>(VkResolveModeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RESOLVE_MODE_NONE";
        case static_cast<uint64_t>(1): return "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT";
        case static_cast<uint64_t>(2): return "VK_RESOLVE_MODE_AVERAGE_BIT";
        case static_cast<uint64_t>(4): return "VK_RESOLVE_MODE_MIN_BIT";
        case static_cast<uint64_t>(8): return "VK_RESOLVE_MODE_MAX_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID";
        default: return "VkResolveModeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkResult>(VkResult type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUCCESS";
        case static_cast<uint64_t>(1): return "VK_NOT_READY";
        case static_cast<uint64_t>(2): return "VK_TIMEOUT";
        case static_cast<uint64_t>(3): return "VK_EVENT_SET";
        case static_cast<uint64_t>(4): return "VK_EVENT_RESET";
        case static_cast<uint64_t>(5): return "VK_INCOMPLETE";
        case static_cast<uint64_t>(-1): return "VK_ERROR_OUT_OF_HOST_MEMORY";
        case static_cast<uint64_t>(-2): return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
        case static_cast<uint64_t>(-3): return "VK_ERROR_INITIALIZATION_FAILED";
        case static_cast<uint64_t>(-4): return "VK_ERROR_DEVICE_LOST";
        case static_cast<uint64_t>(-5): return "VK_ERROR_MEMORY_MAP_FAILED";
        case static_cast<uint64_t>(-6): return "VK_ERROR_LAYER_NOT_PRESENT";
        case static_cast<uint64_t>(-7): return "VK_ERROR_EXTENSION_NOT_PRESENT";
        case static_cast<uint64_t>(-8): return "VK_ERROR_FEATURE_NOT_PRESENT";
        case static_cast<uint64_t>(-9): return "VK_ERROR_INCOMPATIBLE_DRIVER";
        case static_cast<uint64_t>(-10): return "VK_ERROR_TOO_MANY_OBJECTS";
        case static_cast<uint64_t>(-11): return "VK_ERROR_FORMAT_NOT_SUPPORTED";
        case static_cast<uint64_t>(-12): return "VK_ERROR_FRAGMENTED_POOL";
        case static_cast<uint64_t>(-13): return "VK_ERROR_UNKNOWN";
        case static_cast<uint64_t>(2147483647): return "VK_RESULT_MAX_ENUM";
        case static_cast<uint64_t>(-1000069000): return "VK_ERROR_OUT_OF_POOL_MEMORY";
        case static_cast<uint64_t>(-1000072003): return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
        case static_cast<uint64_t>(-1000161000): return "VK_ERROR_FRAGMENTATION";
        case static_cast<uint64_t>(-1000257000): return "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS";
        case static_cast<uint64_t>(1000297000): return "VK_PIPELINE_COMPILE_REQUIRED";
        case static_cast<uint64_t>(-1000174001): return "VK_ERROR_NOT_PERMITTED";
        case static_cast<uint64_t>(-1000000000): return "VK_ERROR_SURFACE_LOST_KHR";
        case static_cast<uint64_t>(-1000000001): return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
        case static_cast<uint64_t>(1000001003): return "VK_SUBOPTIMAL_KHR";
        case static_cast<uint64_t>(-1000001004): return "VK_ERROR_OUT_OF_DATE_KHR";
        case static_cast<uint64_t>(-1000003001): return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
        case static_cast<uint64_t>(-1000011001): return "VK_ERROR_VALIDATION_FAILED_EXT";
        case static_cast<uint64_t>(-1000012000): return "VK_ERROR_INVALID_SHADER_NV";
        case static_cast<uint64_t>(-1000023000): return "VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023001): return "VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023002): return "VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023003): return "VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023004): return "VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023005): return "VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000158000): return "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT";
        case static_cast<uint64_t>(-1000255000): return "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT";
        case static_cast<uint64_t>(1000268000): return "VK_THREAD_IDLE_KHR";
        case static_cast<uint64_t>(1000268001): return "VK_THREAD_DONE_KHR";
        case static_cast<uint64_t>(1000268002): return "VK_OPERATION_DEFERRED_KHR";
        case static_cast<uint64_t>(1000268003): return "VK_OPERATION_NOT_DEFERRED_KHR";
        case static_cast<uint64_t>(-1000299000): return "VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR";
        case static_cast<uint64_t>(-1000338000): return "VK_ERROR_COMPRESSION_EXHAUSTED_EXT";
        case static_cast<uint64_t>(1000482000): return "VK_INCOMPATIBLE_SHADER_BINARY_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_PIPELINE_BINARY_MISSING_KHR";
        case static_cast<uint64_t>(-1000483000): return "VK_ERROR_NOT_ENOUGH_SPACE_KHR";
        default: return "VkResult_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSampleCountFlagBits>(VkSampleCountFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SAMPLE_COUNT_1_BIT";
        case static_cast<uint64_t>(2): return "VK_SAMPLE_COUNT_2_BIT";
        case static_cast<uint64_t>(4): return "VK_SAMPLE_COUNT_4_BIT";
        case static_cast<uint64_t>(8): return "VK_SAMPLE_COUNT_8_BIT";
        case static_cast<uint64_t>(16): return "VK_SAMPLE_COUNT_16_BIT";
        case static_cast<uint64_t>(32): return "VK_SAMPLE_COUNT_32_BIT";
        case static_cast<uint64_t>(64): return "VK_SAMPLE_COUNT_64_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM";
        default: return "VkSampleCountFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerAddressMode>(VkSamplerAddressMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_ADDRESS_MODE_REPEAT";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE";
        case static_cast<uint64_t>(3): return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE";
        default: return "VkSamplerAddressMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerCreateFlagBits>(VkSamplerCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM";
        default: return "VkSamplerCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerMipmapMode>(VkSamplerMipmapMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_MIPMAP_MODE_NEAREST";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_MIPMAP_MODE_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM";
        default: return "VkSamplerMipmapMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerReductionMode>(VkSamplerReductionMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_REDUCTION_MODE_MIN";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_REDUCTION_MODE_MAX";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM";
        case static_cast<uint64_t>(1000521000): return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM";
        default: return "VkSamplerReductionMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerYcbcrModelConversion>(VkSamplerYcbcrModelConversion type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709";
        case static_cast<uint64_t>(3): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM";
        default: return "VkSamplerYcbcrModelConversion_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerYcbcrRange>(VkSamplerYcbcrRange type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_YCBCR_RANGE_ITU_FULL";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_YCBCR_RANGE_MAX_ENUM";
        default: return "VkSamplerYcbcrRange_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkScopeKHR>(VkScopeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SCOPE_DEVICE_KHR";
        case static_cast<uint64_t>(2): return "VK_SCOPE_WORKGROUP_KHR";
        case static_cast<uint64_t>(3): return "VK_SCOPE_SUBGROUP_KHR";
        case static_cast<uint64_t>(5): return "VK_SCOPE_QUEUE_FAMILY_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SCOPE_KHR_MAX_ENUM";
        default: return "VkScopeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreImportFlagBits>(VkSemaphoreImportFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM";
        default: return "VkSemaphoreImportFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreType>(VkSemaphoreType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SEMAPHORE_TYPE_BINARY";
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_TYPE_TIMELINE";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_TYPE_MAX_ENUM";
        default: return "VkSemaphoreType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreWaitFlagBits>(VkSemaphoreWaitFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_WAIT_ANY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM";
        default: return "VkSemaphoreWaitFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderCodeTypeEXT>(VkShaderCodeTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_CODE_TYPE_BINARY_EXT";
        case static_cast<uint64_t>(1): return "VK_SHADER_CODE_TYPE_SPIRV_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_CODE_TYPE_EXT_MAX_ENUM";
        default: return "VkShaderCodeTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderCreateFlagBitsEXT>(VkShaderCreateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SHADER_CREATE_LINK_STAGE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_CREATE_FLAG_BITS_EXT_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT";
        default: return "VkShaderCreateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderFloatControlsIndependence>(VkShaderFloatControlsIndependence type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY";
        case static_cast<uint64_t>(1): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL";
        case static_cast<uint64_t>(2): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM";
        default: return "VkShaderFloatControlsIndependence_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderGroupShaderKHR>(VkShaderGroupShaderKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_GROUP_SHADER_GENERAL_KHR";
        case static_cast<uint64_t>(1): return "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR";
        case static_cast<uint64_t>(3): return "VK_SHADER_GROUP_SHADER_INTERSECTION_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_GROUP_SHADER_KHR_MAX_ENUM";
        default: return "VkShaderGroupShaderKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderInfoTypeAMD>(VkShaderInfoTypeAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_INFO_TYPE_STATISTICS_AMD";
        case static_cast<uint64_t>(1): return "VK_SHADER_INFO_TYPE_BINARY_AMD";
        case static_cast<uint64_t>(2): return "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_INFO_TYPE_AMD_MAX_ENUM";
        default: return "VkShaderInfoTypeAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderStageFlagBits>(VkShaderStageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SHADER_STAGE_VERTEX_BIT";
        case static_cast<uint64_t>(2): return "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT";
        case static_cast<uint64_t>(4): return "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT";
        case static_cast<uint64_t>(8): return "VK_SHADER_STAGE_GEOMETRY_BIT";
        case static_cast<uint64_t>(16): return "VK_SHADER_STAGE_FRAGMENT_BIT";
        case static_cast<uint64_t>(32): return "VK_SHADER_STAGE_COMPUTE_BIT";
        case static_cast<uint64_t>(31): return "VK_SHADER_STAGE_ALL_GRAPHICS";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_STAGE_ALL";
        case static_cast<uint64_t>(16384): return "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI";
        case static_cast<uint64_t>(524288): return "VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI";
        case static_cast<uint64_t>(256): return "VK_SHADER_STAGE_RAYGEN_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_SHADER_STAGE_ANY_HIT_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_SHADER_STAGE_MISS_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_SHADER_STAGE_INTERSECTION_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_SHADER_STAGE_CALLABLE_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SHADER_STAGE_TASK_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SHADER_STAGE_MESH_BIT_EXT";
        default: return "VkShaderStageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShadingRatePaletteEntryNV>(VkShadingRatePaletteEntryNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV";
        case static_cast<uint64_t>(1): return "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(2): return "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(3): return "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(4): return "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(5): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV";
        case static_cast<uint64_t>(6): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV";
        case static_cast<uint64_t>(7): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV";
        case static_cast<uint64_t>(8): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV";
        case static_cast<uint64_t>(9): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV";
        case static_cast<uint64_t>(10): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV";
        case static_cast<uint64_t>(11): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_SHADING_RATE_PALETTE_ENTRY_NV_MAX_ENUM";
        default: return "VkShadingRatePaletteEntryNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSharingMode>(VkSharingMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHARING_MODE_EXCLUSIVE";
        case static_cast<uint64_t>(1): return "VK_SHARING_MODE_CONCURRENT";
        case static_cast<uint64_t>(2147483647): return "VK_SHARING_MODE_MAX_ENUM";
        default: return "VkSharingMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSparseImageFormatFlagBits>(VkSparseImageFormatFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT";
        case static_cast<uint64_t>(2): return "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT";
        case static_cast<uint64_t>(4): return "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM";
        default: return "VkSparseImageFormatFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSparseMemoryBindFlagBits>(VkSparseMemoryBindFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SPARSE_MEMORY_BIND_METADATA_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM";
        default: return "VkSparseMemoryBindFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStencilFaceFlagBits>(VkStencilFaceFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_STENCIL_FACE_FRONT_BIT";
        case static_cast<uint64_t>(2): return "VK_STENCIL_FACE_BACK_BIT";
        case static_cast<uint64_t>(3): return "VK_STENCIL_FACE_FRONT_AND_BACK";
        case static_cast<uint64_t>(2147483647): return "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM";
        default: return "VkStencilFaceFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStencilOp>(VkStencilOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_STENCIL_OP_KEEP";
        case static_cast<uint64_t>(1): return "VK_STENCIL_OP_ZERO";
        case static_cast<uint64_t>(2): return "VK_STENCIL_OP_REPLACE";
        case static_cast<uint64_t>(3): return "VK_STENCIL_OP_INCREMENT_AND_CLAMP";
        case static_cast<uint64_t>(4): return "VK_STENCIL_OP_DECREMENT_AND_CLAMP";
        case static_cast<uint64_t>(5): return "VK_STENCIL_OP_INVERT";
        case static_cast<uint64_t>(6): return "VK_STENCIL_OP_INCREMENT_AND_WRAP";
        case static_cast<uint64_t>(7): return "VK_STENCIL_OP_DECREMENT_AND_WRAP";
        case static_cast<uint64_t>(2147483647): return "VK_STENCIL_OP_MAX_ENUM";
        default: return "VkStencilOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStructureType>(VkStructureType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_STRUCTURE_TYPE_APPLICATION_INFO";
        case static_cast<uint64_t>(1): return "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO";
        case static_cast<uint64_t>(2): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO";
        case static_cast<uint64_t>(3): return "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(4): return "VK_STRUCTURE_TYPE_SUBMIT_INFO";
        case static_cast<uint64_t>(5): return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO";
        case static_cast<uint64_t>(6): return "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE";
        case static_cast<uint64_t>(7): return "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO";
        case static_cast<uint64_t>(8): return "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO";
        case static_cast<uint64_t>(9): return "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO";
        case static_cast<uint64_t>(10): return "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO";
        case static_cast<uint64_t>(11): return "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO";
        case static_cast<uint64_t>(12): return "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO";
        case static_cast<uint64_t>(13): return "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO";
        case static_cast<uint64_t>(14): return "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO";
        case static_cast<uint64_t>(15): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO";
        case static_cast<uint64_t>(16): return "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO";
        case static_cast<uint64_t>(17): return "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO";
        case static_cast<uint64_t>(18): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO";
        case static_cast<uint64_t>(19): return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO";
        case static_cast<uint64_t>(20): return "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO";
        case static_cast<uint64_t>(21): return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO";
        case static_cast<uint64_t>(22): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO";
        case static_cast<uint64_t>(23): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO";
        case static_cast<uint64_t>(24): return "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO";
        case static_cast<uint64_t>(25): return "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO";
        case static_cast<uint64_t>(26): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO";
        case static_cast<uint64_t>(27): return "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO";
        case static_cast<uint64_t>(28): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO";
        case static_cast<uint64_t>(29): return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO";
        case static_cast<uint64_t>(30): return "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO";
        case static_cast<uint64_t>(31): return "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO";
        case static_cast<uint64_t>(32): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO";
        case static_cast<uint64_t>(33): return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO";
        case static_cast<uint64_t>(34): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO";
        case static_cast<uint64_t>(35): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(36): return "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET";
        case static_cast<uint64_t>(37): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO";
        case static_cast<uint64_t>(38): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO";
        case static_cast<uint64_t>(39): return "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO";
        case static_cast<uint64_t>(40): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO";
        case static_cast<uint64_t>(41): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO";
        case static_cast<uint64_t>(42): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO";
        case static_cast<uint64_t>(43): return "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO";
        case static_cast<uint64_t>(44): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER";
        case static_cast<uint64_t>(45): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER";
        case static_cast<uint64_t>(46): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER";
        case static_cast<uint64_t>(47): return "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO";
        case static_cast<uint64_t>(48): return "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(2147483647): return "VK_STRUCTURE_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000094000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES";
        case static_cast<uint64_t>(1000157000): return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO";
        case static_cast<uint64_t>(1000157001): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO";
        case static_cast<uint64_t>(1000083000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES";
        case static_cast<uint64_t>(1000127000): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS";
        case static_cast<uint64_t>(1000127001): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000060000): return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO";
        case static_cast<uint64_t>(1000060003): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO";
        case static_cast<uint64_t>(1000060004): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO";
        case static_cast<uint64_t>(1000060005): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO";
        case static_cast<uint64_t>(1000060006): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO";
        case static_cast<uint64_t>(1000060013): return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO";
        case static_cast<uint64_t>(1000060014): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO";
        case static_cast<uint64_t>(1000070000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES";
        case static_cast<uint64_t>(1000070001): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(1000146000): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146001): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146002): return "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146003): return "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2";
        case static_cast<uint64_t>(1000146004): return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2";
        case static_cast<uint64_t>(1000059000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2";
        case static_cast<uint64_t>(1000059001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2";
        case static_cast<uint64_t>(1000059002): return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059003): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2";
        case static_cast<uint64_t>(1000059005): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2";
        case static_cast<uint64_t>(1000059006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2";
        case static_cast<uint64_t>(1000059007): return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059008): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2";
        case static_cast<uint64_t>(1000117000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES";
        case static_cast<uint64_t>(1000117001): return "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO";
        case static_cast<uint64_t>(1000117002): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000117003): return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000053000): return "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO";
        case static_cast<uint64_t>(1000053001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES";
        case static_cast<uint64_t>(1000053002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES";
        case static_cast<uint64_t>(1000120000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES";
        case static_cast<uint64_t>(1000145000): return "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO";
        case static_cast<uint64_t>(1000145001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES";
        case static_cast<uint64_t>(1000145002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES";
        case static_cast<uint64_t>(1000145003): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2";
        case static_cast<uint64_t>(1000156000): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO";
        case static_cast<uint64_t>(1000156001): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO";
        case static_cast<uint64_t>(1000156002): return "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO";
        case static_cast<uint64_t>(1000156003): return "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO";
        case static_cast<uint64_t>(1000156004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES";
        case static_cast<uint64_t>(1000156005): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES";
        case static_cast<uint64_t>(1000085000): return "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO";
        case static_cast<uint64_t>(1000071000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO";
        case static_cast<uint64_t>(1000071001): return "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES";
        case static_cast<uint64_t>(1000071002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO";
        case static_cast<uint64_t>(1000071003): return "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES";
        case static_cast<uint64_t>(1000071004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES";
        case static_cast<uint64_t>(1000072000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO";
        case static_cast<uint64_t>(1000072001): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000072002): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000112000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO";
        case static_cast<uint64_t>(1000112001): return "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES";
        case static_cast<uint64_t>(1000113000): return "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO";
        case static_cast<uint64_t>(1000077000): return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO";
        case static_cast<uint64_t>(1000076000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO";
        case static_cast<uint64_t>(1000076001): return "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES";
        case static_cast<uint64_t>(1000168000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES";
        case static_cast<uint64_t>(1000168001): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT";
        case static_cast<uint64_t>(1000063000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES";
        case static_cast<uint64_t>(49): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES";
        case static_cast<uint64_t>(50): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES";
        case static_cast<uint64_t>(51): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES";
        case static_cast<uint64_t>(52): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES";
        case static_cast<uint64_t>(1000147000): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO";
        case static_cast<uint64_t>(1000109000): return "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2";
        case static_cast<uint64_t>(1000109001): return "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2";
        case static_cast<uint64_t>(1000109002): return "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2";
        case static_cast<uint64_t>(1000109003): return "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2";
        case static_cast<uint64_t>(1000109004): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2";
        case static_cast<uint64_t>(1000109005): return "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO";
        case static_cast<uint64_t>(1000109006): return "VK_STRUCTURE_TYPE_SUBPASS_END_INFO";
        case static_cast<uint64_t>(1000177000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES";
        case static_cast<uint64_t>(1000196000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES";
        case static_cast<uint64_t>(1000180000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES";
        case static_cast<uint64_t>(1000082000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES";
        case static_cast<uint64_t>(1000197000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES";
        case static_cast<uint64_t>(1000161000): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO";
        case static_cast<uint64_t>(1000161001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES";
        case static_cast<uint64_t>(1000161002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES";
        case static_cast<uint64_t>(1000161003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000161004): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT";
        case static_cast<uint64_t>(1000199000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES";
        case static_cast<uint64_t>(1000199001): return "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE";
        case static_cast<uint64_t>(1000221000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES";
        case static_cast<uint64_t>(1000246000): return "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000130000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES";
        case static_cast<uint64_t>(1000130001): return "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO";
        case static_cast<uint64_t>(1000211000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES";
        case static_cast<uint64_t>(1000108000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES";
        case static_cast<uint64_t>(1000108001): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO";
        case static_cast<uint64_t>(1000108002): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO";
        case static_cast<uint64_t>(1000108003): return "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO";
        case static_cast<uint64_t>(1000253000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES";
        case static_cast<uint64_t>(1000175000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES";
        case static_cast<uint64_t>(1000241000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES";
        case static_cast<uint64_t>(1000241001): return "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT";
        case static_cast<uint64_t>(1000241002): return "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT";
        case static_cast<uint64_t>(1000261000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES";
        case static_cast<uint64_t>(1000207000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES";
        case static_cast<uint64_t>(1000207001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES";
        case static_cast<uint64_t>(1000207002): return "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO";
        case static_cast<uint64_t>(1000207003): return "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO";
        case static_cast<uint64_t>(1000207004): return "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO";
        case static_cast<uint64_t>(1000207005): return "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO";
        case static_cast<uint64_t>(1000257000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES";
        case static_cast<uint64_t>(1000244001): return "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO";
        case static_cast<uint64_t>(1000257002): return "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO";
        case static_cast<uint64_t>(1000257003): return "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000257004): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO";
        case static_cast<uint64_t>(53): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES";
        case static_cast<uint64_t>(54): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES";
        case static_cast<uint64_t>(1000192000): return "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO";
        case static_cast<uint64_t>(1000215000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES";
        case static_cast<uint64_t>(1000245000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES";
        case static_cast<uint64_t>(1000276000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES";
        case static_cast<uint64_t>(1000295000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES";
        case static_cast<uint64_t>(1000295001): return "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO";
        case static_cast<uint64_t>(1000295002): return "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO";
        case static_cast<uint64_t>(1000297000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES";
        case static_cast<uint64_t>(1000314000): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314001): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314002): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314003): return "VK_STRUCTURE_TYPE_DEPENDENCY_INFO";
        case static_cast<uint64_t>(1000314004): return "VK_STRUCTURE_TYPE_SUBMIT_INFO_2";
        case static_cast<uint64_t>(1000314005): return "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO";
        case static_cast<uint64_t>(1000314006): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO";
        case static_cast<uint64_t>(1000314007): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES";
        case static_cast<uint64_t>(1000325000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES";
        case static_cast<uint64_t>(1000335000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES";
        case static_cast<uint64_t>(1000337000): return "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2";
        case static_cast<uint64_t>(1000337001): return "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337002): return "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337003): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2";
        case static_cast<uint64_t>(1000337004): return "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337005): return "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337006): return "VK_STRUCTURE_TYPE_BUFFER_COPY_2";
        case static_cast<uint64_t>(1000337007): return "VK_STRUCTURE_TYPE_IMAGE_COPY_2";
        case static_cast<uint64_t>(1000337008): return "VK_STRUCTURE_TYPE_IMAGE_BLIT_2";
        case static_cast<uint64_t>(1000337009): return "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2";
        case static_cast<uint64_t>(1000337010): return "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2";
        case static_cast<uint64_t>(1000225000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES";
        case static_cast<uint64_t>(1000225001): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO";
        case static_cast<uint64_t>(1000225002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES";
        case static_cast<uint64_t>(1000138000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES";
        case static_cast<uint64_t>(1000138001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES";
        case static_cast<uint64_t>(1000138002): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK";
        case static_cast<uint64_t>(1000138003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO";
        case static_cast<uint64_t>(1000066000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES";
        case static_cast<uint64_t>(1000044000): return "VK_STRUCTURE_TYPE_RENDERING_INFO";
        case static_cast<uint64_t>(1000044001): return "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO";
        case static_cast<uint64_t>(1000044002): return "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO";
        case static_cast<uint64_t>(1000044003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES";
        case static_cast<uint64_t>(1000044004): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO";
        case static_cast<uint64_t>(1000280000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES";
        case static_cast<uint64_t>(1000280001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES";
        case static_cast<uint64_t>(1000281001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES";
        case static_cast<uint64_t>(1000360000): return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3";
        case static_cast<uint64_t>(1000413000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES";
        case static_cast<uint64_t>(1000413001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES";
        case static_cast<uint64_t>(1000413002): return "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS";
        case static_cast<uint64_t>(1000413003): return "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS";
        case static_cast<uint64_t>(55): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES";
        case static_cast<uint64_t>(56): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES";
        case static_cast<uint64_t>(1000174000): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO";
        case static_cast<uint64_t>(1000388000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES";
        case static_cast<uint64_t>(1000388001): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES";
        case static_cast<uint64_t>(1000416000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES";
        case static_cast<uint64_t>(1000528000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES";
        case static_cast<uint64_t>(1000544000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES";
        case static_cast<uint64_t>(1000259000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES";
        case static_cast<uint64_t>(1000259001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000259002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES";
        case static_cast<uint64_t>(1000525000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES";
        case static_cast<uint64_t>(1000190001): return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000190002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES";
        case static_cast<uint64_t>(1000265000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES";
        case static_cast<uint64_t>(1000271000): return "VK_STRUCTURE_TYPE_MEMORY_MAP_INFO";
        case static_cast<uint64_t>(1000271001): return "VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO";
        case static_cast<uint64_t>(1000470000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES";
        case static_cast<uint64_t>(1000470001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES";
        case static_cast<uint64_t>(1000470003): return "VK_STRUCTURE_TYPE_RENDERING_AREA_INFO";
        case static_cast<uint64_t>(1000470004): return "VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO";
        case static_cast<uint64_t>(1000338002): return "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2";
        case static_cast<uint64_t>(1000338003): return "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2";
        case static_cast<uint64_t>(1000470005): return "VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO";
        case static_cast<uint64_t>(1000470006): return "VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO";
        case static_cast<uint64_t>(1000080000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES";
        case static_cast<uint64_t>(1000232000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES";
        case static_cast<uint64_t>(1000232001): return "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO";
        case static_cast<uint64_t>(1000232002): return "VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO";
        case static_cast<uint64_t>(1000545000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES";
        case static_cast<uint64_t>(1000545001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES";
        case static_cast<uint64_t>(1000545002): return "VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS";
        case static_cast<uint64_t>(1000545003): return "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO";
        case static_cast<uint64_t>(1000545004): return "VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO";
        case static_cast<uint64_t>(1000545005): return "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO";
        case static_cast<uint64_t>(1000545006): return "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO";
        case static_cast<uint64_t>(1000466000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES";
        case static_cast<uint64_t>(1000068000): return "VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO";
        case static_cast<uint64_t>(1000068001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES";
        case static_cast<uint64_t>(1000068002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES";
        case static_cast<uint64_t>(1000270000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES";
        case static_cast<uint64_t>(1000270001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES";
        case static_cast<uint64_t>(1000270002): return "VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY";
        case static_cast<uint64_t>(1000270003): return "VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY";
        case static_cast<uint64_t>(1000270004): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO";
        case static_cast<uint64_t>(1000270005): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO";
        case static_cast<uint64_t>(1000270006): return "VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO";
        case static_cast<uint64_t>(1000270007): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO";
        case static_cast<uint64_t>(1000270008): return "VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE";
        case static_cast<uint64_t>(1000270009): return "VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY";
        case static_cast<uint64_t>(1000001000): return "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000001001): return "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000060007): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000060008): return "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000060009): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR";
        case static_cast<uint64_t>(1000060010): return "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR";
        case static_cast<uint64_t>(1000060011): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000060012): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000002000): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000002001): return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000003000): return "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000004000): return "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000005000): return "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000006000): return "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000008000): return "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000009000): return "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000011000): return "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000018000): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD";
        case static_cast<uint64_t>(1000022000): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT";
        case static_cast<uint64_t>(1000022001): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT";
        case static_cast<uint64_t>(1000022002): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT";
        case static_cast<uint64_t>(1000023000): return "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000023001): return "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000023002): return "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR";
        case static_cast<uint64_t>(1000023003): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR";
        case static_cast<uint64_t>(1000023004): return "VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR";
        case static_cast<uint64_t>(1000023005): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000023006): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000023007): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR";
        case static_cast<uint64_t>(1000023008): return "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR";
        case static_cast<uint64_t>(1000023009): return "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR";
        case static_cast<uint64_t>(1000023010): return "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000023011): return "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000023012): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000023013): return "VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR";
        case static_cast<uint64_t>(1000023014): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR";
        case static_cast<uint64_t>(1000023015): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000023016): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000024000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR";
        case static_cast<uint64_t>(1000024001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000024002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR";
        case static_cast<uint64_t>(1000026000): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000026001): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000026002): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV";
        case static_cast<uint64_t>(1000028000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT";
        case static_cast<uint64_t>(1000028001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000028002): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000038000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000038001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000038002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000038003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000038004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000038005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR";
        case static_cast<uint64_t>(1000038006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000038007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000038008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000038009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000038010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000038011): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000038012): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000038013): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000039000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000039001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000039002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000039003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000039004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000039005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR";
        case static_cast<uint64_t>(1000039006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000039007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000039009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000039010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000039011): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000039012): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000039013): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000039014): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000040000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000040001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000040003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000040004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000040005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000040006): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000041000): return "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD";
        case static_cast<uint64_t>(1000049000): return "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP";
        case static_cast<uint64_t>(1000050000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV";
        case static_cast<uint64_t>(1000056000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000056001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV";
        case static_cast<uint64_t>(1000057000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV";
        case static_cast<uint64_t>(1000057001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV";
        case static_cast<uint64_t>(1000058000): return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV";
        case static_cast<uint64_t>(1000061000): return "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT";
        case static_cast<uint64_t>(1000062000): return "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN";
        case static_cast<uint64_t>(1000067000): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT";
        case static_cast<uint64_t>(1000067001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT";
        case static_cast<uint64_t>(1000073000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000073001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000073002): return "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000073003): return "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000074000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR";
        case static_cast<uint64_t>(1000074001): return "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000074002): return "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000075000): return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR";
        case static_cast<uint64_t>(1000078000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000078001): return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000078002): return "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR";
        case static_cast<uint64_t>(1000078003): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000079000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR";
        case static_cast<uint64_t>(1000079001): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000081000): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT";
        case static_cast<uint64_t>(1000081001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT";
        case static_cast<uint64_t>(1000081002): return "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT";
        case static_cast<uint64_t>(1000084000): return "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR";
        case static_cast<uint64_t>(1000087000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000090000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT";
        case static_cast<uint64_t>(1000091000): return "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT";
        case static_cast<uint64_t>(1000091001): return "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000091002): return "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000091003): return "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000092000): return "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE";
        case static_cast<uint64_t>(1000098000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000099000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000099001): return "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000101000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000101001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000102000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000102001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000105000): return "VK_STRUCTURE_TYPE_HDR_METADATA_EXT";
        case static_cast<uint64_t>(1000110000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG";
        case static_cast<uint64_t>(1000111000): return "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000114000): return "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000114001): return "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000114002): return "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000115000): return "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR";
        case static_cast<uint64_t>(1000115001): return "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000116000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR";
        case static_cast<uint64_t>(1000116001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000116002): return "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000116003): return "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR";
        case static_cast<uint64_t>(1000116004): return "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR";
        case static_cast<uint64_t>(1000116005): return "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR";
        case static_cast<uint64_t>(1000116006): return "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR";
        case static_cast<uint64_t>(1000119000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR";
        case static_cast<uint64_t>(1000119001): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR";
        case static_cast<uint64_t>(1000119002): return "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR";
        case static_cast<uint64_t>(1000121000): return "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121001): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121002): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121003): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR";
        case static_cast<uint64_t>(1000121004): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR";
        case static_cast<uint64_t>(1000122000): return "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK";
        case static_cast<uint64_t>(1000123000): return "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK";
        case static_cast<uint64_t>(1000128000): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT";
        case static_cast<uint64_t>(1000128001): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT";
        case static_cast<uint64_t>(1000128002): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT";
        case static_cast<uint64_t>(1000128003): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000128004): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000129000): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID";
        case static_cast<uint64_t>(1000129001): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000129002): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000129003): return "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
        case static_cast<uint64_t>(1000129004): return "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
        case static_cast<uint64_t>(1000129005): return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID";
        case static_cast<uint64_t>(1000129006): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID";
        case static_cast<uint64_t>(1000134000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX";
        case static_cast<uint64_t>(1000134001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX";
        case static_cast<uint64_t>(1000134002): return "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX";
        case static_cast<uint64_t>(1000134003): return "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX";
        case static_cast<uint64_t>(1000134004): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX";
        case static_cast<uint64_t>(1000044008): return "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD";
        case static_cast<uint64_t>(1000141000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR";
        case static_cast<uint64_t>(1000143000): return "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT";
        case static_cast<uint64_t>(1000143001): return "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT";
        case static_cast<uint64_t>(1000143002): return "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000143003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000143004): return "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000148000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT";
        case static_cast<uint64_t>(1000148001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000148002): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000149000): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000152000): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000154000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV";
        case static_cast<uint64_t>(1000154001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000158000): return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT";
        case static_cast<uint64_t>(1000158002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT";
        case static_cast<uint64_t>(1000158003): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000158004): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000158005): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000158006): return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT";
        case static_cast<uint64_t>(1000160000): return "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000160001): return "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000163000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR";
        case static_cast<uint64_t>(1000163001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000164000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000164001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV";
        case static_cast<uint64_t>(1000164002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000164005): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165000): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165001): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165003): return "VK_STRUCTURE_TYPE_GEOMETRY_NV";
        case static_cast<uint64_t>(1000165004): return "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV";
        case static_cast<uint64_t>(1000165005): return "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV";
        case static_cast<uint64_t>(1000165006): return "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV";
        case static_cast<uint64_t>(1000165007): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000165008): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV";
        case static_cast<uint64_t>(1000165009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV";
        case static_cast<uint64_t>(1000165011): return "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165012): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV";
        case static_cast<uint64_t>(1000166000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV";
        case static_cast<uint64_t>(1000166001): return "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000170000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT";
        case static_cast<uint64_t>(1000170001): return "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000178000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT";
        case static_cast<uint64_t>(1000178001): return "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000178002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000181000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR";
        case static_cast<uint64_t>(1000183000): return "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000185000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD";
        case static_cast<uint64_t>(1000187000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000187001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000187002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000187003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000187004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000187005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000189000): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000190000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000191000): return "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP";
        case static_cast<uint64_t>(1000202000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV";
        case static_cast<uint64_t>(1000202001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV";
        case static_cast<uint64_t>(1000204000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV";
        case static_cast<uint64_t>(1000205000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000205002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV";
        case static_cast<uint64_t>(1000206000): return "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV";
        case static_cast<uint64_t>(1000206001): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000314008): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV";
        case static_cast<uint64_t>(1000314009): return "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV";
        case static_cast<uint64_t>(1000209000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL";
        case static_cast<uint64_t>(1000210000): return "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL";
        case static_cast<uint64_t>(1000210001): return "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL";
        case static_cast<uint64_t>(1000210002): return "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL";
        case static_cast<uint64_t>(1000210003): return "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL";
        case static_cast<uint64_t>(1000210004): return "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL";
        case static_cast<uint64_t>(1000210005): return "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL";
        case static_cast<uint64_t>(1000212000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000213000): return "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD";
        case static_cast<uint64_t>(1000213001): return "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000214000): return "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000217000): return "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000218000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000218001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000218002): return "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000044007): return "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT";
        case static_cast<uint64_t>(1000226000): return "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR";
        case static_cast<uint64_t>(1000226001): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000226002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000226003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR";
        case static_cast<uint64_t>(1000226004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR";
        case static_cast<uint64_t>(1000044006): return "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR";
        case static_cast<uint64_t>(1000227000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD";
        case static_cast<uint64_t>(1000229000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD";
        case static_cast<uint64_t>(1000234000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT";
        case static_cast<uint64_t>(1000235000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR";
        case static_cast<uint64_t>(1000237000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000238000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT";
        case static_cast<uint64_t>(1000238001): return "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT";
        case static_cast<uint64_t>(1000239000): return "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000240000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV";
        case static_cast<uint64_t>(1000244000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000244002): return "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000247000): return "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT";
        case static_cast<uint64_t>(1000248000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR";
        case static_cast<uint64_t>(1000249000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV";
        case static_cast<uint64_t>(1000249001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV";
        case static_cast<uint64_t>(1000249002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV";
        case static_cast<uint64_t>(1000250000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV";
        case static_cast<uint64_t>(1000250001): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000250002): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV";
        case static_cast<uint64_t>(1000251000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT";
        case static_cast<uint64_t>(1000252000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT";
        case static_cast<uint64_t>(1000254000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT";
        case static_cast<uint64_t>(1000254001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000254002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000255000): return "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT";
        case static_cast<uint64_t>(1000255002): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT";
        case static_cast<uint64_t>(1000255001): return "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT";
        case static_cast<uint64_t>(1000256000): return "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000260000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT";
        case static_cast<uint64_t>(1000267000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000269000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR";
        case static_cast<uint64_t>(1000269001): return "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR";
        case static_cast<uint64_t>(1000269002): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000269003): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR";
        case static_cast<uint64_t>(1000269004): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR";
        case static_cast<uint64_t>(1000269005): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR";
        case static_cast<uint64_t>(1000272000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT";
        case static_cast<uint64_t>(1000272001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000272002): return "VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT";
        case static_cast<uint64_t>(1000273000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000277000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000277001): return "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277002): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277003): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV";
        case static_cast<uint64_t>(1000277004): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277005): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV";
        case static_cast<uint64_t>(1000277006): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV";
        case static_cast<uint64_t>(1000277007): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV";
        case static_cast<uint64_t>(1000278000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV";
        case static_cast<uint64_t>(1000278001): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV";
        case static_cast<uint64_t>(1000281000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT";
        case static_cast<uint64_t>(1000282000): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM";
        case static_cast<uint64_t>(1000282001): return "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000283000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000283001): return "VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT";
        case static_cast<uint64_t>(1000283002): return "VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT";
        case static_cast<uint64_t>(1000284000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT";
        case static_cast<uint64_t>(1000284001): return "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000284002): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000287000): return "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000287001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000287002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT";
        case static_cast<uint64_t>(1000290000): return "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000292000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV";
        case static_cast<uint64_t>(1000292001): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV";
        case static_cast<uint64_t>(1000292002): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000294000): return "VK_STRUCTURE_TYPE_PRESENT_ID_KHR";
        case static_cast<uint64_t>(1000294001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR";
        case static_cast<uint64_t>(1000299000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR";
        case static_cast<uint64_t>(1000299001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000299002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000299003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000299004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR";
        case static_cast<uint64_t>(1000299005): return "VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000299006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR";
        case static_cast<uint64_t>(1000299007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000299008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR";
        case static_cast<uint64_t>(1000299009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000299010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000300000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV";
        case static_cast<uint64_t>(1000300001): return "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307000): return "VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307001): return "VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307002): return "VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV";
        case static_cast<uint64_t>(1000307003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV";
        case static_cast<uint64_t>(1000307004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV";
        case static_cast<uint64_t>(1000309000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM";
        case static_cast<uint64_t>(1000309001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000309002): return "VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000309003): return "VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000309004): return "VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM";
        case static_cast<uint64_t>(1000309005): return "VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM";
        case static_cast<uint64_t>(1000310000): return "VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV";
        case static_cast<uint64_t>(1000311000): return "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000311001): return "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT";
        case static_cast<uint64_t>(1000311002): return "VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT";
        case static_cast<uint64_t>(1000311003): return "VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT";
        case static_cast<uint64_t>(1000311004): return "VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT";
        case static_cast<uint64_t>(1000311005): return "VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT";
        case static_cast<uint64_t>(1000311006): return "VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT";
        case static_cast<uint64_t>(1000311007): return "VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT";
        case static_cast<uint64_t>(1000311008): return "VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT";
        case static_cast<uint64_t>(1000311009): return "VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT";
        case static_cast<uint64_t>(1000311010): return "VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000311011): return "VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000316000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000316001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000316002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT";
        case static_cast<uint64_t>(1000316003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT";
        case static_cast<uint64_t>(1000316004): return "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT";
        case static_cast<uint64_t>(1000316005): return "VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316006): return "VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316007): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316008): return "VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316010): return "VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000316011): return "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT";
        case static_cast<uint64_t>(1000316012): return "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT";
        case static_cast<uint64_t>(1000316009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000320000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT";
        case static_cast<uint64_t>(1000320001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000320002): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000321000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD";
        case static_cast<uint64_t>(1000203000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR";
        case static_cast<uint64_t>(1000322000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000323000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR";
        case static_cast<uint64_t>(1000326000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000326001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV";
        case static_cast<uint64_t>(1000326002): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000327000): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV";
        case static_cast<uint64_t>(1000327001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV";
        case static_cast<uint64_t>(1000327002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV";
        case static_cast<uint64_t>(1000330000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000332000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000332001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000333000): return "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM";
        case static_cast<uint64_t>(1000336000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR";
        case static_cast<uint64_t>(1000338000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000338001): return "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT";
        case static_cast<uint64_t>(1000338004): return "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000339000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT";
        case static_cast<uint64_t>(1000340000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000341000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT";
        case static_cast<uint64_t>(1000341001): return "VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT";
        case static_cast<uint64_t>(1000341002): return "VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT";
        case static_cast<uint64_t>(1000344000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000346000): return "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000352000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000352001): return "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT";
        case static_cast<uint64_t>(1000352002): return "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT";
        case static_cast<uint64_t>(1000353000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000354000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT";
        case static_cast<uint64_t>(1000354001): return "VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000355000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000355001): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000356000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT";
        case static_cast<uint64_t>(1000364000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000364001): return "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA";
        case static_cast<uint64_t>(1000364002): return "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000365000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000365001): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366000): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366001): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA";
        case static_cast<uint64_t>(1000366002): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366003): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA";
        case static_cast<uint64_t>(1000366004): return "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366005): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366006): return "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366007): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366008): return "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA";
        case static_cast<uint64_t>(1000366009): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000369000): return "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI";
        case static_cast<uint64_t>(1000369001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000369002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI";
        case static_cast<uint64_t>(1000370000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000371000): return "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV";
        case static_cast<uint64_t>(1000371001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV";
        case static_cast<uint64_t>(1000372000): return "VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT";
        case static_cast<uint64_t>(1000372001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT";
        case static_cast<uint64_t>(1000375000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT";
        case static_cast<uint64_t>(1000375001): return "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT";
        case static_cast<uint64_t>(1000376000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT";
        case static_cast<uint64_t>(1000376001): return "VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT";
        case static_cast<uint64_t>(1000376002): return "VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT";
        case static_cast<uint64_t>(1000377000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000378000): return "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX";
        case static_cast<uint64_t>(1000381000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000381001): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000382000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT";
        case static_cast<uint64_t>(1000386000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000391000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT";
        case static_cast<uint64_t>(1000391001): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000392000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT";
        case static_cast<uint64_t>(1000392001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000393000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT";
        case static_cast<uint64_t>(1000395000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT";
        case static_cast<uint64_t>(1000395001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000396000): return "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT";
        case static_cast<uint64_t>(1000396001): return "VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT";
        case static_cast<uint64_t>(1000396002): return "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT";
        case static_cast<uint64_t>(1000396003): return "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT";
        case static_cast<uint64_t>(1000396004): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT";
        case static_cast<uint64_t>(1000396005): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000396006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000396007): return "VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000396008): return "VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT";
        case static_cast<uint64_t>(1000396009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT";
        case static_cast<uint64_t>(1000397000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV";
        case static_cast<uint64_t>(1000397001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV";
        case static_cast<uint64_t>(1000397002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV";
        case static_cast<uint64_t>(1000404000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000404001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI";
        case static_cast<uint64_t>(1000404002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000411000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000411001): return "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000412000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT";
        case static_cast<uint64_t>(1000415000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000417000): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000417001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM";
        case static_cast<uint64_t>(1000417002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000418000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT";
        case static_cast<uint64_t>(1000418001): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000420000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE";
        case static_cast<uint64_t>(1000420001): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE";
        case static_cast<uint64_t>(1000420002): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE";
        case static_cast<uint64_t>(1000422000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000424000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM";
        case static_cast<uint64_t>(1000424001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000424002): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM";
        case static_cast<uint64_t>(1000424003): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM";
        case static_cast<uint64_t>(1000424004): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM";
        case static_cast<uint64_t>(1000426000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV";
        case static_cast<uint64_t>(1000426001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000427000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV";
        case static_cast<uint64_t>(1000427001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV";
        case static_cast<uint64_t>(1000428000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV";
        case static_cast<uint64_t>(1000428001): return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV";
        case static_cast<uint64_t>(1000428002): return "VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV";
        case static_cast<uint64_t>(1000429008): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV";
        case static_cast<uint64_t>(1000429009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV";
        case static_cast<uint64_t>(1000429010): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV";
        case static_cast<uint64_t>(1000430000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV";
        case static_cast<uint64_t>(1000434000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR";
        case static_cast<uint64_t>(1000437000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT";
        case static_cast<uint64_t>(1000440000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM";
        case static_cast<uint64_t>(1000440001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000440002): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000451000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT";
        case static_cast<uint64_t>(1000451001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000453000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT";
        case static_cast<uint64_t>(1000455000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT";
        case static_cast<uint64_t>(1000455001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000458000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT";
        case static_cast<uint64_t>(1000458001): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT";
        case static_cast<uint64_t>(1000458002): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000458003): return "VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000459000): return "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG";
        case static_cast<uint64_t>(1000459001): return "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG";
        case static_cast<uint64_t>(1000460000): return "VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460001): return "VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460002): return "VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM";
        case static_cast<uint64_t>(1000460003): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM";
        case static_cast<uint64_t>(1000460004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460005): return "VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460006): return "VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM";
        case static_cast<uint64_t>(1000460007): return "VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000460008): return "VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM";
        case static_cast<uint64_t>(1000460009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM";
        case static_cast<uint64_t>(1000460010): return "VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM";
        case static_cast<uint64_t>(1000460011): return "VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460012): return "VK_STRUCTURE_TYPE_TENSOR_COPY_ARM";
        case static_cast<uint64_t>(1000460013): return "VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM";
        case static_cast<uint64_t>(1000460014): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM";
        case static_cast<uint64_t>(1000460015): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460016): return "VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460017): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460018): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM";
        case static_cast<uint64_t>(1000460019): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460020): return "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460021): return "VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM";
        case static_cast<uint64_t>(1000460022): return "VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM";
        case static_cast<uint64_t>(1000460023): return "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM";
        case static_cast<uint64_t>(1000462000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT";
        case static_cast<uint64_t>(1000462001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000462002): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000462003): return "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT";
        case static_cast<uint64_t>(1000342000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000464000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV";
        case static_cast<uint64_t>(1000464001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV";
        case static_cast<uint64_t>(1000464002): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV";
        case static_cast<uint64_t>(1000464003): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000464004): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000464005): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV";
        case static_cast<uint64_t>(1000464010): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV";
        case static_cast<uint64_t>(1000465000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT";
        case static_cast<uint64_t>(1000468000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID";
        case static_cast<uint64_t>(1000468001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000468002): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000476000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD";
        case static_cast<uint64_t>(1000476001): return "VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD";
        case static_cast<uint64_t>(1000476002): return "VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD";
        case static_cast<uint64_t>(1000479000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR";
        case static_cast<uint64_t>(1000479001): return "VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR";
        case static_cast<uint64_t>(1000479002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000480000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR";
        case static_cast<uint64_t>(1000480001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000480002): return "VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR";
        case static_cast<uint64_t>(1000481000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR";
        case static_cast<uint64_t>(1000482000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT";
        case static_cast<uint64_t>(1000482001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000482002): return "VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR";
        case static_cast<uint64_t>(1000483001): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000483002): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR";
        case static_cast<uint64_t>(1000483003): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR";
        case static_cast<uint64_t>(1000483004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000483005): return "VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR";
        case static_cast<uint64_t>(1000483006): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR";
        case static_cast<uint64_t>(1000483007): return "VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000483008): return "VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR";
        case static_cast<uint64_t>(1000483009): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR";
        case static_cast<uint64_t>(1000484000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM";
        case static_cast<uint64_t>(1000484001): return "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000485000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC";
        case static_cast<uint64_t>(1000485001): return "VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC";
        case static_cast<uint64_t>(1000274000): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR";
        case static_cast<uint64_t>(1000274001): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000274002): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR";
        case static_cast<uint64_t>(1000275000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000275001): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR";
        case static_cast<uint64_t>(1000275002): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000275003): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR";
        case static_cast<uint64_t>(1000275004): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000275005): return "VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR";
        case static_cast<uint64_t>(1000488000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000490000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV";
        case static_cast<uint64_t>(1000490001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV";
        case static_cast<uint64_t>(1000491001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491002): return "VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491004): return "VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV";
        case static_cast<uint64_t>(1000492000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV";
        case static_cast<uint64_t>(1000492001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000351000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT";
        case static_cast<uint64_t>(1000351002): return "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000495000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT";
        case static_cast<uint64_t>(1000495001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000496000): return "VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000497000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM";
        case static_cast<uint64_t>(1000497001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000498000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT";
        case static_cast<uint64_t>(1000499000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT";
        case static_cast<uint64_t>(1000505000): return "VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV";
        case static_cast<uint64_t>(1000505001): return "VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV";
        case static_cast<uint64_t>(1000505002): return "VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV";
        case static_cast<uint64_t>(1000505003): return "VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV";
        case static_cast<uint64_t>(1000505004): return "VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV";
        case static_cast<uint64_t>(1000505005): return "VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV";
        case static_cast<uint64_t>(1000505006): return "VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV";
        case static_cast<uint64_t>(1000505007): return "VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000505008): return "VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV";
        case static_cast<uint64_t>(1000506000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR";
        case static_cast<uint64_t>(1000506001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000506002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000507000): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507001): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507002): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM";
        case static_cast<uint64_t>(1000507003): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM";
        case static_cast<uint64_t>(1000507004): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000507005): return "VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM";
        case static_cast<uint64_t>(1000507006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM";
        case static_cast<uint64_t>(1000507007): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507008): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM";
        case static_cast<uint64_t>(1000507009): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM";
        case static_cast<uint64_t>(1000507010): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507011): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000507012): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM";
        case static_cast<uint64_t>(1000507013): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507014): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM";
        case static_cast<uint64_t>(1000507016): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507017): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000507018): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000507019): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM";
        case static_cast<uint64_t>(1000507015): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM";
        case static_cast<uint64_t>(1000510000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000510001): return "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000201000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR";
        case static_cast<uint64_t>(1000511000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000512000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000512001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000512003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000512004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000512005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000513000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000513001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000513002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000513003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000513004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR";
        case static_cast<uint64_t>(1000513005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000513006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000513007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000513008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000513009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000513010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000514000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR";
        case static_cast<uint64_t>(1000514001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000514002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000514003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000515000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000515001): return "VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR";
        case static_cast<uint64_t>(1000516000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV";
        case static_cast<uint64_t>(1000518000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM";
        case static_cast<uint64_t>(1000518001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000518002): return "VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000519000): return "VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000519001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000519002): return "VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM";
        case static_cast<uint64_t>(1000520000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM";
        case static_cast<uint64_t>(1000520001): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000521000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM";
        case static_cast<uint64_t>(1000524000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000527000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR";
        case static_cast<uint64_t>(1000527001): return "VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT";
        case static_cast<uint64_t>(1000529000): return "VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX";
        case static_cast<uint64_t>(1000529001): return "VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX";
        case static_cast<uint64_t>(1000529002): return "VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX";
        case static_cast<uint64_t>(1000529003): return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX";
        case static_cast<uint64_t>(1000529004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX";
        case static_cast<uint64_t>(1000530000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT";
        case static_cast<uint64_t>(1000184000): return "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR";
        case static_cast<uint64_t>(1000545007): return "VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT";
        case static_cast<uint64_t>(1000545008): return "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT";
        case static_cast<uint64_t>(1000546000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV";
        case static_cast<uint64_t>(1000547000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM";
        case static_cast<uint64_t>(1000547001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000547002): return "VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM";
        case static_cast<uint64_t>(1000547003): return "VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM";
        case static_cast<uint64_t>(1000547004): return "VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM";
        case static_cast<uint64_t>(1000551000): return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000551001): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV";
        case static_cast<uint64_t>(1000552000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000552001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000552002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR";
        case static_cast<uint64_t>(1000552003): return "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR";
        case static_cast<uint64_t>(1000552004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR";
        case static_cast<uint64_t>(1000553000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553001): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000553002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR";
        case static_cast<uint64_t>(1000553005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000553009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR";
        case static_cast<uint64_t>(1000553003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553006): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000553007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553008): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000555000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV";
        case static_cast<uint64_t>(1000556000): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000556001): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000556002): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV";
        case static_cast<uint64_t>(1000556003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000558000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR";
        case static_cast<uint64_t>(1000559000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV";
        case static_cast<uint64_t>(1000562000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR";
        case static_cast<uint64_t>(1000562001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000562002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR";
        case static_cast<uint64_t>(1000562003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000562004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000563000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV";
        case static_cast<uint64_t>(1000564000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT";
        case static_cast<uint64_t>(1000567000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT";
        case static_cast<uint64_t>(1000568000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV";
        case static_cast<uint64_t>(1000569000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV";
        case static_cast<uint64_t>(1000569001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000569002): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV";
        case static_cast<uint64_t>(1000569003): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV";
        case static_cast<uint64_t>(1000569004): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV";
        case static_cast<uint64_t>(1000569005): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV";
        case static_cast<uint64_t>(1000569006): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV";
        case static_cast<uint64_t>(1000569007): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000570000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV";
        case static_cast<uint64_t>(1000570001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000570002): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000570003): return "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV";
        case static_cast<uint64_t>(1000570004): return "VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV";
        case static_cast<uint64_t>(1000570005): return "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV";
        case static_cast<uint64_t>(1000572000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT";
        case static_cast<uint64_t>(1000572001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000572002): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT";
        case static_cast<uint64_t>(1000572003): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000572004): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT";
        case static_cast<uint64_t>(1000572006): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000572007): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT";
        case static_cast<uint64_t>(1000572008): return "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT";
        case static_cast<uint64_t>(1000572009): return "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT";
        case static_cast<uint64_t>(1000572010): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT";
        case static_cast<uint64_t>(1000572011): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT";
        case static_cast<uint64_t>(1000572012): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT";
        case static_cast<uint64_t>(1000572013): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT";
        case static_cast<uint64_t>(1000572014): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT";
        case static_cast<uint64_t>(1000574000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR";
        case static_cast<uint64_t>(1000574002): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR";
        case static_cast<uint64_t>(1000575000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA";
        case static_cast<uint64_t>(1000575001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA";
        case static_cast<uint64_t>(1000575002): return "VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA";
        case static_cast<uint64_t>(1000582000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000582001): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000584000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR";
        case static_cast<uint64_t>(1000584001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000584002): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000586000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000586001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000586002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000586003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000587000): return "VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS";
        case static_cast<uint64_t>(1000590000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000590001): return "VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI";
        case static_cast<uint64_t>(1000593000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV";
        case static_cast<uint64_t>(1000593001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000593002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV";
        case static_cast<uint64_t>(1000596000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM";
        case static_cast<uint64_t>(1000602000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT";
        case static_cast<uint64_t>(1000602001): return "VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000602002): return "VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT";
        case static_cast<uint64_t>(1000421000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR";
        case static_cast<uint64_t>(1000608000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000609000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM";
        case static_cast<uint64_t>(1000611000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE";
        case static_cast<uint64_t>(1000611001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE";
        case static_cast<uint64_t>(1000611002): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE";
        case static_cast<uint64_t>(1000286000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000286001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000613000): return "VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV";
        case static_cast<uint64_t>(1000613001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV";
        case static_cast<uint64_t>(1000425000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT";
        case static_cast<uint64_t>(1000425001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000425002): return "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT";
        case static_cast<uint64_t>(1000619003): return "VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT";
        case static_cast<uint64_t>(1000620000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT";
        case static_cast<uint64_t>(1000361000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR";
        case static_cast<uint64_t>(1000637000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC";
        case static_cast<uint64_t>(1000150007): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR";
        case static_cast<uint64_t>(1000150000): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR";
        case static_cast<uint64_t>(1000150002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR";
        case static_cast<uint64_t>(1000150003): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR";
        case static_cast<uint64_t>(1000150004): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR";
        case static_cast<uint64_t>(1000150005): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR";
        case static_cast<uint64_t>(1000150006): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR";
        case static_cast<uint64_t>(1000150009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR";
        case static_cast<uint64_t>(1000150010): return "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR";
        case static_cast<uint64_t>(1000150011): return "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR";
        case static_cast<uint64_t>(1000150012): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR";
        case static_cast<uint64_t>(1000150013): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR";
        case static_cast<uint64_t>(1000150014): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000150017): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150020): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR";
        case static_cast<uint64_t>(1000347000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR";
        case static_cast<uint64_t>(1000347001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000150015): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150016): return "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150018): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000348013): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR";
        case static_cast<uint64_t>(1000328000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT";
        case static_cast<uint64_t>(1000328001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT";
        default: return "VkStructureType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubgroupFeatureFlagBits>(VkSubgroupFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SUBGROUP_FEATURE_BASIC_BIT";
        case static_cast<uint64_t>(2): return "VK_SUBGROUP_FEATURE_VOTE_BIT";
        case static_cast<uint64_t>(4): return "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT";
        case static_cast<uint64_t>(8): return "VK_SUBGROUP_FEATURE_BALLOT_BIT";
        case static_cast<uint64_t>(16): return "VK_SUBGROUP_FEATURE_SHUFFLE_BIT";
        case static_cast<uint64_t>(32): return "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT";
        case static_cast<uint64_t>(64): return "VK_SUBGROUP_FEATURE_CLUSTERED_BIT";
        case static_cast<uint64_t>(128): return "VK_SUBGROUP_FEATURE_QUAD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(512): return "VK_SUBGROUP_FEATURE_ROTATE_BIT";
        case static_cast<uint64_t>(1024): return "VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT";
        case static_cast<uint64_t>(256): return "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV";
        default: return "VkSubgroupFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubmitFlagBits>(VkSubmitFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SUBMIT_PROTECTED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBMIT_FLAG_BITS_MAX_ENUM";
        default: return "VkSubmitFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassContents>(VkSubpassContents type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUBPASS_CONTENTS_INLINE";
        case static_cast<uint64_t>(1): return "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS";
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_CONTENTS_MAX_ENUM";
        case static_cast<uint64_t>(1000451000): return "VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR";
        default: return "VkSubpassContents_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassDescriptionFlagBits>(VkSubpassDescriptionFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM";
        case static_cast<uint64_t>(8): return "VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM";
        case static_cast<uint64_t>(256): return "VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM";
        case static_cast<uint64_t>(16): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT";
        default: return "VkSubpassDescriptionFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassMergeStatusEXT>(VkSubpassMergeStatusEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUBPASS_MERGE_STATUS_MERGED_EXT";
        case static_cast<uint64_t>(1): return "VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT";
        case static_cast<uint64_t>(2): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT";
        case static_cast<uint64_t>(3): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT";
        case static_cast<uint64_t>(4): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT";
        case static_cast<uint64_t>(5): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT";
        case static_cast<uint64_t>(6): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT";
        case static_cast<uint64_t>(7): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT";
        case static_cast<uint64_t>(8): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT";
        case static_cast<uint64_t>(9): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT";
        case static_cast<uint64_t>(10): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT";
        case static_cast<uint64_t>(11): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT";
        case static_cast<uint64_t>(12): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT";
        case static_cast<uint64_t>(13): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_MERGE_STATUS_EXT_MAX_ENUM";
        default: return "VkSubpassMergeStatusEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSurfaceCounterFlagBitsEXT>(VkSurfaceCounterFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SURFACE_COUNTER_VBLANK_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SURFACE_COUNTER_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkSurfaceCounterFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSurfaceTransformFlagBitsKHR>(VkSurfaceTransformFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SURFACE_TRANSFORM_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkSurfaceTransformFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSwapchainCreateFlagBitsKHR>(VkSwapchainCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SWAPCHAIN_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR";
        default: return "VkSwapchainCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSystemAllocationScope>(VkSystemAllocationScope type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND";
        case static_cast<uint64_t>(1): return "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT";
        case static_cast<uint64_t>(2): return "VK_SYSTEM_ALLOCATION_SCOPE_CACHE";
        case static_cast<uint64_t>(3): return "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE";
        case static_cast<uint64_t>(4): return "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE";
        case static_cast<uint64_t>(2147483647): return "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM";
        default: return "VkSystemAllocationScope_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTensorTilingARM>(VkTensorTilingARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TENSOR_TILING_OPTIMAL_ARM";
        case static_cast<uint64_t>(1): return "VK_TENSOR_TILING_LINEAR_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_TENSOR_TILING_ARM_MAX_ENUM";
        default: return "VkTensorTilingARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTessellationDomainOrigin>(VkTessellationDomainOrigin type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT";
        case static_cast<uint64_t>(1): return "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT";
        case static_cast<uint64_t>(2147483647): return "VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM";
        default: return "VkTessellationDomainOrigin_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTileShadingRenderPassFlagBitsQCOM>(VkTileShadingRenderPassFlagBitsQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM";
        case static_cast<uint64_t>(2): return "VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_QCOM_MAX_ENUM";
        default: return "VkTileShadingRenderPassFlagBitsQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTimeDomainKHR>(VkTimeDomainKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TIME_DOMAIN_DEVICE_KHR";
        case static_cast<uint64_t>(1): return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR";
        case static_cast<uint64_t>(2): return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR";
        case static_cast<uint64_t>(3): return "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_TIME_DOMAIN_KHR_MAX_ENUM";
        default: return "VkTimeDomainKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkToolPurposeFlagBits>(VkToolPurposeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_TOOL_PURPOSE_VALIDATION_BIT";
        case static_cast<uint64_t>(2): return "VK_TOOL_PURPOSE_PROFILING_BIT";
        case static_cast<uint64_t>(4): return "VK_TOOL_PURPOSE_TRACING_BIT";
        case static_cast<uint64_t>(8): return "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT";
        case static_cast<uint64_t>(16): return "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT";
        default: return "VkToolPurposeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationCacheHeaderVersionEXT>(VkValidationCacheHeaderVersionEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_CACHE_HEADER_VERSION_EXT_MAX_ENUM";
        default: return "VkValidationCacheHeaderVersionEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationCheckEXT>(VkValidationCheckEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_CHECK_ALL_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_CHECK_SHADERS_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_CHECK_EXT_MAX_ENUM";
        default: return "VkValidationCheckEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationFeatureDisableEXT>(VkValidationFeatureDisableEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT";
        case static_cast<uint64_t>(2): return "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT";
        case static_cast<uint64_t>(3): return "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT";
        case static_cast<uint64_t>(4): return "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT";
        case static_cast<uint64_t>(5): return "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT";
        case static_cast<uint64_t>(6): return "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT";
        case static_cast<uint64_t>(7): return "VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_FEATURE_DISABLE_EXT_MAX_ENUM";
        default: return "VkValidationFeatureDisableEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationFeatureEnableEXT>(VkValidationFeatureEnableEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT";
        case static_cast<uint64_t>(2): return "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT";
        case static_cast<uint64_t>(3): return "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT";
        case static_cast<uint64_t>(4): return "VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_FEATURE_ENABLE_EXT_MAX_ENUM";
        default: return "VkValidationFeatureEnableEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVendorId>(VkVendorId type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(65536): return "VK_VENDOR_ID_KHRONOS";
        case static_cast<uint64_t>(65537): return "VK_VENDOR_ID_VIV";
        case static_cast<uint64_t>(65538): return "VK_VENDOR_ID_VSI";
        case static_cast<uint64_t>(65539): return "VK_VENDOR_ID_KAZAN";
        case static_cast<uint64_t>(65540): return "VK_VENDOR_ID_CODEPLAY";
        case static_cast<uint64_t>(65541): return "VK_VENDOR_ID_MESA";
        case static_cast<uint64_t>(65542): return "VK_VENDOR_ID_POCL";
        case static_cast<uint64_t>(65543): return "VK_VENDOR_ID_MOBILEYE";
        case static_cast<uint64_t>(2147483647): return "VK_VENDOR_ID_MAX_ENUM";
        default: return "VkVendorId_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVertexInputRate>(VkVertexInputRate type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VERTEX_INPUT_RATE_VERTEX";
        case static_cast<uint64_t>(1): return "VK_VERTEX_INPUT_RATE_INSTANCE";
        case static_cast<uint64_t>(2147483647): return "VK_VERTEX_INPUT_RATE_MAX_ENUM";
        default: return "VkVertexInputRate_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCapabilityFlagBitsKHR>(VkVideoCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoChromaSubsamplingFlagBitsKHR>(VkVideoChromaSubsamplingFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoChromaSubsamplingFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCodecOperationFlagBitsKHR>(VkVideoCodecOperationFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_CODEC_OPERATION_NONE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CODEC_OPERATION_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR";
        default: return "VkVideoCodecOperationFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCodingControlFlagBitsKHR>(VkVideoCodingControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CODING_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR";
        default: return "VkVideoCodingControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoComponentBitDepthFlagBitsKHR>(VkVideoComponentBitDepthFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoComponentBitDepthFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeCapabilityFlagBitsKHR>(VkVideoDecodeCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeH264PictureLayoutFlagBitsKHR>(VkVideoDecodeH264PictureLayoutFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_H2_64_PICTURE_LAYOUT_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeH264PictureLayoutFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeUsageFlagBitsKHR>(VkVideoDecodeUsageFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_DECODE_USAGE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_USAGE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeUsageFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1CapabilityFlagBitsKHR>(VkVideoEncodeAV1CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR";
        default: return "VkVideoEncodeAV1CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1PredictionModeKHR>(VkVideoEncodeAV1PredictionModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR";
        case static_cast<uint64_t>(3): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1PredictionModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1RateControlFlagBitsKHR>(VkVideoEncodeAV1RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1RateControlGroupKHR>(VkVideoEncodeAV1RateControlGroupKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1RateControlGroupKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1StdFlagBitsKHR>(VkVideoEncodeAV1StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1SuperblockSizeFlagBitsKHR>(VkVideoEncodeAV1SuperblockSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeCapabilityFlagBitsKHR>(VkVideoEncodeCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR";
        default: return "VkVideoEncodeCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeContentFlagBitsKHR>(VkVideoEncodeContentFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeContentFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeFeedbackFlagBitsKHR>(VkVideoEncodeFeedbackFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeFeedbackFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeFlagBitsKHR>(VkVideoEncodeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR";
        default: return "VkVideoEncodeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264CapabilityFlagBitsKHR>(VkVideoEncodeH264CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR";
        default: return "VkVideoEncodeH264CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264RateControlFlagBitsKHR>(VkVideoEncodeH264RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH264RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264StdFlagBitsKHR>(VkVideoEncodeH264StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH264StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265CapabilityFlagBitsKHR>(VkVideoEncodeH265CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR";
        default: return "VkVideoEncodeH265CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265CtbSizeFlagBitsKHR>(VkVideoEncodeH265CtbSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_CTB_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265CtbSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265RateControlFlagBitsKHR>(VkVideoEncodeH265RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265StdFlagBitsKHR>(VkVideoEncodeH265StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265TransformBlockSizeFlagBitsKHR>(VkVideoEncodeH265TransformBlockSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_TRANSFORM_BLOCK_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeIntraRefreshModeFlagBitsKHR>(VkVideoEncodeIntraRefreshModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeIntraRefreshModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeRateControlModeFlagBitsKHR>(VkVideoEncodeRateControlModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeRateControlModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeTuningModeKHR>(VkVideoEncodeTuningModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR";
        case static_cast<uint64_t>(3): return "VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_TUNING_MODE_KHR_MAX_ENUM";
        default: return "VkVideoEncodeTuningModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeUsageFlagBitsKHR>(VkVideoEncodeUsageFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_USAGE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeUsageFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoSessionCreateFlagBitsKHR>(VkVideoSessionCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_SESSION_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR";
        default: return "VkVideoSessionCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoSessionParametersCreateFlagBitsKHR>(VkVideoSessionParametersCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR";
        default: return "VkVideoSessionParametersCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkViewportCoordinateSwizzleNV>(VkViewportCoordinateSwizzleNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV";
        case static_cast<uint64_t>(1): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV";
        case static_cast<uint64_t>(2): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV";
        case static_cast<uint64_t>(3): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV";
        case static_cast<uint64_t>(4): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV";
        case static_cast<uint64_t>(5): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV";
        case static_cast<uint64_t>(6): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV";
        case static_cast<uint64_t>(7): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV";
        case static_cast<uint64_t>(2147483647): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NV_MAX_ENUM";
        default: return "VkViewportCoordinateSwizzleNV_UNKNOWN";
      }
    }
  }
  template <typename Type>
  constexpr VkStructureType ResolveSType();

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureBuildGeometryInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureBuildGeometryInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureBuildSizesInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureBuildSizesInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureDeviceAddressInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureDeviceAddressInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryAabbsDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryAabbsDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryInstancesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryInstancesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryLinearSweptSpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryLinearSweptSpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryMotionTrianglesDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryMotionTrianglesDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometrySpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometrySpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryTrianglesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryTrianglesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureMotionInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureMotionInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureTrianglesDisplacementMicromapNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureTrianglesDisplacementMicromapNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureTrianglesOpacityMicromapEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureTrianglesOpacityMicromapEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureVersionInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureVersionInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAcquireNextImageInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAcquireNextImageInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAcquireProfilingLockInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAcquireProfilingLockInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAmigoProfilingSubmitInfoSEC>() { return VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkAmigoProfilingSubmitInfoSEC>() { return VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatProperties2ANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatProperties2ANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferUsageANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferUsageANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkAntiLagDataAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAntiLagDataAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkAntiLagPresentationInfoAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAntiLagPresentationInfoAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkApplicationInfo>() { return VK_STRUCTURE_TYPE_APPLICATION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkApplicationInfo>() { return VK_STRUCTURE_TYPE_APPLICATION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentDescription2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentDescription2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentDescriptionStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentDescriptionStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentFeedbackLoopInfoEXT>() { return VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentFeedbackLoopInfoEXT>() { return VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentReference2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentReference2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentReferenceStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentReferenceStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentSampleCountInfoAMD>() { return VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentSampleCountInfoAMD>() { return VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkBindAccelerationStructureMemoryInfoNV>() { return VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkBindAccelerationStructureMemoryInfoNV>() { return VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkBindBufferMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindBufferMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindBufferMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindBufferMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindDataGraphPipelineSessionMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDataGraphPipelineSessionMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkBindDescriptorBufferEmbeddedSamplersInfoEXT>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkBindDescriptorSetsInfo>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDescriptorSetsInfo>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemorySwapchainInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemorySwapchainInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkBindImagePlaneMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImagePlaneMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindMemoryStatus>() { return VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS; }
  template <> constexpr VkStructureType ResolveSType<const VkBindMemoryStatus>() { return VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS; }

  template <> constexpr VkStructureType ResolveSType<VkBindSparseInfo>() { return VK_STRUCTURE_TYPE_BIND_SPARSE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindSparseInfo>() { return VK_STRUCTURE_TYPE_BIND_SPARSE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindTensorMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkBindTensorMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkBindVideoSessionMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkBindVideoSessionMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkBlitImageCubicWeightsInfoQCOM>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkBlitImageCubicWeightsInfoQCOM>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkBlitImageInfo2>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBlitImageInfo2>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionBufferCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionBufferCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionImageCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionImageCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionPropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionPropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkBufferCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferDeviceAddressCreateInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferDeviceAddressCreateInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkBufferDeviceAddressInfo>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferDeviceAddressInfo>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferImageCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferImageCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryBarrier>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryBarrier>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryBarrier2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryBarrier2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferOpaqueCaptureAddressCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferOpaqueCaptureAddressCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferUsageFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferUsageFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferViewCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferViewCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBuildPartitionedAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkBuildPartitionedAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCalibratedTimestampInfoKHR>() { return VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCalibratedTimestampInfoKHR>() { return VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCheckpointData2NV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCheckpointData2NV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCheckpointDataNV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCheckpointDataNV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureClustersBottomLevelInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureClustersBottomLevelInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureCommandsInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureCommandsInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureInputInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureInputInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureMoveObjectsInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureMoveObjectsInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureTriangleClusterInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureTriangleClusterInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferAllocateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferAllocateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceConditionalRenderingInfoEXT>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceConditionalRenderingInfoEXT>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceRenderingInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceRenderingInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceViewportScissorInfoNV>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceViewportScissorInfoNV>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferSubmitInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferSubmitInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandPoolCreateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandPoolCreateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkComputePipelineCreateInfo>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkComputePipelineCreateInfo>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkComputePipelineIndirectBufferInfoNV>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkComputePipelineIndirectBufferInfoNV>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkConditionalRenderingBeginInfoEXT>() { return VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkConditionalRenderingBeginInfoEXT>() { return VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkConvertCooperativeVectorMatrixInfoNV>() { return VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkConvertCooperativeVectorMatrixInfoNV>() { return VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixFlexibleDimensionsPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixFlexibleDimensionsPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCopyAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyAccelerationStructureToMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyAccelerationStructureToMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyBufferToImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyBufferToImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyCommandTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyCommandTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkCopyDescriptorSet>() { return VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyDescriptorSet>() { return VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToMemoryInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToMemoryInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMicromapToMemoryInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMicromapToMemoryInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyTensorInfoARM>() { return VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyTensorInfoARM>() { return VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaFunctionCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaFunctionCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaLaunchInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaLaunchInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaModuleCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaModuleCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkD3D12FenceSubmitInfoKHR>() { return VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkD3D12FenceSubmitInfoKHR>() { return VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineCompilerControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineCompilerControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineConstantARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineConstantARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineDispatchInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineDispatchInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineIdentifierCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineIdentifierCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelinePropertyQueryResultARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelinePropertyQueryResultARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineResourceInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineResourceInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionBindPointRequirementARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionBindPointRequirementARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionBindPointRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionBindPointRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineShaderModuleCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineShaderModuleCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphProcessingEngineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphProcessingEngineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerMarkerInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerMarkerInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugReportCallbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugReportCallbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsLabelEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsLabelEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsMessengerCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsMessengerCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsMessengerCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsMessengerCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationBufferCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationBufferCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDependencyInfo>() { return VK_STRUCTURE_TYPE_DEPENDENCY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDependencyInfo>() { return VK_STRUCTURE_TYPE_DEPENDENCY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDepthBiasInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDepthBiasInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDepthBiasRepresentationInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDepthBiasRepresentationInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorAddressInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorAddressInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorBufferBindingInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorBufferBindingInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorGetInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorGetInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorGetTensorInfoARM>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorGetTensorInfoARM>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorPoolCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorPoolCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorPoolInlineUniformBlockCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorPoolInlineUniformBlockCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetBindingReferenceVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetBindingReferenceVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutBindingFlagsCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutBindingFlagsCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutHostMappingInfoVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutHostMappingInfoVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetVariableDescriptorCountAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetVariableDescriptorCountAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetVariableDescriptorCountLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetVariableDescriptorCountLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorUpdateTemplateCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorUpdateTemplateCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceAddressBindingCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceAddressBindingCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceBufferMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceBufferMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceDeviceMemoryReportCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceDeviceMemoryReportCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceDiagnosticsConfigCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceDiagnosticsConfigCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceEventInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceEventInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceFaultCountsEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceFaultCountsEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceFaultInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceFaultInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupBindSparseInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupBindSparseInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupPresentCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupPresentCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupSubmitInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupSubmitInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceImageMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceImageMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceImageSubresourceInfo>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceImageSubresourceInfo>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryOpaqueCaptureAddressInfo>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryOpaqueCaptureAddressInfo>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryOverallocationCreateInfoAMD>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryOverallocationCreateInfoAMD>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryReportCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryReportCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDevicePipelineBinaryInternalCacheControlKHR>() { return VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDevicePipelineBinaryInternalCacheControlKHR>() { return VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDevicePrivateDataCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDevicePrivateDataCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueGlobalPriorityCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueGlobalPriorityCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueInfo2>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueInfo2>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueShaderCoreControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueShaderCoreControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceTensorMemoryRequirementsARM>() { return VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceTensorMemoryRequirementsARM>() { return VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDirectDriverLoadingInfoLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectDriverLoadingInfoLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG; }

  template <> constexpr VkStructureType ResolveSType<VkDirectDriverLoadingListLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectDriverLoadingListLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG; }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <> constexpr VkStructureType ResolveSType<VkDirectFBSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectFBSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkDispatchTileInfoQCOM>() { return VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkDispatchTileInfoQCOM>() { return VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayEventInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayEventInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeStereoPropertiesNV>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeStereoPropertiesNV>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayNativeHdrSurfaceCapabilitiesAMD>() { return VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayNativeHdrSurfaceCapabilitiesAMD>() { return VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneCapabilities2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneCapabilities2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneInfo2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneInfo2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPowerInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPowerInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplaySurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplaySurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplaySurfaceStereoCreateInfoNV>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplaySurfaceStereoCreateInfoNV>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDrmFormatModifierPropertiesList2EXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDrmFormatModifierPropertiesList2EXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDrmFormatModifierPropertiesListEXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDrmFormatModifierPropertiesListEXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkEventCreateInfo>() { return VK_STRUCTURE_TYPE_EVENT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkEventCreateInfo>() { return VK_STRUCTURE_TYPE_EVENT_CREATE_INFO; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkExecutionGraphPipelineCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkExecutionGraphPipelineCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkExecutionGraphPipelineScratchSizeAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkExecutionGraphPipelineScratchSizeAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportFenceCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportFenceCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExportMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalCommandQueueInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalCommandQueueInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalDeviceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalDeviceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalObjectCreateInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalObjectCreateInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalObjectsInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalObjectsInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExternalBufferProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalBufferProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueDataParamsNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueDataParamsNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueDeviceCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueDeviceCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalFenceProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFenceProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkExternalFormatANDROID>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFormatANDROID>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkExternalFormatQNX>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFormatQNX>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExternalImageFormatProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalImageFormatProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryAcquireUnmodifiedEXT>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryAcquireUnmodifiedEXT>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryBufferCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryBufferCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryImageCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryImageCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkExternalSemaphoreProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalSemaphoreProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkFenceCreateInfo>() { return VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceCreateInfo>() { return VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFenceGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkFenceGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkFilterCubicImageViewImageFormatPropertiesEXT>() { return VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkFilterCubicImageViewImageFormatPropertiesEXT>() { return VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkFormatProperties2>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkFormatProperties2>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkFormatProperties3>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3; }
  template <> constexpr VkStructureType ResolveSType<const VkFormatProperties3>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3; }

  template <> constexpr VkStructureType ResolveSType<VkFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkFrameBoundaryEXT>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkFrameBoundaryEXT>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkFrameBoundaryTensorsARM>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkFrameBoundaryTensorsARM>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferAttachmentImageInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferAttachmentImageInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferAttachmentsCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferAttachmentsCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferMixedSamplesCombinationNV>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferMixedSamplesCombinationNV>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsMemoryRequirementsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsMemoryRequirementsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsShaderInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsShaderInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryAABBNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryAABBNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryTrianglesNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryTrianglesNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineCreateInfo>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineCreateInfo>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineLibraryCreateInfoEXT>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineLibraryCreateInfoEXT>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineShaderGroupsCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineShaderGroupsCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkHdrMetadataEXT>() { return VK_STRUCTURE_TYPE_HDR_METADATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkHdrMetadataEXT>() { return VK_STRUCTURE_TYPE_HDR_METADATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkHdrVividDynamicMetadataHUAWEI>() { return VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkHdrVividDynamicMetadataHUAWEI>() { return VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkHeadlessSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkHeadlessSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkHostImageCopyDevicePerformanceQuery>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY; }
  template <> constexpr VkStructureType ResolveSType<const VkHostImageCopyDevicePerformanceQuery>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY; }

  template <> constexpr VkStructureType ResolveSType<VkHostImageLayoutTransitionInfo>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkHostImageLayoutTransitionInfo>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO; }

#ifdef VK_USE_PLATFORM_IOS_MVK
  template <> constexpr VkStructureType ResolveSType<VkIOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK; }
  template <> constexpr VkStructureType ResolveSType<const VkIOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageAlignmentControlCreateInfoMESA>() { return VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageAlignmentControlCreateInfoMESA>() { return VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkImageBlit2>() { return VK_STRUCTURE_TYPE_IMAGE_BLIT_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageBlit2>() { return VK_STRUCTURE_TYPE_IMAGE_BLIT_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageCompressionControlEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCompressionControlEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageCompressionPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCompressionPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImageConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageCopy2>() { return VK_STRUCTURE_TYPE_IMAGE_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCopy2>() { return VK_STRUCTURE_TYPE_IMAGE_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierExplicitCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierExplicitCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierListCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierListCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImageFormatConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageFormatListCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatListCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageFormatProperties2>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatProperties2>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryBarrier>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryBarrier>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryBarrier2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryBarrier2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImagePipeSurfaceCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImagePipeSurfaceCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImagePlaneMemoryRequirementsInfo>() { return VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImagePlaneMemoryRequirementsInfo>() { return VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageResolve2>() { return VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageResolve2>() { return VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageSparseMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSparseMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageStencilUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageStencilUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageSubresource2>() { return VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSubresource2>() { return VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkImageToMemoryCopy>() { return VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY; }
  template <> constexpr VkStructureType ResolveSType<const VkImageToMemoryCopy>() { return VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewASTCDecodeModeEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewASTCDecodeModeEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewMinLodCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewMinLodCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewSampleWeightCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewSampleWeightCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewSlicedCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewSlicedCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkImportAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportFenceFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportFenceFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryBufferCollectionFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryBufferCollectionFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportMemoryFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkImportMemoryHostPointerInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryHostPointerInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkImportScreenBufferInfoQNX>() { return VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkImportScreenBufferInfoQNX>() { return VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutCreateInfoNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutCreateInfoNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutTokenEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutTokenEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutTokenNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutTokenNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetShaderInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetShaderInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetShaderLayoutInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetShaderLayoutInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkInitializePerformanceApiInfoINTEL>() { return VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkInitializePerformanceApiInfoINTEL>() { return VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySleepInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySleepInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySleepModeInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySleepModeInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySubmissionPresentIdNV>() { return VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySubmissionPresentIdNV>() { return VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySurfaceCapabilitiesNV>() { return VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySurfaceCapabilitiesNV>() { return VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencyTimingsFrameReportNV>() { return VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencyTimingsFrameReportNV>() { return VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLayerSettingsCreateInfoEXT>() { return VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerSettingsCreateInfoEXT>() { return VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT; }

#ifdef VK_USE_PLATFORM_MACOS_MVK
  template <> constexpr VkStructureType ResolveSType<VkMacOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK; }
  template <> constexpr VkStructureType ResolveSType<const VkMacOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMappedMemoryRange>() { return VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE; }
  template <> constexpr VkStructureType ResolveSType<const VkMappedMemoryRange>() { return VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryAllocateFlagsInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryAllocateFlagsInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrier>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrier>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrier2>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrier2>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrierAccessFlags3KHR>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrierAccessFlags3KHR>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedAllocateInfoTensorARM>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedAllocateInfoTensorARM>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedRequirements>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedRequirements>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryFdPropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryFdPropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryGetRemoteAddressInfoNV>() { return VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetRemoteAddressInfoNV>() { return VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryHostPointerPropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryHostPointerPropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryMapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryMapPlacedInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMapPlacedInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMemoryMetalHandlePropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMetalHandlePropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryOpaqueCaptureAddressAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryOpaqueCaptureAddressAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryPriorityAllocateInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryPriorityAllocateInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryRequirements2>() { return VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryRequirements2>() { return VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryToImageCopy>() { return VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryToImageCopy>() { return VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryUnmapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryUnmapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryWin32HandlePropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryWin32HandlePropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkMemoryZirconHandlePropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryZirconHandlePropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMetalSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMetalSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMicromapBuildInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapBuildInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapBuildSizesInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapBuildSizesInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapVersionInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapVersionInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultisamplePropertiesEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMultisamplePropertiesEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultisampledRenderToSingleSampledInfoEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMultisampledRenderToSingleSampledInfoEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkMutableDescriptorTypeCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMutableDescriptorTypeCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT; }

#ifdef VK_USE_PLATFORM_OHOS
  template <> constexpr VkStructureType ResolveSType<VkOHSurfaceCreateInfoOHOS>() { return VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS; }
  template <> constexpr VkStructureType ResolveSType<const VkOHSurfaceCreateInfoOHOS>() { return VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkOpaqueCaptureDescriptorDataCreateInfoEXT>() { return VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkOpaqueCaptureDescriptorDataCreateInfoEXT>() { return VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowExecuteInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowExecuteInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowImageFormatInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowImageFormatInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowImageFormatPropertiesNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowImageFormatPropertiesNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowSessionCreateInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowSessionCreateInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowSessionCreatePrivateDataInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowSessionCreatePrivateDataInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOutOfBandQueueTypeInfoNV>() { return VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOutOfBandQueueTypeInfoNV>() { return VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPartitionedAccelerationStructureFlagsNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPartitionedAccelerationStructureFlagsNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPartitionedAccelerationStructureInstancesInputNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPartitionedAccelerationStructureInstancesInputNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPerTileBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPerTileBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPerTileEndInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPerTileEndInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceConfigurationAcquireInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceConfigurationAcquireInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceCounterDescriptionKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceCounterDescriptionKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceCounterKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceCounterKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceOverrideInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceOverrideInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceQuerySubmitInfoKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceQuerySubmitInfoKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceStreamMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceStreamMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice16BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice16BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice4444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice4444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice8BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice8BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceASTCDecodeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceASTCDecodeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAccelerationStructureFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAccelerationStructureFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAccelerationStructurePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAccelerationStructurePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAddressBindingReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAddressBindingReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAmigoProfilingFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAmigoProfilingFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAntiLagFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAntiLagFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBufferDeviceAddressFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBufferDeviceAddressFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCoherentMemoryFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCoherentMemoryFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceColorWriteEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceColorWriteEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceConditionalRenderingFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceConditionalRenderingFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrix2FeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrix2FeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrix2PropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrix2PropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeVectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeVectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCornerSampledImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCornerSampledImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCoverageReductionModeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCoverageReductionModeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCubicClampFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCubicClampFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCubicWeightsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCubicWeightsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCudaKernelLaunchFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCudaKernelLaunchFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCudaKernelLaunchPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCudaKernelLaunchPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCustomBorderColorFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCustomBorderColorFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCustomBorderColorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCustomBorderColorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDataGraphFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDataGraphFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthBiasControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthBiasControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClampControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClampControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClipControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClipControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClipEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClipEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthStencilResolveProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthStencilResolveProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorIndexingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorIndexingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorIndexingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorIndexingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDiscardRectanglePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDiscardRectanglePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDisplacementMicromapFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDisplacementMicromapFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDisplacementMicromapPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDisplacementMicromapPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDriverProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDriverProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDrmPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDrmPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingLocalReadFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExclusiveScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExclusiveScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalBufferInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalBufferInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalComputeQueuePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalComputeQueuePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFenceInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFenceInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalImageFormatInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalImageFormatInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV; }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalSemaphoreInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalSemaphoreInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalTensorInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalTensorInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFaultFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFaultFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFeatures2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFeatures2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFloatControlsProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFloatControlsProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFormatPackFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFormatPackFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFrameBoundaryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFrameBoundaryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGlobalPriorityQueryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGlobalPriorityQueryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHdrVividFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHdrVividFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostImageCopyFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostImageCopyFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostImageCopyProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostImageCopyProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostQueryResetFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostQueryResetFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceIDProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceIDProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageAlignmentControlFeaturesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageAlignmentControlFeaturesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageAlignmentControlPropertiesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageAlignmentControlPropertiesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageCompressionControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageCompressionControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessing2FeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessing2FeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessing2PropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessing2PropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageViewImageFormatInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageViewImageFormatInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageViewMinLodFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageViewMinLodFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImagelessFramebufferFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImagelessFramebufferFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceIndexTypeUint8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceIndexTypeUint8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInlineUniformBlockFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInlineUniformBlockFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInlineUniformBlockProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInlineUniformBlockProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiPropertiesListKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiPropertiesListKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredDriverPropertiesMSFT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredDriverPropertiesMSFT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyDitheringFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyDitheringFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLineRasterizationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLineRasterizationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLineRasterizationProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLineRasterizationProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLinearColorAttachmentFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance3Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance3Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance4Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance4Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance4Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance4Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance5Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance5Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance5Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance5Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance6Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance6Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance6Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance6Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance7FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance7FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance7PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance7PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance8FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance8FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance9PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance9PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryBudgetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryBudgetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryDecompressionFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryDecompressionFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryDecompressionPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryDecompressionPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryPriorityFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryPriorityFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiDrawFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiDrawFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiDrawPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiDrawPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNestedCommandBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNestedCommandBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNestedCommandBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpacityMicromapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpacityMicromapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpacityMicromapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpacityMicromapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpticalFlowFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpticalFlowFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpticalFlowPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpticalFlowPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePCIBusInfoPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePCIBusInfoPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerStageDescriptorSetFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerformanceQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerformanceQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerformanceQueryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerformanceQueryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineBinaryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineBinaryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineBinaryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineBinaryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineCreationCacheControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineCreationCacheControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelinePropertiesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelinePropertiesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineProtectedAccessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineProtectedAccessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineRobustnessProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineRobustnessProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePointClippingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePointClippingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePortabilitySubsetFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePortabilitySubsetFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePortabilitySubsetPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePortabilitySubsetPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentBarrierFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentBarrierFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentId2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentId2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentIdFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentIdFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentMeteringFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentMeteringFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentWait2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentWait2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentWaitFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentWaitFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrivateDataFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrivateDataFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProtectedMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProtectedMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProtectedMemoryProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProtectedMemoryProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProvokingVertexFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProvokingVertexFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProvokingVertexPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProvokingVertexPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePushDescriptorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePushDescriptorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRawAccessChainsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRawAccessChainsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingValidationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingValidationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRenderPassStripedFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRenderPassStripedFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRenderPassStripedPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRenderPassStripedPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRobustness2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRobustness2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRobustness2PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRobustness2PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSampleLocationsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSampleLocationsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSamplerFilterMinmaxProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSamplerFilterMinmaxProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSamplerYcbcrConversionFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSamplerYcbcrConversionFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceScalarBlockLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceScalarBlockLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSchedulingControlsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSchedulingControlsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSchedulingControlsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSchedulingControlsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicInt64Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicInt64Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderBfloat16FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderBfloat16FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderClockFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderClockFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreProperties2AMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreProperties2AMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCorePropertiesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCorePropertiesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCorePropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCorePropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderDrawParametersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderDrawParametersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEnqueueFeaturesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEnqueueFeaturesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEnqueuePropertiesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEnqueuePropertiesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderExpectAssumeFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderExpectAssumeFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloat16Int8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloat16Int8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloat8FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloat8FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloatControls2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloatControls2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderImageFootprintFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderImageFootprintFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerDotProductFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerDotProductFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerDotProductProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerDotProductProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderObjectFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderObjectFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderObjectPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderObjectPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderQuadControlFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderQuadControlFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupRotateFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupRotateFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTerminateInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTerminateInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTileImageFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTileImageFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTileImagePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTileImagePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShadingRateImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShadingRateImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShadingRateImagePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShadingRateImagePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSparseImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSparseImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupSizeControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupSizeControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupSizeControlProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupSizeControlProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSurfaceInfo2KHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSurfaceInfo2KHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSynchronization2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSynchronization2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTexelBufferAlignmentProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTexelBufferAlignmentProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTextureCompressionASTCHDRFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTilePropertiesFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTilePropertiesFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileShadingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileShadingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileShadingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileShadingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTimelineSemaphoreFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTimelineSemaphoreFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTimelineSemaphoreProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTimelineSemaphoreProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceToolProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceToolProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTransformFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTransformFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTransformFeedbackPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTransformFeedbackPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVariablePointersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVariablePointersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoFormatInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoFormatInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoMaintenance2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoMaintenance2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan11Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan11Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan11Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan11Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan12Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan12Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan12Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan12Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan13Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan13Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan13Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan13Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan14Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan14Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan14Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan14Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkanMemoryModelFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkanMemoryModelFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryDataInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryDataInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryHandlesInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryHandlesInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryKeyKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryKeyKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCacheCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCacheCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorBlendAdvancedStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorBlendAdvancedStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorBlendStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorBlendStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorWriteCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorWriteCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCompilerControlCreateInfoAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCompilerControlCreateInfoAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageModulationStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageModulationStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageReductionStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageReductionStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageToColorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageToColorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreateFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreateFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreationFeedbackCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreationFeedbackCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDepthStencilStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDepthStencilStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDiscardRectangleStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDiscardRectangleStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDynamicStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDynamicStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableInternalRepresentationKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableInternalRepresentationKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutablePropertiesKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutablePropertiesKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableStatisticKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableStatisticKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentShadingRateStateCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentShadingRateStateCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineIndirectDeviceAddressInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineIndirectDeviceAddressInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineInputAssemblyStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineInputAssemblyStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineLibraryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineLibraryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineMultisampleStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineMultisampleStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelinePropertiesIdentifierEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelinePropertiesIdentifierEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationConservativeStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationConservativeStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationDepthClipStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationDepthClipStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationLineStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationLineStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateRasterizationOrderAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateRasterizationOrderAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateStreamCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateStreamCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRenderingCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRenderingCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRobustnessCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRobustnessCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineSampleLocationsStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineSampleLocationsStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageModuleIdentifierCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageNodeCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageNodeCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineTessellationDomainOriginStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineTessellationDomainOriginStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineTessellationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineTessellationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineVertexInputDivisorStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineVertexInputDivisorStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineVertexInputStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineVertexInputStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportDepthClampControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportDepthClampControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportDepthClipControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportDepthClipControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportExclusiveScissorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportExclusiveScissorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportShadingRateImageStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportShadingRateImageStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportSwizzleStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportSwizzleStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportWScalingStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportWScalingStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV; }

#ifdef VK_USE_PLATFORM_GGP
  template <> constexpr VkStructureType ResolveSType<VkPresentFrameTokenGGP>() { return VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentFrameTokenGGP>() { return VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPresentId2KHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentId2KHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentIdKHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentIdKHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentInfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentInfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentRegionsKHR>() { return VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentRegionsKHR>() { return VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentTimesInfoGOOGLE>() { return VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentTimesInfoGOOGLE>() { return VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE; }

  template <> constexpr VkStructureType ResolveSType<VkPresentWait2InfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentWait2InfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPrivateDataSlotCreateInfo>() { return VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPrivateDataSlotCreateInfo>() { return VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkProtectedSubmitInfo>() { return VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkProtectedSubmitInfo>() { return VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushConstantsInfo>() { return VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushConstantsInfo>() { return VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushDescriptorSetInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushDescriptorSetInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushDescriptorSetWithTemplateInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushDescriptorSetWithTemplateInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkQueryLowLatencySupportNV>() { return VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryLowLatencySupportNV>() { return VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolCreateInfo>() { return VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolCreateInfo>() { return VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolPerformanceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolPerformanceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolPerformanceQueryCreateInfoINTEL>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolPerformanceQueryCreateInfoINTEL>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyCheckpointProperties2NV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyCheckpointProperties2NV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyCheckpointPropertiesNV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyCheckpointPropertiesNV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyDataGraphProcessingEnginePropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyDataGraphProcessingEnginePropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyDataGraphPropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyDataGraphPropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyGlobalPriorityProperties>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyGlobalPriorityProperties>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyOwnershipTransferPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyOwnershipTransferPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyProperties2>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyProperties2>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyQueryResultStatusPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyQueryResultStatusPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyVideoPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyVideoPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineInterfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineInterfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingShaderGroupCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingShaderGroupCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkReleaseCapturedPipelineDataInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkReleaseCapturedPipelineDataInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkReleaseSwapchainImagesInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkReleaseSwapchainImagesInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassAttachmentBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassAttachmentBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreateInfo2>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreateInfo2>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreationControlEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreationControlEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreationFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreationFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassFragmentDensityMapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassFragmentDensityMapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassFragmentDensityMapOffsetEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassFragmentDensityMapOffsetEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassInputAttachmentAspectCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassInputAttachmentAspectCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassMultiviewCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassMultiviewCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassSampleLocationsBeginInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassSampleLocationsBeginInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeBeginInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeBeginInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeSubmitInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeSubmitInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassSubpassFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassSubpassFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassTileShadingCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassTileShadingCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassTransformBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassTransformBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAreaInfo>() { return VK_STRUCTURE_TYPE_RENDERING_AREA_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAreaInfo>() { return VK_STRUCTURE_TYPE_RENDERING_AREA_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAttachmentInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAttachmentInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAttachmentLocationInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAttachmentLocationInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingFragmentDensityMapAttachmentInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingFragmentDensityMapAttachmentInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingInputAttachmentIndexInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingInputAttachmentIndexInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkResolveImageInfo2>() { return VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkResolveImageInfo2>() { return VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkSampleLocationsInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSampleLocationsInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerBlockMatchWindowCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerBlockMatchWindowCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerBorderColorComponentMappingCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerBorderColorComponentMappingCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCubicWeightsCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCubicWeightsCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCustomBorderColorCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCustomBorderColorCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerReductionModeCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerReductionModeCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionImageFormatProperties>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionImageFormatProperties>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM; }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenBufferFormatPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenBufferFormatPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenBufferPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenBufferPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenSurfaceCreateInfoQNX>() { return VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenSurfaceCreateInfoQNX>() { return VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreSignalInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreSignalInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreTypeCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreTypeCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreWaitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreWaitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSetDescriptorBufferOffsetsInfoEXT>() { return VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSetDescriptorBufferOffsetsInfoEXT>() { return VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkSetPresentConfigNV>() { return VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSetPresentConfigNV>() { return VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkShaderCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleCreateInfo>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleCreateInfo>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleIdentifierEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleIdentifierEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSharedPresentSurfaceCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSharedPresentSurfaceCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSparseImageFormatProperties2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSparseImageFormatProperties2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkSparseImageMemoryRequirements2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSparseImageMemoryRequirements2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2; }

#ifdef VK_USE_PLATFORM_GGP
  template <> constexpr VkStructureType ResolveSType<VkStreamDescriptorSurfaceCreateInfoGGP>() { return VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP; }
  template <> constexpr VkStructureType ResolveSType<const VkStreamDescriptorSurfaceCreateInfoGGP>() { return VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSubmitInfo>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubmitInfo>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubmitInfo2>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubmitInfo2>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassBeginInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassBeginInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDependency2>() { return VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDependency2>() { return VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDescription2>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDescription2>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDescriptionDepthStencilResolve>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDescriptionDepthStencilResolve>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassEndInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_END_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassEndInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_END_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassResolvePerformanceQueryEXT>() { return VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassResolvePerformanceQueryEXT>() { return VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassShadingPipelineCreateInfoHUAWEI>() { return VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassShadingPipelineCreateInfoHUAWEI>() { return VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkSubresourceHostMemcpySize>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE; }
  template <> constexpr VkStructureType ResolveSType<const VkSubresourceHostMemcpySize>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE; }

  template <> constexpr VkStructureType ResolveSType<VkSubresourceLayout2>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubresourceLayout2>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilities2EXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilities2EXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilities2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilities2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesFullScreenExclusiveEXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesFullScreenExclusiveEXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentBarrierNV>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentBarrierNV>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentId2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentId2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentWait2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentWait2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceFormat2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFormat2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceFullScreenExclusiveInfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFullScreenExclusiveInfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceFullScreenExclusiveWin32InfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFullScreenExclusiveWin32InfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentModeCompatibilityKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentModeCompatibilityKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentModeKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentModeKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentScalingCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentScalingCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceProtectedCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceProtectedCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainCounterCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainCounterCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainDisplayNativeHdrCreateInfoAMD>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainDisplayNativeHdrCreateInfoAMD>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainLatencyCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainLatencyCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentBarrierCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentBarrierCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentFenceInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentFenceInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentModeInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentModeInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentModesCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentModesCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentScalingCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentScalingCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkSysmemColorSpaceFUCHSIA>() { return VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkSysmemColorSpaceFUCHSIA>() { return VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkTensorCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorCopyARM>() { return VK_STRUCTURE_TYPE_TENSOR_COPY_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCopyARM>() { return VK_STRUCTURE_TYPE_TENSOR_COPY_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorDependencyInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorDependencyInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorDescriptionARM>() { return VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorDescriptionARM>() { return VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorFormatPropertiesARM>() { return VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorFormatPropertiesARM>() { return VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorMemoryBarrierARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorMemoryBarrierARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorViewCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorViewCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorViewCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorViewCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTextureLODGatherFormatPropertiesAMD>() { return VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkTextureLODGatherFormatPropertiesAMD>() { return VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemoryBindInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemoryBindInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemoryRequirementsQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemoryRequirementsQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemorySizeInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemorySizeInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTilePropertiesQCOM>() { return VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTilePropertiesQCOM>() { return VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTimelineSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkTimelineSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkValidationFeaturesEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationFeaturesEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkValidationFlagsEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationFlagsEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkVertexInputAttributeDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkVertexInputAttributeDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkVertexInputBindingDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkVertexInputBindingDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT; }

#ifdef VK_USE_PLATFORM_VI_NN
  template <> constexpr VkStructureType ResolveSType<VkViSurfaceCreateInfoNN>() { return VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN; }
  template <> constexpr VkStructureType ResolveSType<const VkViSurfaceCreateInfoNN>() { return VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkVideoBeginCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoBeginCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoCodingControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoCodingControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264NaluSliceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264NaluSliceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265NaluSliceSegmentInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265NaluSliceSegmentInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeIntraRefreshCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeIntraRefreshCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeRateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeRateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeRateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeRateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionIntraRefreshCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionIntraRefreshCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEndCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEndCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatAV1QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatAV1QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatH265QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatH265QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatQuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatQuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoInlineQueryInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoInlineQueryInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoPictureResourceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoPictureResourceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoProfileListInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoProfileListInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoReferenceIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoReferenceIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoReferenceSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoReferenceSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionMemoryRequirementsKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionMemoryRequirementsKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionParametersUpdateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionParametersUpdateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <> constexpr VkStructureType ResolveSType<VkWaylandSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWaylandSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32KeyedMutexAcquireReleaseInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32KeyedMutexAcquireReleaseInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32KeyedMutexAcquireReleaseInfoNV>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32KeyedMutexAcquireReleaseInfoNV>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32SurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32SurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSet>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSet>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetAccelerationStructureKHR>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetAccelerationStructureKHR>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetInlineUniformBlock>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetInlineUniformBlock>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetPartitionedAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetPartitionedAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetTensorARM>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetTensorARM>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkWriteIndirectExecutionSetPipelineEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteIndirectExecutionSetPipelineEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkWriteIndirectExecutionSetShaderEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteIndirectExecutionSetShaderEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT; }

#ifdef VK_USE_PLATFORM_XCB_KHR
  template <> constexpr VkStructureType ResolveSType<VkXcbSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkXcbSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <> constexpr VkStructureType ResolveSType<VkXlibSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkXlibSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR; }
#endif
}

namespace vkroots {

  static VkResult implicit_wrap_CreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
          VkInstance*            pInstance) {
    VkInstanceProcAddrFuncs instanceProcAddrFuncs;
    VkResult procAddrRes = GetProcAddrs(pCreateInfo, &instanceProcAddrFuncs);
    if (procAddrRes != VK_SUCCESS)
      return procAddrRes;
    PFN_vkCreateInstance createInstanceProc = (PFN_vkCreateInstance) instanceProcAddrFuncs.NextGetInstanceProcAddr(nullptr, "vkCreateInstance");
    VkResult ret = createInstanceProc(pCreateInfo, pAllocator, pInstance);
    if (ret == VK_SUCCESS)
      tables::CreateDispatchTable(instanceProcAddrFuncs.NextGetInstanceProcAddr, instanceProcAddrFuncs.NextGetPhysicalDeviceProcAddr, *pInstance);
    return ret;
  }

}
namespace vkroots {
}

namespace vkroots::tables {

  static inline void CreateDispatchTable(PFN_vkGetInstanceProcAddr nextInstanceProcAddr, PFN_GetPhysicalDeviceProcAddr nextPhysDevProcAddr, VkInstance instance) {
    auto instanceDispatch = InstanceDispatches.create(instance, nextInstanceProcAddr, instance, nextPhysDevProcAddr);

    uint32_t physicalDeviceCount;
    VkResult res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, nullptr);
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res != VK_SUCCESS) return;
    std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
    res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, physicalDevices.data());
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res != VK_SUCCESS) return;

    instanceDispatch->PhysicalDevices.resize(physicalDevices.size());
    instanceDispatch->PhysicalDeviceDispatches.resize(physicalDevices.size());
    for (VkPhysicalDevice physicalDevice : physicalDevices) {
      const vkroots::VkPhysicalDeviceDispatch *pPhysicalDeviceDispatch = tables::AssignDispatchTable(physicalDevice, instanceDispatch);
      instanceDispatch->PhysicalDevices.push_back(physicalDevice);
      instanceDispatch->PhysicalDeviceDispatches.push_back(pPhysicalDeviceDispatch);
    }
  }

  static inline void CreateDispatchTable(const VkDeviceCreateInfo* pCreateInfo, PFN_vkGetDeviceProcAddr nextProcAddr, VkPhysicalDevice physicalDevice, VkDevice device) {
    auto physicalDeviceDispatch = vkroots::LookupDispatch(physicalDevice);
    auto deviceDispatch = DeviceDispatches.create(device, nextProcAddr, device, physicalDevice, physicalDeviceDispatch, pCreateInfo);

    for (uint32_t i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
      const auto &queueInfo = pCreateInfo->pQueueCreateInfos[i];
      for (uint32_t j = 0; j < queueInfo.queueCount; j++) {
        VkQueue queue;
        deviceDispatch->GetDeviceQueue(device, queueInfo.queueFamilyIndex, j, &queue);

        tables::AssignDispatchTable(queue, deviceDispatch);
      }
    }
  }

  static inline void DestroyDispatchTable(VkInstance instance) {
    const VkInstanceDispatch* instanceDispatch = InstanceDispatches.find(instance);
    assert(instanceDispatch);
    if (!instanceDispatch)
      return;

    uint32_t physicalDeviceCount;
    VkResult res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, nullptr);
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res == VK_SUCCESS) {
      std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
      res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, physicalDevices.data());
      assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
      if (res == VK_SUCCESS) {
        for (VkPhysicalDevice physicalDevice : physicalDevices)
          tables::UnassignDispatchTable(physicalDevice);
      }
    }

    InstanceDispatches.erase(instance);
  }

  static inline void DestroyDispatchTable(VkDevice device) {
    const VkDeviceDispatch* deviceDispatch = DeviceDispatches.find(device);
    assert(deviceDispatch);
    if (!deviceDispatch)
      return;

    for (const auto& queueInfo : deviceDispatch->DeviceQueueInfos) {
      for (uint32_t i = 0; i < queueInfo.queueCount; i++) {
        VkQueue queue;
        deviceDispatch->GetDeviceQueue(device, queueInfo.queueFamilyIndex, i, &queue);
        tables::UnassignDispatchTable(queue);
      }
    }

    DeviceDispatches.erase(device);
  }

}

namespace vkroots {

  template <typename Func>
  inline void delimitStringView(std::string_view view, std::string_view delim, Func func) {
    size_t pos = 0;
    while ((pos = view.find(delim)) != std::string_view::npos) {
      std::string_view token = view.substr(0, pos);
      if (!func(token))
        return;
      view = view.substr(pos + 1);
    }
    func(view);
  }

  inline bool contains(const std::vector<const char *> vec, std::string_view lookupValue) {
    return std::ranges::any_of(vec, std::bind_front(std::equal_to{}, lookupValue));
  }

  template <typename T, typename ArrType, typename Op>
  inline VkResult array(ArrType& arr, uint32_t *pCount, T* pOut, Op func) {
    const uint32_t count = uint32_t(arr.size());

    if (!pOut) {
      *pCount = count;
      return VK_SUCCESS;
    }

    const uint32_t outCount = std::min(*pCount, count);
    for (uint32_t i = 0; i < outCount; i++)
      func(pOut[i], arr[i]);

    *pCount = outCount;
    return count != outCount
      ? VK_INCOMPLETE
      : VK_SUCCESS;
  }

  template <typename T, typename ArrType>
  inline VkResult array(ArrType& arr, uint32_t *pCount, T* pOut) {
    return array(arr, pCount, pOut, [](T& x, const T& y) { x = y; });
  }

  // For dispatch functions, you might need eg:
  //   vkr_dispatch_bind( dispatch, GetPhysicalDeviceQueueFamilyProperties )
  template <typename Func, typename OutArray, typename... Args>
  uint32_t enumerate(Func function, OutArray& outArray, Args&&... arguments) {
    uint32_t count = 0;
    function(arguments..., &count, nullptr);

    outArray.resize(count);
    if (!count)
        return 0;

    function(std::forward<Args>(arguments)..., &count, outArray.data());
    return count;
  }

  // For dispatch functions, you might need eg:
  //   vkr_dispatch_bind( dispatch, GetPhysicalDeviceQueueFamilyProperties )
  template <typename Func, typename InArray, typename OutType, typename... Args>
  VkResult append(Func function, const InArray& inArray, uint32_t* pOutCount, OutType* pOut, Args&&... arguments) {
    uint32_t baseCount = 0;
    function(std::forward<Args>(arguments)..., &baseCount, nullptr);

    const uint32_t totalCount = baseCount + uint32_t(inArray.size());
    if (!pOut) {
      *pOutCount = totalCount;
      return VK_SUCCESS;
    }

    if (*pOutCount < totalCount) {
      function(std::forward<Args>(arguments)..., pOutCount, pOut);
      return VK_INCOMPLETE;
    }

    function(std::forward<Args>(arguments)..., &baseCount, pOut);
    for (size_t i = 0; i < inArray.size(); i++)
      pOut[baseCount + i] = inArray[i];
    return VK_SUCCESS;
  }

  template <typename SearchType, VkStructureType StructureTypeEnum, typename ChainBaseType>
  SearchType *chain(ChainBaseType* pNext) {
    for (VkBaseOutStructure* pBaseOut = reinterpret_cast<VkBaseOutStructure*>(pNext); pBaseOut; pBaseOut = pBaseOut->pNext) {
      if (pBaseOut->sType == StructureTypeEnum)
        return reinterpret_cast<SearchType*>(pBaseOut);
    }
    return nullptr;
  }

  #define vkr_dispatch_bind( dispatch, FuncName ) ( [&](auto... args){ ( dispatch ) . FuncName (args...); } )

  template <typename Type, typename UserData = uint64_t>
  class ChainPatcher {
  public:
    template <typename AnyStruct>
    ChainPatcher(const AnyStruct *obj, std::function<bool(UserData&, Type *)> func) {
      m_obj = (VkBaseOutStructure *)const_cast<AnyStruct*>(obj);

      // Remove the old value from the pNext chain.
      auto [in, header] = vkroots::RemoveFromChain<Type>(const_cast<AnyStruct *>(obj));
      m_in = in;
      m_header = header;

      // Copy that to our local version
      if (m_in) {
        m_value = *m_in;
        m_value.pNext = nullptr;
      } else {
        m_value.sType = ResolveSType<Type>();
      }

      // Add the function to pNext if func() returns true, OR we had it before.
      if (func(m_ctx, &m_value) || m_in) {
        m_value.pNext = std::exchange(m_obj->pNext, (VkBaseOutStructure*)&m_value);
      }
    }

    ~ChainPatcher() {
      auto [us, prev] = vkroots::RemoveFromChain<Type>(m_obj);
      assert(us == &m_value);

      // Patch up the pNext chain to undo our damage.
      // Ie. If one already existed in the chain before, point its header back to it.
      // For the other case, we needn't do anything as we already removed it with RemoveFromChain.
      if (m_in)
        m_header->pNext = (VkBaseOutStructure *)m_in; // Don't need to patch m_in's pNext as it will be what it was before.
    }

    template <typename AnyStruct>
    ChainPatcher(const AnyStruct *obj, std::function<bool(Type *)> func)
      : ChainPatcher(obj, [&](UserData& ctx, Type *obj) { return func(obj); }) {
    }

  private:
    VkBaseOutStructure *m_obj = nullptr; // The base object we started from in the chain.
    Type *m_in = nullptr; // The pointer to the thing we removed.
    VkBaseOutStructure *m_header = nullptr; // The pointer to the thing before the one we removed.

    Type m_value{};
    UserData m_ctx;
  };

  namespace log
  {
      enum LogLevel
      {
          Fatal,
          Error,
          Warning,
          Info,
          Debug,

          Count
      };

      constexpr std::string_view ToString(LogLevel level)
      {
          switch (level)
          {
              case Fatal:   return "fatal";
              case Error:   return "error";
              case Warning: return "warning";
              default:
              case Info:    return "info";
              case Debug:   return "debug";
          }
      }

      constexpr LogLevel FromString(std::string_view scope)
      {
          if (scope == "fatal")
              return Fatal;
          else if (scope == "error")
              return Error;
          else if (scope == "warning")
              return Warning;
          else if (scope == "debug")
              return Debug;
          else
              return Info;
      }

      constexpr std::string_view ToPrint(LogLevel level)
      {
          switch (level)
          {
              case Fatal:		return "\e[38;2;0;0;0;48;2;255;0;0m" "Fatal " "\e[0m";
              case Error:		return "\e[0;31m" "Error " "\e[0m";
              case Warning:	return " \e[0;33m" "Warn " "\e[0m";
              default:
              case Info:		return " \e[0;34m" "Info " "\e[0m";
              case Debug:		return "\e[0;35m" "Debug " "\e[0m";
          }
      }

      template <typename... Args>
      void print_log(std::string_view file, int line, LogLevel level, std::string_view prefix, std::format_string<Args...> fmt, Args&&... args)
      {
          std::string msg = std::format(std::move(fmt), std::forward<Args>(args)...);
          //std::print(stderr, "{} {}: {}\n", ToPrint(level), prefix, msg);
          int spaceCount = std::max(13 - int(prefix.length()), 0);
          std::string out = std::format("{}| {}{:>{}}| {} \e[0;90m({}:{})\e[0m", ToPrint(level), prefix, ' ', spaceCount, msg, file, line);
          std::cout << out << std::endl;
      }

      class LogScope
      {
      public:
          LogScope(std::string_view name, LogLevel maxLevel = log::Info)
              : LogScope(name, name, maxLevel)
          {
          }

          LogScope(std::string_view name, std::string_view prefix, LogLevel maxLevel = log::Info)
              : m_name{ name }
              , m_prefix{ prefix }
              , m_maxLevel{ maxLevel }
          {
          }

          ~LogScope()
          {
          }

          bool Enabled(LogLevel level) const
          {
              return level <= m_maxLevel;
          }

          void SetLevel(LogLevel level)
          {
              m_maxLevel = level;
          }

          template <typename... Args> 
          void log(std::string_view file, int line, LogLevel level, std::format_string<Args...> fmt, Args&&... args)
          {
              if (!Enabled(level))
                  return;

              print_log(file, line, level, m_prefix, std::move(fmt), std::forward<Args>(args)...);
          }

      private:
          std::string_view m_name;
          std::string_view m_prefix;

          LogLevel m_maxLevel = vkroots::log::Info;
      };

      namespace util
      {
          template <typename T, size_t S>
          constexpr size_t GetFileNameOffset(const T (& str)[S], size_t i = S - 1)
          {
              return (str[i] == '/' || str[i] == '\\') ? i + 1 : (i > 0 ? GetFileNameOffset(str, i - 1) : 0);
          }

          template <typename T>
          constexpr size_t GetFileNameOffset(T (& str)[1])
          {
              return 0;
          }
      }

      #define vkr_log_generic(scope, level, ...) \
          (log_ ## scope).log((&__FILE__[::vkroots::log::util::GetFileNameOffset(__FILE__)]), (__LINE__), (level), __VA_ARGS__)
      #define vkr_log_debug(scope, ...) vkr_log_generic(scope, ::vkroots::log::Debug, __VA_ARGS__)
      #define vkr_log_info(scope, ...) vkr_log_generic(scope, ::vkroots::log::Info, __VA_ARGS__)
      #define vkr_log_warn(scope, ...) vkr_log_generic(scope, ::vkroots::log::Warning, __VA_ARGS__)
      #define vkr_log_err(scope, ...) vkr_log_generic(scope, ::vkroots::log::Error, __VA_ARGS__)
      #define vkr_log_fatal(scope, ...) vkr_log_generic(scope, ::vkroots::log::Fatal, __VA_ARGS__)

  }


}
namespace vkroots {

  template <typename InstanceOverrides, typename DeviceOverrides>
  VkResult NegotiateLoaderLayerInterfaceVersion(VkNegotiateLayerInterface* pVersionStruct) {
    if (pVersionStruct->loaderLayerInterfaceVersion < 2)
      return VK_ERROR_INITIALIZATION_FAILED;
    pVersionStruct->loaderLayerInterfaceVersion = 2;

    // Can't optimize away not having instance overrides from the layer, need to track device creation and instance dispatch and stuff.
    pVersionStruct->pfnGetInstanceProcAddr       = std::is_base_of<NoOverrides, InstanceOverrides>::value && std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetInstanceProcAddr<InstanceOverrides, DeviceOverrides>;
    pVersionStruct->pfnGetPhysicalDeviceProcAddr = std::is_base_of<NoOverrides, InstanceOverrides>::value && std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetPhysicalDeviceProcAddr<InstanceOverrides, DeviceOverrides>;
    pVersionStruct->pfnGetDeviceProcAddr         = std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetDeviceProcAddr<InstanceOverrides, DeviceOverrides>;

    return VK_SUCCESS;
  }

}

// Sadly, can't include this in VKROOTS_DEFINE_LAYER_INTERFACES
// as we need the stupid pragma comment for stdcall aliasing on Win32.
// So you can only have one layer interface per compilation unit.
#ifndef VKROOTS_NEGOTIATION_INTERFACE
#define VKROOTS_NEGOTIATION_INTERFACE vkNegotiateLoaderLayerInterfaceVersion
#endif

#ifdef _WIN32

// Define VK_LAYER_EXPORT to dllexport.
# undef VK_LAYER_EXPORT
# define VK_LAYER_EXPORT extern "C" __declspec(dllexport)

// Fix stdcall aliasing on 32-bit Windows.
# ifndef _WIN64
#  pragma comment(linker, "/EXPORT:" #VKROOTS_NEGOTIATION_INTERFACE "=_" #VKROOTS_NEGOTIATION_INTERFACE "@8")
# endif

#elif defined(__GNUC__)

# undef VK_LAYER_EXPORT
# define VK_LAYER_EXPORT extern "C" __attribute__((visibility("default")))

#endif

#define VKROOTS_DEFINE_LAYER_INTERFACES(InstanceOverrides, DeviceOverrides)                                   \
  VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL VKROOTS_NEGOTIATION_INTERFACE(VkNegotiateLayerInterface* pVersionStruct) {            \
    return vkroots::NegotiateLoaderLayerInterfaceVersion<InstanceOverrides, DeviceOverrides>(pVersionStruct); \
  }
